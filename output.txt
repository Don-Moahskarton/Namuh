#include "Namuh_Main_H.h"using namespace Ogre;
Amnesic_Faune_mgr Amnesic_Faune_man;// Code des méthodes de la classe
Amnesic_Faune_mgr::Amnesic_Faune_mgr(void)
{
	initialised = false;
}
Amnesic_Faune_mgr::~Amnesic_Faune_mgr(void)
{
}void Amnesic_Faune_mgr::initialise(void)
{  
	if(!initialised)
	{
		initialised = true;		ActualEntityCount = 0;
		DisplayFakeDistance = 50; //temp
		MaxEntities = 10; //temp
		std::vector<Amnesic_Faune_Entity> Theonlyone;
		Amnesic_Entities.push_back(Theonlyone);
	}}void Amnesic_Faune_mgr::destroy(void)
{
}
void Amnesic_Faune_mgr::update(float Timelapse,Ogre::Vector2 playerpos)
{
	// pop some new animals. That's freeky stuff !
	Ogre::uint tryCount = ( MaxEntities - ActualEntityCount ) * 2; // two attempts to place each animal in average
	while(ActualEntityCount < MaxEntities && tryCount > 0)
	{
		GenerateNewAnimals(playerpos);
		tryCount--; 
	}	for(uint i = 0; i < Amnesic_Entities.size(); i++)
		for(uint j = 0; j < Amnesic_Entities[i].size(); j++)
		{			// update all animals
			Amnesic_Entities[i][j].update(Timelapse);
			
			// delete too far ones
			if(FakeDistance2D(	Amnesic_Entities[i][j].position.x, 
								Amnesic_Entities[i][j].position.z,
								playerpos.x,
								playerpos.y) > DisplayFakeDistance)
			{
				Amnesic_Entities[i][j].destroy();				
				Amnesic_Entities[i].erase(Amnesic_Entities[i].begin()+j);
				if(ActualEntityCount != 0)ActualEntityCount--;
			}
		}
}
void Amnesic_Faune_mgr::GenerateNewAnimals(Ogre::Vector2 playerpos)
{
	float	PoppingAngle1			= Math::RangeRandom(-1,1),
			PoppingAngle2			= Math::RangeRandom(-1,1);	Ogre::Vector2 NewPos(	playerpos.x + DisplayFakeDistance *0.8 *(PoppingAngle1),
							playerpos.y + DisplayFakeDistance *0.8 *(PoppingAngle2)); //TO_IMPROVE
	if(Hydrax_man.sea_level < terrain_height(NewPos.x, NewPos.y,0))
	{
		Amnesic_Faune_Entity NewAmnesicAnimal;
		Amnesic_Entities[0].push_back(NewAmnesicAnimal);
		Amnesic_Entities[0].back().initialise(NewPos);
		ActualEntityCount++;
	}
}uint FakeDistance2D (int x1, int y1, int x2, int y2) //{ return uint( std::sqrt((x1-x2)*(x1-x2) + (y1-y2)*(y1-y2) )); } // true distance for debugging purpose
	{ return ( (abs(x1-x2) + abs(y1-y2))*0.785 ); }
 #include "Namuh_Main_H.h"using namespace Ogre;
// Code des méthodes de la classe
Arc_En_Bois::Arc_En_Bois(void)
{
}
Arc_En_Bois::~Arc_En_Bois(void)
{
}
void Arc_En_Bois::initialise(RakNet::RakNetGUID Requested_Owner_id) // Tir !!
{
	NextProjectileID =0;
	Cooldown = 500; // 2flèches/sec	FlecheDescription.mMass = 2.6f;
	FlecheDescription.mLinearDamping = 0.002f;  
	FlecheDescription.mAngularDamping = 0.001f;
	FlecheDescription.mDynamicRigidbodyFlags += NxOgre::DynamicRigidbodyFlags::DisableGravity;	Owner = PlayerList[Requested_Owner_id];	WeaponMesh = sys0.mgr->createEntity("ArcEnBois" + StringConverter::toString(sys0.timer.getMilliseconds()),"ArcEnBois.mesh"); // Attention, risque de problème de nommage d'entité lors de plusieurs lance pierre (SAuf que 1 seul par joueur, m'enfin...)
	WeaponNode = Owner->CamNode->createChildSceneNode();
		WeaponNode->attachObject(WeaponMesh);
		WeaponNode->setPosition(0.2f,-0.30f,-0.5f);
}void Arc_En_Bois::fire(void) // Tir !!
{	if(LastfiredTimer+Cooldown < sys0.timer.getMilliseconds())
	{
		ldbg.send("Tir a l'arc");
		Ogre::Radian	angle_horizontal = Owner->Node->getOrientation().getYaw(),
						angle_vertical = Owner->rot.getPitch();
		NxOgre::Vec3 projectilepos = NxOgre::Vec3(	Owner->pos.x-Ogre::Math::Sin(angle_horizontal)*1.4,
													Owner->pos.y-0.2, 
													Owner->pos.z-Ogre::Math::Cos(angle_horizontal)*1.4);
		
		Critter::BodyDescription currentFlecheDescription = FlecheDescription; // New node for the projectile
		Projectile CurrentProjectile(Owner);
		CurrentProjectile.body = PhysX_man.mRenderSystem->createBody(NxOgre::BoxDescription(0.1f,0.1f,1.2f),NxOgre::Vec3(Owner->pos.x,Owner->pos.y,Owner->pos.z), "fleche.mesh",currentFlecheDescription);
		CurrentProjectile.body->setGlobalPosition(projectilepos);
		CurrentProjectile.body->setGlobalOrientationQuat(NxOgre::Quat(WeaponNode->convertLocalToWorldOrientation(WeaponNode->getOrientation()))); //caméra, bofbof
		CurrentProjectile.body->addLocalForce(NxOgre::Vec3(0,0,-80.0*currentFlecheDescription.mMass), NxOgre::Enums::ForceMode_SmoothImpulse);
		CurrentProjectile.body->setCCDMotionThreshold(0);
		CurrentProjectile.Date_Fired = sys0.timer.getMilliseconds();
		CurrentProjectile.CanDamage = true;
		ProjectileList.push_back(CurrentProjectile);		for (	std::map<RakNet::RakNetGUID, Perso*>::iterator PlayerIterator = PlayerList.begin();
				PlayerIterator != PlayerList.end();
				PlayerIterator++)
		{
			if(PlayerIterator->second->id != Owner->id)
			{
				
				ProjCallback myCallback;
				myCallback.ProjectileID = ProjectileList.size()-1;
				myCallback.AgressorID = Owner->id;
				myCallback.TargetID = PlayerIterator->second->id ;
				myCallback.type = ArcEnBois;
				ProjCallbackList.push_back(myCallback);
				CurrentProjectile.body->setContactCallback(&ProjCallbackList.back());				PlayerIterator->second->CharCtrl->setContactCallback(&ProjCallbackList.back());
				PhysX_man.mScene->setActorFlags(ProjectileList.back().body,PlayerIterator->second->CharCtrl, NxOgre::Enums::ContactPairFlags_All);
			}
		}
		NextProjectileID++;
		LastfiredTimer = sys0.timer.getMilliseconds();
	}
}
#include "Namuh_Main_H.h"using namespace Ogre;
Atm_mgr Atm_man;
// Code des méthodes de la classe
Atm_mgr::Atm_mgr(void)
{	
	SkyX::ColorGradient mWaterGradient= SkyX::ColorGradient(),mAmbientGradient= SkyX::ColorGradient(),mSunGradient = SkyX::ColorGradient();
	first_ini = true;
	initialised = false;}
Atm_mgr::~Atm_mgr(void)
{
}void Atm_mgr::initialise(void)
{  
	Vector3 lightDir= Ogre::Vector3::ZERO,lightAmb= Ogre::Vector3::ZERO;
	requested_hour = FloatFromName(Map.MapDataPool,"Time_Starting");
	Eastdir = FloatFromName(Map.MapDataPool,"World_East_Direction");
	mWaterGradient= SkyX::ColorGradient();
	mAmbientGradient= SkyX::ColorGradient();
	mSunGradient = SkyX::ColorGradient();
	Sunsethour = FloatFromName(Map.MapDataPool,"Time_Sunset");
	Sunrisehour = FloatFromName(Map.MapDataPool,"Time_Sunrise");
	 
	// Water color
	mWaterGradient.addCFrame(SkyX::ColorGradient::ColorFrame(Ogre::Vector3(0.168209f,0.635822f,0.779105f)*0.8f, 1.0f));
	mWaterGradient.addCFrame(SkyX::ColorGradient::ColorFrame(Ogre::Vector3(0.168209f,0.635822f,0.729105f)*0.6f, 0.8f));
	mWaterGradient.addCFrame(SkyX::ColorGradient::ColorFrame(Ogre::Vector3(0.168209f,0.635822f,0.679105f)*0.5f, 0.6f));
	mWaterGradient.addCFrame(SkyX::ColorGradient::ColorFrame(Ogre::Vector3(0.168209f,0.635822f,0.679105f)*0.4f, 0.5f));
	mWaterGradient.addCFrame(SkyX::ColorGradient::ColorFrame(Ogre::Vector3(0.168209f,0.635822f,0.679105f)*0.1f, 0.45f));
	mWaterGradient.addCFrame(SkyX::ColorGradient::ColorFrame(Ogre::Vector3(0.168209f,0.635822f,0.679105f)*0.025f, 0));
	// Ambient color
	mAmbientGradient.addCFrame(SkyX::ColorGradient::ColorFrame(Ogre::Vector3(1.0f,1.0f,1.0f)*1.0f, 1.0f));
	mAmbientGradient.addCFrame(SkyX::ColorGradient::ColorFrame(Ogre::Vector3(1.0f,1.0f,1.0f)*1.0f, 0.6f));
	mAmbientGradient.addCFrame(SkyX::ColorGradient::ColorFrame(Ogre::Vector3(1.0f,1.0f,1.0f)*0.6f, 0.5f));
	mAmbientGradient.addCFrame(SkyX::ColorGradient::ColorFrame(Ogre::Vector3(1.0f,1.0f,1.0f)*0.3f, 0.45f));
	mAmbientGradient.addCFrame(SkyX::ColorGradient::ColorFrame(Ogre::Vector3(1.0f,1.0f,1.0f)*0.1f, 0.35f));
	mAmbientGradient.addCFrame(SkyX::ColorGradient::ColorFrame(Ogre::Vector3(1.0f,1.0f,1.0f)*0.05f, 0.0f));
	// Sun
	mSunGradient.addCFrame(SkyX::ColorGradient::ColorFrame(Ogre::Vector3(0.8f,0.75f,0.55f)*1.5f, 1.0f));
	mSunGradient.addCFrame(SkyX::ColorGradient::ColorFrame(Ogre::Vector3(0.8f,0.75f,0.55f)*1.4f, 0.75f));
	mSunGradient.addCFrame(SkyX::ColorGradient::ColorFrame(Ogre::Vector3(0.8f,0.75f,0.55f)*1.3f, 0.5625f));
	mSunGradient.addCFrame(SkyX::ColorGradient::ColorFrame(Ogre::Vector3(0.6f,0.5f,0.2f)*1.5f, 0.5f));
	mSunGradient.addCFrame(SkyX::ColorGradient::ColorFrame(Ogre::Vector3(0.5f,0.5f,0.5f)*0.25f, 0.45f));
	mSunGradient.addCFrame(SkyX::ColorGradient::ColorFrame(Ogre::Vector3(0.5f,0.5f,0.5f)*0.01f, 0.0f));	if(first_ini)
	{
		mControler = new SkyX::BasicController();
		mSkyX = new SkyX::SkyX(sys0.mgr, &mControler);
		mSkyX->create();
		mControler.setMoonPhase(0.75f);
		sys0.mRoot->addFrameListener(mSkyX);
		sys0.win->addListener(mSkyX);		mSkyX->getCloudsManager()->add(SkyX::CloudLayer::Options());
	}
	mSkyX->getVCloudsManager()->setHeight(Vector2(FloatFromName(Map.MapDataPool,"Weather_Cloud_Altitude"),FloatFromName(Map.MapDataPool,"Weather_Cloud_Height")));
	
	if(BoolFromName(Map.MapDataPool,"Weather_Cloud_Enabled"))
	{
		if(first_ini)
			mSkyX->getVCloudsManager()->create(20000); // Le radius de SkyX influe sur l'altitude que l'on peut donner à la couche nuageuse
		mSkyX->getVCloudsManager()->setAutoupdate(true);
		mSkyX->getVCloudsManager()->getVClouds()->setWheater(FloatFromName(Map.MapDataPool,"Weather_Cloud_Humidity"),FloatFromName(Map.MapDataPool,"Weather_Cloud_Average_Width"),true); // average : 0.15,60,2
		mSkyX->getVCloudsManager()->getVClouds()->setWindDirection(Radian(FloatFromName(Map.MapDataPool,"Weather_Wind_Direction")));
		mSkyX->getVCloudsManager()->getVClouds()->setWindSpeed(FloatFromName(Map.MapDataPool,"Weather_Wind_Speed"));
	}
	if(!first_ini && !BoolFromName(Map.MapDataPool,"Weather_Cloud_Enabled") && mSkyX->getVCloudsManager() != NULL) // Si il faut enlever les nuwage
	{
		mSkyX->getVCloudsManager()->remove();
		delete mSkyX->getVCloudsManager();
	}
	Options.Exposure = FloatFromName(Map.MapDataPool,"Weather_Sky_Exposure");
	Options.MieMultiplier = FloatFromName(Map.MapDataPool,"Weather_Sky_MieMultiplier");
	mControler.setTime(Vector3(FloatFromName(Map.MapDataPool,"Time_Starting"),Sunrisehour,Sunsethour));
	Options.WaveLength = Vector3FromName(Map.MapDataPool,"Weather_Sky_WaveLength");
	mControler.setEastDirection(Vector2(cos(Eastdir),sin(Eastdir)));
	mSkyX->getAtmosphereManager()->setOptions(Options);	mSkyX->getVCloudsManager()->getVClouds()->setDistanceFallingParams(Ogre::Vector2(2,955));
	mSkyX->setTimeMultiplier(FloatFromName(Map.MapDataPool,"Time_Multiplier"));	
	initialised = true;
	first_ini = false;
}
void Atm_mgr::update(float ellapsed_time)
{
	Options = mSkyX->getAtmosphereManager()->getOptions();
	sys1.hour = static_cast<char>(mControler.getTime().x);
	sys1.min  = static_cast<char>((mControler.getTime().x - sys1.hour)*60);
	Ogre::Light *Light0 = sys0.mgr->getLight("SunLight"),*Light1 = sys0.mgr->getLight("SunLight1");
	lightDir =	mControler.getSunDirection();
	Light0->setPosition(sys0.cam->getDerivedPosition() - lightDir*mSkyX->getMeshManager()->getSkydomeRadius(sys0.cam)*0.02f);
	Light1->setDirection(lightDir);
	Light0->setDirection(lightDir);
	Map.terrainGlobals->setLightMapDirection(Light1->getDerivedDirection());
	Map.terrainGlobals->setCompositeMapDiffuse(Light1->getDiffuseColour());
	sunCol = mSunGradient.getColor(((lightDir.y +1 ) / 2.0f)); // Time_gradient : ((lightDir.y + 1.0f) / 2.0f)
	sunPos = sys0.cam->getDerivedPosition() - lightDir*mSkyX->getMeshManager()->getSkydomeRadius(sys0.cam)*0.1f;
	lightAmb = mAmbientGradient.getColor(((lightDir.y + 1) / 2.0f));
	Light0->setDiffuseColour(ColourValue(sunCol.x,sunCol.y,sunCol.z));
	Light1->setDiffuseColour(ColourValue(sunCol.x,sunCol.y,sunCol.z));
	sys0.mgr->setAmbientLight(ColourValue(lightAmb.x,lightAmb.y,lightAmb.z));
	//if(lastrequested_hour != requested_hour) mControler.setTime(Vector3(requested_hour,Sunrisehour,Sunsethour));
//	lastrequested_hour = requested_hour;
	mControler.setEastDirection(Vector2(cos(Eastdir),sin(Eastdir)));
	mSkyX->getAtmosphereManager()->setOptions(Options);
	mControler.update(ellapsed_time*mSkyX->getTimeMultiplier());
	mSkyX->update(ellapsed_time); 
}
void Atm_mgr::destroy(void)
{
//	delete mSkyX;
}#include "Namuh_Main_H.h"using namespace Ogre;
// Code des méthodes de la classe#include "Namuh_Main_H.h"using namespace Ogre;CstrMan CstrMgr;// Code des méthodes de la classe
CstrMan::CstrMan(void)
{
	// Definition de la syntaxe des fichier de Construction
	ParserBalise *Construction = new ParserBalise;
	Construction->Name = "Construction";
	Construction->StringKeywords.push_back("Name");
	Syntax.push_back(Construction);		ParserBalise Element = {"Element"};
		Syntax.back()->SousBalises.push_back(Element);
		
			Syntax.back()->SousBalises.back().Vector3Keywords.push_back("Position");
			Syntax.back()->SousBalises.back().FloatKeywords.push_back("Longueur");
			Syntax.back()->SousBalises.back().FloatKeywords.push_back("Diametre");
			Syntax.back()->SousBalises.back().StringKeywords.push_back("Type");
			Syntax.back()->SousBalises.back().StringKeywords.push_back("Name");			ParserBalise Orientation = {"Orientation"};
				Syntax.back()->SousBalises.back().SousBalises.push_back(Orientation);
				Syntax.back()->SousBalises.back().SousBalises.back().FloatKeywords.push_back("w");
				Syntax.back()->SousBalises.back().SousBalises.back().FloatKeywords.push_back("x");
				Syntax.back()->SousBalises.back().SousBalises.back().FloatKeywords.push_back("y");
				Syntax.back()->SousBalises.back().SousBalises.back().FloatKeywords.push_back("z");		ParserBalise Link = {"Link"};
		Syntax.back()->SousBalises.push_back(Link );
		
			Syntax.back()->SousBalises.back().StringKeywords.push_back("LinkName");
			Syntax.back()->SousBalises.back().StringKeywords.push_back("FirstBodyName");
			Syntax.back()->SousBalises.back().StringKeywords.push_back("SecondBodyName");}
CstrMan::~CstrMan(void)
{
}
 
Construction* CstrMan::Load(string FileName, Ogre::Vector3 CstrPosition, Ogre::Quaternion CstrOrientation)
{
	if(FileName != "")
	{
		std::vector<NamedDataPool> ConstructionDataPoolArray = Map_Parser.ParseFile(Syntax,ProfileMgr.ProfilePath+"Constructions/"+FileName);
		NamedDataPool ConstructionDataPool = ConstructionDataPoolArray[FindPoolIndexFromName(ConstructionDataPoolArray,"Construction")]; // On ne garde que la Pool construction
		LoadedConstructions.push_back(new Construction);		// Construit tout les nouveaux éléments
		for(	std::vector<NamedDataPool>::iterator PoolIterator = ConstructionDataPool.SubPool.begin();
				PoolIterator != ConstructionDataPool.SubPool.end();
				++PoolIterator)
			if((*PoolIterator).Name == "Element")
			{
				Ogre::Quaternion ElemOrientation = Ogre::Quaternion(	FloatFromName((*PoolIterator).SubPool[SubPoolsIndexesFromName((*PoolIterator), "Orientation").back()],"w"),
																		FloatFromName((*PoolIterator).SubPool[SubPoolsIndexesFromName((*PoolIterator), "Orientation").back()],"x"),
																		FloatFromName((*PoolIterator).SubPool[SubPoolsIndexesFromName((*PoolIterator), "Orientation").back()],"y"),
																		FloatFromName((*PoolIterator).SubPool[SubPoolsIndexesFromName((*PoolIterator), "Orientation").back()],"z"));				if(StringFromName(*PoolIterator,"Type") == "Rondin")
					this->Create_rondin(	LoadedConstructions.back(),
											Vector3FromName(*PoolIterator,"Position"),
											ElemOrientation,
											FloatFromName(*PoolIterator,"Diametre"),				
											FloatFromName(*PoolIterator,"Longueur"),
											StringFromName(*PoolIterator,"Name"));
				if(StringFromName(*PoolIterator,"Type") == "Rocher")
					this->Create_rocher(	LoadedConstructions.back(),
											Vector3FromName(*PoolIterator,"Position"),
											ElemOrientation,
											StringFromName(*PoolIterator,"Name"));
			}		// Construit tout les nouveaux link
		for(	std::vector<NamedDataPool>::iterator PoolIterator = ConstructionDataPool.SubPool.begin();
				PoolIterator != ConstructionDataPool.SubPool.end();
				++PoolIterator)
			if ((*PoolIterator).Name == "Link")
			{
				Critter::Body	*FirstBdy = NULL,
								*SecondBdy = NULL;
				// Cherche le premier body
				string firstbdyName = StringFromName(*PoolIterator,"FirstBodyName");
				for (	std::vector<Critter::Body*>::iterator itt = LoadedConstructions.back()->element.begin();
						itt != LoadedConstructions.back()->element.end();
						++itt)
						if((*itt)->getName() == firstbdyName)
							FirstBdy = *itt;
				// Cherche le second body
				string secondbdyName = StringFromName(*PoolIterator,"SecondBodyName");
				for (	std::vector<Critter::Body*>::iterator itt = LoadedConstructions.back()->element.begin();
						itt != LoadedConstructions.back()->element.end();
						++itt)
						if((*itt)->getName() == secondbdyName)
							SecondBdy = *itt;
				string LnkName = StringFromName(*PoolIterator,"LinkName");
				LoadedConstructions.back()->CreateFixedLink(FirstBdy, SecondBdy, LnkName);
			}		// Applique la rotation et l'orientation demandée
			LoadedConstructions.back()->setOrientation(CstrOrientation);
			LoadedConstructions.back()->setPosition(CstrPosition);		return LoadedConstructions.back();
	}
	else
		return NULL;
}void CstrMan::SaveAs(Construction* Cstr, string FileName)
{
	// construit la Datapool qui contient toutes les données a enregister
	NamedDataPool Construction_data;
	Construction_data.Name = "Construction";
	Construction_data.String_Data.push_back(*(new NamedString));
	Construction_data.String_Data.back().Name = "Name";
	Construction_data.String_Data.back().data = Cstr->name;	Ogre::Vector3 Origin = Ogre::Vector3::ZERO;
	if(Cstr->element.size())
	{
		Origin = Ogre::Vector3(	Cstr->element[0]->getGlobalPosition().x,
								Cstr->element[0]->getGlobalPosition().y,
								Cstr->element[0]->getGlobalPosition().z);		// met les éléments dans la datapool
		for(	std::vector<Critter::Body*>::iterator ElementsIterator = Cstr->element.begin();
				ElementsIterator != Cstr->element.end();
				++ElementsIterator)
		{
			// nouvel élément
			Construction_data.SubPool.push_back(*(new NamedDataPool));
			Construction_data.SubPool.back().Name = "Element";			// Type d'élément
			Construction_data.SubPool.back().String_Data.push_back(*(new NamedString));
			Construction_data.SubPool.back().String_Data.back().Name = "Type";
			if((*ElementsIterator)->getShape(0)->getShapeType() == 493) // Si Trianglegeometry Shape (Rocher)
				Construction_data.SubPool.back().String_Data.back().data = "Rocher";
			if((*ElementsIterator)->getShape(0)->getShapeType() == 484) // Si Capsule Shape (Rondin)
			{
				Construction_data.SubPool.back().String_Data.back().data = "Rondin";
				
				// Diamètre du rondin
				Construction_data.SubPool.back().Float_Data.push_back(*(new NamedFloat));
				Construction_data.SubPool.back().Float_Data.back().Name = "Diametre";
				Construction_data.SubPool.back().Float_Data.back().data = static_cast<NxOgre::Capsule*>((*ElementsIterator)->getShape(0))->getRadius()*2;				// Diamètre du rocher
				Construction_data.SubPool.back().Float_Data.push_back(*(new NamedFloat));
				Construction_data.SubPool.back().Float_Data.back().Name = "Longueur";
				Construction_data.SubPool.back().Float_Data.back().data = static_cast<NxOgre::Capsule*>((*ElementsIterator)->getShape(0))->getHeight();
			}			// position
			Construction_data.SubPool.back().Vector3_Data.push_back(*(new NamedVector3));
			Construction_data.SubPool.back().Vector3_Data.back().Name = "Position";
			Construction_data.SubPool.back().Vector3_Data.back().data = Ogre::Vector3(	(*ElementsIterator)->getGlobalPosition().x,
																						(*ElementsIterator)->getGlobalPosition().y,
																						(*ElementsIterator)->getGlobalPosition().z) - Origin;
			// nom
			Construction_data.SubPool.back().String_Data.push_back(*(new NamedString));
			Construction_data.SubPool.back().String_Data.back().Name = "Name";
			Construction_data.SubPool.back().String_Data.back().data = string((*ElementsIterator)->getName().c_str());			// Orientation
			Construction_data.SubPool.back().SubPool.push_back(*(new NamedDataPool));
			Construction_data.SubPool.back().SubPool.back().Name = "Orientation";
				Construction_data.SubPool.back().SubPool.back().Float_Data.push_back(*(new NamedFloat));
				Construction_data.SubPool.back().SubPool.back().Float_Data.back().Name = "w";
				Construction_data.SubPool.back().SubPool.back().Float_Data.back().data = (*ElementsIterator)->getGlobalOrientationQuat().w;
				Construction_data.SubPool.back().SubPool.back().Float_Data.push_back(*(new NamedFloat));
				Construction_data.SubPool.back().SubPool.back().Float_Data.back().Name = "x";
				Construction_data.SubPool.back().SubPool.back().Float_Data.back().data = (*ElementsIterator)->getGlobalOrientationQuat().x;
				Construction_data.SubPool.back().SubPool.back().Float_Data.push_back(*(new NamedFloat));
				Construction_data.SubPool.back().SubPool.back().Float_Data.back().Name = "y";
				Construction_data.SubPool.back().SubPool.back().Float_Data.back().data = (*ElementsIterator)->getGlobalOrientationQuat().y;
				Construction_data.SubPool.back().SubPool.back().Float_Data.push_back(*(new NamedFloat));
				Construction_data.SubPool.back().SubPool.back().Float_Data.back().Name = "z";
				Construction_data.SubPool.back().SubPool.back().Float_Data.back().data = (*ElementsIterator)->getGlobalOrientationQuat().z;		}
		
		// met les joints dans la datapool
		for(	std::vector<NxOgre_NamedJoint>::iterator LinkIterator = Cstr->joint.begin();
				LinkIterator != Cstr->joint.end();
				++LinkIterator)
		{
			// nouveau link
			Construction_data.SubPool.push_back(*(new NamedDataPool));
			Construction_data.SubPool.back().Name = "Link";			// nom
			Construction_data.SubPool.back().String_Data.push_back(*(new NamedString));
			Construction_data.SubPool.back().String_Data.back().Name = "LinkName";
			Construction_data.SubPool.back().String_Data.back().data = string((*LinkIterator).name);			// Premier Body
			Construction_data.SubPool.back().String_Data.push_back(*(new NamedString));
			Construction_data.SubPool.back().String_Data.back().Name = "FirstBodyName";
			Construction_data.SubPool.back().String_Data.back().data = string((*LinkIterator).joint->getFirstRigidBody()->getName().c_str());			// Second Body
			Construction_data.SubPool.back().String_Data.push_back(*(new NamedString));
			Construction_data.SubPool.back().String_Data.back().Name = "SecondBodyName";
			Construction_data.SubPool.back().String_Data.back().data = string((*LinkIterator).joint->getSecondRigidBody()->getName().c_str());
		}
	}
	std::vector<NamedDataPool*> Construction_data_vector;
	Construction_data_vector.push_back(&Construction_data);
	
	// écris le fichier
	if(FileName == "")
		FileName = "Untitled" + StringConverter::toString(sys0.timer.getMicroseconds());
	File_Serialiser.WriteFile(Construction_data_vector,ProfileMgr.ProfilePath+"Constructions/"+FileName+".nmh");}
Construction* CstrMan::CreateNew(void)
{
	LoadedConstructions.push_back(new Construction);
	return LoadedConstructions.back();
}void CstrMan::Destroy(Construction* Cstr)
{
	// détruits les bodys
	for(	std::vector<Critter::Body*>::iterator ElementsIterator = Cstr->element.begin();
			ElementsIterator != Cstr->element.end();
			++ElementsIterator)
	{
		// delete Ogre's node
		sys0.mgr->destroySceneNode((*ElementsIterator)->getNode()->getSceneNode());		// Delete PhysX's body (Yes, we can cast a Rigidbody to a Critter's Body)
		PhysX_man.mRenderSystem->destroyBody((*ElementsIterator));		// Unregister the element from the construction
		for(Ogre::uint i = 0; i<Cstr->element.size(); ++i)
			if(Cstr->element[i] == (*ElementsIterator))
				Cstr->element.erase(Cstr->element.begin()+i);		// Unregister related links				
		for(Ogre::uint i = 0; i<Cstr->joint.size(); ++i)
			if(Cstr->joint[i].joint->getFirstRigidBody() == (*ElementsIterator) ||
			   Cstr->joint[i].joint->getSecondRigidBody() == (*ElementsIterator))
				Cstr->DestroyJoint(Cstr->joint[i].joint);
				
	}
}
void CstrMan::Create_rondin(Construction* Container, Ogre::Vector3 Position, Ogre::Quaternion Orientation, float diametre, float longueur, string name)
{
	// Protections
	if(diametre == 0) diametre = 0.001f;
	if(longueur == 0) longueur = 0.001f;
	// Faire un BodyDescription pour chaque nouveau Body
	Critter::BodyDescription rondinDescription;
	rondinDescription.mNode = new Critter::Node(sys0.mgr,Container->root->getNode()->getSceneNode(),PhysX_man.mRenderSystem); // accroche le rondin au noeud racine de la construction
	// m = µ * pi * r² * h 
	rondinDescription.mMass = 650*3.1415926*(diametre/2)*(diametre/2)*longueur; //masse volumique du bois : 650 kg/m^3
	rondinDescription.mLinearDamping = 0.12f;  
	rondinDescription.mAngularDamping = 0.11f;
	if (name == "")
		rondinDescription.mName = "Rondin"+ StringConverter::toString(sys0.timer.getMilliseconds());
	else 
		rondinDescription.mName = name;	// Crée l'objet en lui meme
	Critter::Body*	rondin = PhysX_man.mRenderSystem->createBody(NxOgre::CapsuleDescription(diametre/2,longueur),NxOgre::Vec3(Position), "Rondin.mesh",rondinDescription);
	rondin->setGlobalOrientationQuat(NxOgre::Quat(Orientation));
	rondin->getNode()->getSceneNode()->scale(diametre/2,longueur/10,diametre/2);
	PhysXfloater.add(rondin);
	rondin->setSolverIterationCount(80); // Lent	// L'enregistr comme partie intégrante de la construction demandée
	Container->element.push_back(rondin);	
}void CstrMan::Create_rocher(Construction* Container, Ogre::Vector3 Position, Ogre::Quaternion Orientation, string name)
{
	// Faire un BodyDescription pour chaque nouveau Body
	Critter::BodyDescription rocherDescription;
	rocherDescription.mNode = new Critter::Node(sys0.mgr,Container->root->getNode()->getSceneNode(),PhysX_man.mRenderSystem); // accroche le rocher au noeud racine de la construction
	rocherDescription.mMass = 5850;
	rocherDescription.mLinearDamping = 0.12f;  
	rocherDescription.mAngularDamping = 0.11f;
	if (name == "")
		rocherDescription.mName = "Rocher"+ toOgStr(sys0.timer.getMilliseconds());
	else 
		rocherDescription.mName = name;	// Crée l'objet en lui meme
	Critter::Body* rocher = PhysX_man.mRenderSystem->createBody(NxOgre::ConvexDescription(RocherMesh),NxOgre::Vec3(Position), "rocher.mesh",rocherDescription);
	rocher->setGlobalOrientationQuat(NxOgre::Quat(Orientation));
	//rocher->setSolverIterationCount(80); // Lent	// L'enregistre comme partie intégrante de la construction demandée
	Container->element.push_back(rocher);	
}void CstrMan::Create_triangle(Construction* Container, Ogre::Vector3 Position, Ogre::Quaternion Orientation, float diametre, float longueur, string name)
{
	Ogre::Matrix3	localToGlobal = Ogre::Matrix3::ZERO,
					GLobalToLocal;
	Orientation.ToRotationMatrix(localToGlobal);
	GLobalToLocal = localToGlobal.Inverse();	// les trois rondins du triangle
	Create_rondin(Container,Position + localToGlobal * 0.5 * Ogre::Vector3(0.0f,0.0f, 0.43f * longueur) ,Orientation * Ogre::Quaternion(Degree(90), Vector3::UNIT_X) * Ogre::Quaternion(Degree(90), Vector3::UNIT_Z),diametre,longueur,name + "_log1"); // 0.43 = sqrt(3)/4
	Create_rondin(Container,Position + localToGlobal * 0.5  * Ogre::Vector3(0.37f * longueur,0.0f, -0.22f * longueur),Orientation* Ogre::Quaternion(Degree(90), Vector3::UNIT_X) * Ogre::Quaternion(Degree(-30), Vector3::UNIT_Z),diametre,longueur,name + "_log1");
	Create_rondin(Container,Position + localToGlobal * 0.5  * Ogre::Vector3(-0.37f * longueur,0.0f, -0.22f * longueur),Orientation * Ogre::Quaternion(Degree(90), Vector3::UNIT_X) * Ogre::Quaternion(Degree(30), Vector3::UNIT_Z),diametre,longueur,name + "_log3");
	
	NxOgre::RigidBody*	first = static_cast<NxOgre::RigidBody*>(Container->element[Container->element.size() - 3]),
						*second = static_cast<NxOgre::RigidBody*>(Container->element[Container->element.size() - 2]),
						*third = static_cast<NxOgre::RigidBody*>(Container->element[Container->element.size() - 1]);
	// Soude le triangle
	Container->CreateFixedLink(first,second, "triangle" + toOgStr(sys0.timer.getMilliseconds()) + " Fixed " + first->getName() + " <==> " + second->getName());
	Container->CreateFixedLink(second, third, "triangle" + toOgStr(sys0.timer.getMilliseconds()) + " Fixed " + second->getName() + " <==> " + third->getName());
	Container->CreateFixedLink(third, first, "triangle" + toOgStr(sys0.timer.getMilliseconds()) + " Fixed " + third->getName() + " <==> " + first->getName());
}
#include "Namuh_Main_H.h"
using namespace Ogre;
Construction::Construction(void)
{
	name = "Construction" + StringConverter::toString(sys0.timer.getMicroseconds());
	root = PhysX_man.mRenderSystem->createBody(NxOgre::BoxDescription(0.0f), NxOgre::Matrix44::IDENTITY, Critter::BodyDescription());
	root->getNode()->setPosition(0,0,0);
}
Construction::~Construction(void)
{
}
/* // We don't need other link type than fixed. Revolute ones are well made by a Torus.
void Construction::CreateRevoluteLink(NxOgre::RigidBody* FirstBody, NxOgre::RigidBody* SecondBody, string name)
{
	NxOgre::RevoluteJointDescription join_descr = NxOgre::RevoluteJointDescription();
	join_descr.mLocalAnchor[0] = NxOgre::Vec3(NxOgre::Vec3(3,0,0));
	join_descr.mLocalAxis[0] = NxOgre::Vec3(0,1,0);
	join_descr.mLocalNormal[0] = NxOgre::Vec3(1,0,0);
	join_descr.mLocalAnchor[1] = NxOgre::Vec3(NxOgre::Vec3(0,0,0));
	join_descr.mLocalAxis[1] = NxOgre::Vec3(0,1,0);
	join_descr.mLocalNormal[1] = NxOgre::Vec3(1,0,0);
	join_descr.mJointFlags = NxOgre::Enums::JointFlag_Visualisation | NxOgre::Enums::JointFlag_CollisionEnabled;
	
	//join_descr.mLocalAnchor[0] = NxOgre::Vec3(FirstBody->getShape(0)->getGlobalPose()) + NxOgre::Vec3(0,0.5,0);
	
//	join_descr.mLocalAxis[1] = NxOgre::Vec3(0,1,0);
	//join_descr.mLocalNormal[1] = NxOgre::Vec3(1,0,0);
	//join_descr.mLocalAnchor[1] = NxOgre::Vec3(SecondBody->getShape(0)->getGlobalPose()) + NxOgre::Vec3(0,0,0);
	//join_descr.mMotor = NxOgre::MotorDescription(50 , 1000000,true);
	
	NxOgre_NamedJoint NewJoint;
	NewJoint.joint = PhysX_man.mScene->createRevoluteJoint(FirstBody,SecondBody,join_descr);
	if(name == "")
		NewJoint.name = "Revolute " + FirstBody->getName() + " <==> " + SecondBody->getName();
	else
		NewJoint.name = name;
	joint.push_back(NewJoint);
	NewJoint.joint->getJointType();
}
*/
void Construction::CreateFixedLink(NxOgre::RigidBody* FirstBody, NxOgre::RigidBody* SecondBody, string name)
{	NxOgre_NamedJoint NewJoint;
	NewJoint.joint = PhysX_man.mScene->createFixedJoint(FirstBody,SecondBody);
	if(name == "")
		NewJoint.name = "Fixed "+ FirstBody->getName() + " <==> " + SecondBody->getName();
	else
		NewJoint.name = name;
	joint.push_back(NewJoint);
}
void Construction::DestroyJoint(NxOgre::Joint* Joint)
{
	// PhysX deletion
	Joint->setBreakable(0.00001f,0.000001f);
	//PhysX_man.mScene->destroyJoint(Joint);  // don't work (NxOgre bug)
		//Unregistering from construstion
	for (Ogre::uint i = 0; i<joint.size(); ++i)
		if(joint[i].joint == Joint)
		{
			//NxOgre::Joint* jointToDel = joint[i].joint;
			joint.erase(joint.begin()+i);
			//PhysX_man.mScene->destroyJoint(jointToDel);
		}
}
void Construction::Rotate(Ogre::Quaternion NewRelativeOrentation)
{
	root->setGlobalOrientationQuat(root->getGlobalOrientationQuat() * NewRelativeOrentation);	for (Ogre::uint i = 0; i<element.size(); ++i)
	{
		element[i]->setGlobalOrientationQuat(element[i]->getGlobalOrientationQuat() * root->getGlobalOrientationQuat());
		element[i]->setGlobalPosition(root->getGlobalPosition() + element[i]->getCMassLocalPosition());
	}
}void Construction::setOrientation(Ogre::Quaternion NewAbsoluteOrentation)
{
	root->setGlobalOrientationQuat(NewAbsoluteOrentation);
	
	for (Ogre::uint i = 0; i<element.size(); ++i)
	{
		element[i]->setGlobalOrientationQuat(element[i]->getGlobalOrientationQuat() * root->getGlobalOrientationQuat());
		element[i]->setGlobalPosition(root->getGlobalPosition() + element[i]->getCMassLocalPosition());
	}
}void Construction::Move(Ogre::Vector3 NewRelativePosition)
{
//	root->setGlobalPosition(root->getGlobalPosition() + NxOgre::Vec3(NewRelativePosition));
	
	for (Ogre::uint i = 0; i<element.size(); ++i)
	{
		NxOgre::Vec3 pos = NxOgre::Vec3(element[i]->getNode()->getSceneNode()->getPosition()) + root->getGlobalPosition();
		element[i]->setGlobalPose(NxOgre::Matrix44(pos));
	}}void Construction::setPosition(Ogre::Vector3 NewAbsolutePosition)
{
//	root->setGlobalPosition(NewAbsolutePosition);
	
	for (Ogre::uint i = 0; i<element.size(); ++i)
	{
		NxOgre::Vec3 pos = NxOgre::Vec3(element[i]->getNode()->getSceneNode()->getPosition()) + root->getGlobalPosition();
		element[i]->setGlobalPose(NxOgre::Matrix44(pos));
	}
}#include "Namuh_Main_H.h"using namespace Ogre;DeathMatchRules Ruler;DeathMatchRules::DeathMatchRules(void)
{
}
void DeathMatchRules::initialise(void)
{	
	EndOfGame =false;
}void DeathMatchRules::update(void)
{	
	if(raknet_man.isServer)
		for (	std::map<RakNet::RakNetGUID, Perso*>::iterator PlayerIterator = PlayerList.begin();
				PlayerIterator != PlayerList.end();
				PlayerIterator++)
			if(PointList[PlayerIterator->first] >= 20)
			{
				EndOfGame =true;
				RakNet::BitStream bsOut;
				bsOut.Write((RakNet::MessageID)StC_GAME_END);
				raknet_man.peer->Send(&bsOut,HIGH_PRIORITY,RELIABLE_ORDERED,0,RakNet::UNASSIGNED_SYSTEM_ADDRESS,true);
			}
}void DeathMatchRules::NoticeFrag(RakNet::RakNetGUID id_Victim, RakNet::RakNetGUID id_Criminal)
{	
	PointList[id_Victim] -= 1;
	PointList[id_Criminal] += 2;
	
	if(raknet_man.initialised && raknet_man.isServer)
	{
		// Prévient les clients du changemrnt points
		RakNet::BitStream bsOut;
		bsOut.Write((RakNet::MessageID)StC_PLAYER_PTS);
		bsOut.Write(id_Victim);
		bsOut.Write(int(PointList[id_Victim]*100));
		raknet_man.peer->Send(&bsOut,HIGH_PRIORITY,RELIABLE_ORDERED,0,RakNet::UNASSIGNED_SYSTEM_ADDRESS,true);
		bsOut.Reset();
		bsOut.Write((RakNet::MessageID)StC_PLAYER_PTS);
		bsOut.Write(id_Criminal);
		bsOut.Write(int(PointList[id_Criminal]*100));
		raknet_man.peer->Send(&bsOut,HIGH_PRIORITY,RELIABLE_ORDERED,0,RakNet::UNASSIGNED_SYSTEM_ADDRESS,true);
	}
}void DeathMatchRules::NoticeScuicide(RakNet::RakNetGUID id_Noob)
{	
	PointList[id_Noob] -= 0.5;
	if(raknet_man.initialised && raknet_man.isServer)
	{
		// Prévient les clients du changemrnt points
		RakNet::BitStream bsOut;
		bsOut.Write((RakNet::MessageID)StC_PLAYER_PTS);
		bsOut.Write(id_Noob);
		bsOut.Write(int(PointList[id_Noob]*100));
		raknet_man.peer->Send(&bsOut,HIGH_PRIORITY,RELIABLE_ORDERED,0,RakNet::UNASSIGNED_SYSTEM_ADDRESS,true);
	}
}void DeathMatchRules::destroy(void)
{	
	EndOfGame =false;
	PointList.erase(PointList.begin(),PointList.end());
}
DeathMatchRules::~DeathMatchRules(void)
{
}
#include "Namuh_Main_H.h"using namespace Ogre;
Faune_Entity::Faune_Entity(void)
{	
}
Faune_Entity::~Faune_Entity(void)
{
}void Faune_Entity::initialise(Faune_Page* Containing_Page, Ogre::Vector3 RequestedPos)
{  
	Container = Containing_Page;
	AnimalEntity = sys0.mgr->createEntity("Animal" + StringConverter::toString(sys0.timer.getMicroseconds()),"Fish01.mesh");
	AnimalNode = sys0.mgr->getRootSceneNode()->createChildSceneNode();
	//AnimalNode->setScale(0.5,0.5,0.5);
	AnimalNode->attachObject(AnimalEntity);
	AnimalNode->setPosition(	RequestedPos.x,
								Math::RangeRandom(terrain_height(RequestedPos.x, RequestedPos.z,0),Hydrax_man.sea_level),
								RequestedPos.z); //Fishes are always upside up
	AnimalNode->setFixedYawAxis(true, Ogre::Vector3::UNIT_Y);  //
	position = AnimalNode->getPosition();
	linearVelocity = Ogre::Vector3::ZERO;}void Faune_Entity::update(float Timelapse)
{
	if(Timelapse <= 0.0f) Timelapse = 0.002f;
	// See details at http://fr.wikipedia.org/wiki/Boids
			// Compute attraction center (cohesion component) plus the number of enlarged neiboors
	Ogre::Vector3 AttractionCenter = Ogre::Vector3::ZERO;
	float AttractionCenterWeightstSum = 0.0f;	if( Container->Bottom != NULL)
	{
		for (Ogre::uint i = 0; i < Container->Bottom->ContainedEntities.size(); ++i)
		{
			AttractionCenter += (Container->Bottom->ContainedEntities[i]->position - position) * (Container->Bottom->ContainedEntities[i]->position - position).squaredLength();
			AttractionCenterWeightstSum += 1 - 0.002 * (Container->Bottom->ContainedEntities[i]->position - position).squaredLength();
		}
	}
	if( Container->BottomLeft != NULL)
	{
		for (Ogre::uint i = 0; i < Container->BottomLeft->ContainedEntities.size(); ++i)
		{
			AttractionCenter += (Container->BottomLeft->ContainedEntities[i]->position - position) * (Container->BottomLeft->ContainedEntities[i]->position - position).squaredLength();
			AttractionCenterWeightstSum += 1 - 0.002 * (Container->BottomLeft->ContainedEntities[i]->position - position).squaredLength();
		}
	}
	if( Container->BottomRight != NULL)
	{
		for (Ogre::uint i = 0; i < Container->BottomRight->ContainedEntities.size(); ++i)
		{
			AttractionCenter += (Container->BottomRight->ContainedEntities[i]->position - position) * (Container->BottomRight->ContainedEntities[i]->position - position).squaredLength();
			AttractionCenterWeightstSum += 1 - 0.002 * (Container->BottomRight->ContainedEntities[i]->position - position).squaredLength();
		}
	}
	if( Container->Right != NULL)
	{
		for (Ogre::uint i = 0; i < Container->Right->ContainedEntities.size(); ++i)
		{
			AttractionCenter += (Container->Right->ContainedEntities[i]->position - position) * (Container->Right->ContainedEntities[i]->position - position).squaredLength();
			AttractionCenterWeightstSum += 1 - 0.002 * (Container->Right->ContainedEntities[i]->position - position).squaredLength();
		}
	}
	if( Container->Left != NULL)
	{
		for (Ogre::uint i = 0; i < Container->Left->ContainedEntities.size(); ++i)
		{
			AttractionCenter += (Container->Left->ContainedEntities[i]->position - position) * (Container->Left->ContainedEntities[i]->position - position).squaredLength();
			AttractionCenterWeightstSum += 1 - 0.002 * (Container->Left->ContainedEntities[i]->position - position).squaredLength();
		}
	}
	if( Container->Top != NULL)
	{
		for (Ogre::uint i = 0; i < Container->Top->ContainedEntities.size(); ++i)
		{
			AttractionCenter += (Container->Top->ContainedEntities[i]->position - position) * (Container->Top->ContainedEntities[i]->position - position).squaredLength();
			AttractionCenterWeightstSum += 1 - 0.002 * (Container->Top->ContainedEntities[i]->position - position).squaredLength();
		}
	}
	if( Container->TopLeft != NULL)
	{
		for (Ogre::uint i = 0; i < Container->TopLeft->ContainedEntities.size(); ++i)
		{
			AttractionCenter += (Container->TopLeft->ContainedEntities[i]->position - position) * (Container->TopLeft->ContainedEntities[i]->position - position).squaredLength();
			AttractionCenterWeightstSum += 1 - 0.002 * (Container->TopLeft->ContainedEntities[i]->position - position).squaredLength();
		}
	}
	if( Container->TopRight != NULL)
	{
		for (Ogre::uint i = 0; i < Container->TopRight->ContainedEntities.size(); ++i)
		{
			AttractionCenter += (Container->TopRight->ContainedEntities[i]->position - position) * (Container->TopRight->ContainedEntities[i]->position - position).squaredLength();
			AttractionCenterWeightstSum += 1 - 0.002 * (Container->TopRight->ContainedEntities[i]->position - position).squaredLength();
		}
	}
		if(AttractionCenterWeightstSum != 0.0f)
		AttractionCenter /= AttractionCenterWeightstSum;	Ogre::Vector3 AttractionComponent = AttractionCenter;
	
	// Compute repultion center (separation component)
	Ogre::Vector3 RepultionTerms = Ogre::Vector3::ZERO;
	float RepulionTermsWeightstSum = 0.0f;	float RepulionTermWeight = 0.0f;
	for (Ogre::uint i = 0; i < Container->ContainedEntities.size(); ++i)
	{
		RepulionTermWeight = 1 - 0.004 * (Container->ContainedEntities[i]->position - position).squaredLength(); // The closer is the neiboor, the more is it imortant to get away from him
		RepulionTermsWeightstSum += RepulionTermWeight;
		RepultionTerms += (Container->ContainedEntities[i]->position - position) * RepulionTermWeight;
	}	if(RepulionTermsWeightstSum != 0.0f)
		RepultionTerms /= RepulionTermsWeightstSum;
	// Since now RepultionTerms points the center of repultion
	
	Ogre::Vector3 RepultionComponent = -1 * RepultionTerms;
		// Compute average speed vector (alignment component)
	Ogre::Vector3 AverageVelocity = Ogre::Vector3::ZERO;	if( Container->Bottom != NULL)
		for (Ogre::uint i = 0; i < Container->Bottom->ContainedEntities.size(); ++i)
			if(Container->Bottom->ContainedEntities[i]->linearVelocityHistory.size())
				// on prend a la fin de l'historique pour simuler une perception retardée
				AverageVelocity += Container->Bottom->ContainedEntities[i]->linearVelocityHistory.back() * (1 - 0.002 * (Container->Bottom->ContainedEntities[i]->position - position).squaredLength()); 
	if( Container->BottomLeft != NULL)
		for (Ogre::uint i = 0; i < Container->BottomLeft->ContainedEntities.size(); ++i)
			if(Container->BottomLeft->ContainedEntities[i]->linearVelocityHistory.size())
				AverageVelocity += Container->BottomLeft->ContainedEntities[i]->linearVelocityHistory.back() * (1 - 0.002 * (Container->BottomLeft->ContainedEntities[i]->position - position).squaredLength());
	if( Container->BottomRight != NULL)
		for (Ogre::uint i = 0; i < Container->BottomRight->ContainedEntities.size(); ++i)
			if(Container->BottomRight->ContainedEntities[i]->linearVelocityHistory.size())
				AverageVelocity += Container->BottomRight->ContainedEntities[i]->linearVelocityHistory.back() * (1 - 0.002 * (Container->BottomRight->ContainedEntities[i]->position - position).squaredLength());
	if( Container->Right != NULL)
		for (Ogre::uint i = 0; i < Container->Right->ContainedEntities.size(); ++i)
			if(Container->Right->ContainedEntities[i]->linearVelocityHistory.size())
				AverageVelocity += Container->Right->ContainedEntities[i]->linearVelocityHistory.back() *(1 - 0.002 *  (Container->Right->ContainedEntities[i]->position - position).squaredLength());
	if( Container->Left != NULL)
		for (Ogre::uint i = 0; i < Container->Left->ContainedEntities.size(); ++i)
			if(Container->Left->ContainedEntities[i]->linearVelocityHistory.size())
				AverageVelocity += Container->Left->ContainedEntities[i]->linearVelocityHistory.back() *(1 - 0.002 *  (Container->Left->ContainedEntities[i]->position - position).squaredLength());
	if( Container->Top != NULL)
		for (Ogre::uint i = 0; i < Container->Top->ContainedEntities.size(); ++i)
			if(Container->Top->ContainedEntities[i]->linearVelocityHistory.size())
				AverageVelocity += Container->Top->ContainedEntities[i]->linearVelocityHistory.back() * (1 - 0.002 * (Container->Top->ContainedEntities[i]->position - position).squaredLength());
	if( Container->TopLeft != NULL)
		for (Ogre::uint i = 0; i < Container->TopLeft->ContainedEntities.size(); ++i)
			if(Container->TopLeft->ContainedEntities[i]->linearVelocityHistory.size())
				AverageVelocity += Container->TopLeft->ContainedEntities[i]->linearVelocityHistory.back() * (1 - 0.002 * (Container->TopLeft->ContainedEntities[i]->position - position).squaredLength());
	if( Container->TopRight != NULL)
		for (Ogre::uint i = 0; i < Container->TopRight->ContainedEntities.size(); ++i)
			if(Container->TopRight->ContainedEntities[i]->linearVelocityHistory.size())
				AverageVelocity += Container->TopRight->ContainedEntities[i]->linearVelocityHistory.back() * (1 - 0.002 * (Container->TopRight->ContainedEntities[i]->position - position).squaredLength());
		if(AttractionCenterWeightstSum != 0.0f) 
		AverageVelocity /= AttractionCenterWeightstSum;	// Fishy Component : 
	Ogre::Vector3 PhishyComponent = Ogre::Vector3::ZERO;
	if(Hydrax_man.sea_level > terrain_height(position.x, position.z,0))
		PhishyComponent.y = 1.0f * pow((Hydrax_man.sea_level + terrain_height(position.x, position.z,0) - 2 * position.y)/(Hydrax_man.sea_level - terrain_height(position.x, position.z,0)),3);
	else
		PhishyComponent.y = -1000;	if (Faune_man.debugInfoTimestamp + 500 < sys0.timer.getMilliseconds())
	{
	/*
	ldbg.send("Fish update info : \n Position  = " + toOgStr(position) 
			+ "\n PagePos = " + toOgStr(Container->MinXBorder) + "   " + toOgStr(Container->MinZBorder)
			+ "\n Playerpos = " + toOgStr(local_player.pos)
			+ "\n AverageVelocity = " + toOgStr(AverageVelocity*100)
			+ "\n (AttractionComponent / Timelapse) =  " + toOgStr((AttractionComponent / Timelapse)/10000) 
			+ "\n (RepultionComponent / Timelapse) =  " + toOgStr((RepultionComponent / Timelapse))
			+ "\n (PhishyComponent/Timelapse) =  " + toOgStr((PhishyComponent/Timelapse)*6));
		Faune_man.debugInfoTimestamp = sys0.timer.getMilliseconds();*/
	}	// Compute displacement vector
	linearVelocity = AverageVelocity*100 + (AttractionComponent / Timelapse)/10000 + (RepultionComponent/Timelapse) + (PhishyComponent/Timelapse)*30 ;
	linearVelocity.normalise();
	//linearVelocity *= 2;	// final displacement vector is the averaging of last quarter of displacement history	
	std::list<Ogre::Vector3>::iterator it = linearVelocityHistory.begin();
	Ogre::uint i = 1;
	while (i < linearVelocityHistory.size()/40)
	{
		linearVelocity += *it/((i+4)/2);
		++it;
		++i;
	}
	linearVelocity.normalise();
			Ogre::Vector3 NewPos = position + linearVelocity * Timelapse;	
	AnimalNode->lookAt(NewPos, Ogre::Node::TransformSpace::TS_WORLD, Ogre::Vector3::UNIT_Z); // Makes the animal look at where he is heading 	// Makes the animal's body vertical
	/*Ogre::Vector3 transform =  Ogre::Vector3(  AnimalNode->getOrientation().getPitch().valueAngleUnits(),
											   AnimalNode->getOrientation().getYaw().valueAngleUnits(),
											   0 );
	AnimalNode->setOrientation(Ogre::Quaternion(&transform));*/	// Apply displacement
	AnimalNode->setPosition(	NewPos.x,
								NewPos.y,
								NewPos.z);	position = AnimalNode->getPosition();	//Store new velocity in history
	linearVelocityHistory.push_front(linearVelocity);
	if(linearVelocityHistory.size() > 400) //40 * Timelapse de temps de réponse donc (de l'ordre de la seconde) TODO : implement real reponse time, and random variation of it
		linearVelocityHistory.pop_back();}void Faune_Entity::destroy(void)
{
	AnimalNode->detachAllObjects();
	sys0.mgr->destroyEntity(AnimalEntity);
	sys0.mgr->destroySceneNode(AnimalNode);
} 
Amnesic_Faune_Entity::Amnesic_Faune_Entity(void)
{	
}
Amnesic_Faune_Entity::~Amnesic_Faune_Entity(void)
{
}void Amnesic_Faune_Entity::initialise(Ogre::Vector2 RequestedPos)
{  
	AnimalEntity = sys0.mgr->createEntity("AmnseicAnimal" + StringConverter::toString(sys0.timer.getMicroseconds()),"Mamoth std.mesh");
	//AnimalEntity->setMaterial(MaterialManager::getSingleton().getByName("fur"));
	AnimalNode = sys0.mgr->getRootSceneNode()->createChildSceneNode();
	//AnimalNode->setScale(0.4,0.4,0.4);
	AnimalNode->attachObject(AnimalEntity);
	AnimalNode->setPosition(	RequestedPos.x,
								terrain_height(RequestedPos.x, RequestedPos.y,0),
								RequestedPos.y);}void Amnesic_Faune_Entity::update(float Timelapse = 1/60)
{
	position = AnimalNode->getPosition();
}void Amnesic_Faune_Entity::destroy(void)
{
	AnimalNode->detachAllObjects();
	sys0.mgr->destroyEntity(AnimalEntity);
	sys0.mgr->destroySceneNode(AnimalNode);
} 
#include "Namuh_Main_H.h"using namespace Ogre;Faune_Page::Faune_Page(void)
{	
}
Faune_Page::~Faune_Page(void)
{
}void Faune_Page::initialise(int rqMinXBorder,int rqMaxXBorder ,int rqMinZBorder ,int rqMaxZBorder)
{  
	MinXBorder = rqMinXBorder;
	MaxXBorder = rqMaxXBorder;
	MinZBorder = rqMinZBorder;
	MaxZBorder = rqMaxZBorder;	Center = Ogre::Vector3((MinXBorder+MaxXBorder)/2,0,(MinZBorder+MaxZBorder)/2);
	Center = Ogre::Vector3(Center.x,terrain_height(Center.x, Center.z,0),Center.z);
	size = MaxXBorder - MinXBorder;	/*
	// Also uses cubes to show updated pages
	FlagEntity = sys0.mgr->createEntity("Flag" + StringConverter::toString(sys0.timer.getMicroseconds()),"Cube.mesh");
	//FlagEntity->setMaterial(MaterialManager::getSingleton().getByName("blink"));
	FlagNode = sys0.mgr->getRootSceneNode()->createChildSceneNode();
	FlagNode->setScale(5*size/15,0.5,5*size/15);
	FlagNode->attachObject(FlagEntity);
	FlagNode->setPosition(	MinXBorder + size/2,
							250 + size / 2,
							MinZBorder + size/2);
	FlagNode->setVisible(false);*/
}void Faune_Page::update(float TimeLapse)
{
	if(SubPages.size() != 0) // Si la page contient des sous pages on update les sous pages
		for(int t = 0;t != SubPages.size();t++)
			SubPages[t]->update(TimeLapse);
	else
		for(Ogre::uint t = 0;t < ContainedEntities.size();t++)
		{
			ContainedEntities[t]->update(TimeLapse);
		
			// Si une entitée sors de son enclot, on doit la réattibuer a la bonne Page
			char posID =		char(bool(MaxXBorder < ContainedEntities[t]->position.x)*1) +
								char(bool(ContainedEntities[t]->position.x < MinXBorder)*2) + 
								char(bool(MaxZBorder < ContainedEntities[t]->position.z)*4) + 
								char(bool(ContainedEntities[t]->position.z < MinZBorder)*8) ;			if(posID != 0)
			{
				Faune_Page* NewPage = NULL;
				if(posID ==  1) NewPage = Right;
				if(posID ==  2) NewPage = Left;
				if(posID ==  4) NewPage = Top;
				if(posID ==  5) NewPage = TopRight;
				if(posID ==  6) NewPage = TopLeft;
				if(posID ==  8) NewPage = Bottom;
				if(posID ==  9) NewPage = BottomRight;
				if(posID == 10) NewPage = BottomLeft;
				// Si on sors de la map, on est attribué a la dernière page qui nous as hébergé
				if(NewPage != NULL) 
				{
					ContainedEntities[t]->Container = NewPage;
	
					NewPage->ContainedEntities.push_back(ContainedEntities[t]);
		
					ContainedEntities[t] = ContainedEntities.back();
					ContainedEntities.pop_back();					// applique la visibilité de la nouvelle page
					NewPage->ContainedEntities.back()->AnimalNode->setVisible(NewPage->isVisible);
				}
			
			}
		}
}void Faune_Page::destroy(void)
{
}void Faune_Page::setVisible(bool NewVisibility)
{
	if(NewVisibility != isVisible)
	{
		isVisible = NewVisibility;
		if(SubPages.size() != 0) // Si la page contient des sous pages on update les sous pages
			for(int t = 0;t != SubPages.size();t++)
				SubPages[t]->setVisible(NewVisibility);
		else // Sinon on cache les maillages de la feuille de l'arbre
		{
			for(int t = 0;t != ContainedEntities.size();t++)
				ContainedEntities[t]->AnimalNode->setVisible(NewVisibility);
			//FlagNode->setVisible(NewVisibility);
		}
	}
}Faune_mgr Faune_man;
// Code des méthodes de la classe
Faune_mgr::Faune_mgr(void)
{	
	initialised = false;
	debugInfoTimestamp = 0;
}
Faune_mgr::~Faune_mgr(void)
{
}void Faune_mgr::initialise(void)
{  
	if(!initialised)
	{
		initialised = true;		float MinimalFeuilleDimention = FloatFromName(Map.MapDataPool,"Faune_Page_Min_Size");
		DisplayDistance = FloatFromName(Map.MapDataPool,"Faune_Display_Distance");
		std::vector<Faune_Page*> FeuillesShortCut,NextFeuillesShortCut;
		Faune_Page WorldPage;
		RootPage = WorldPage;
		NextFeuillesShortCut.push_back(&RootPage);
		NextFeuillesShortCut.back()->initialise(	Vector3FromName(Map.MapDataPool,"World_Position").x - FloatFromName(Map.MapDataPool,"World_Horisontal_Size")/2,
													Vector3FromName(Map.MapDataPool,"World_Position").x + FloatFromName(Map.MapDataPool,"World_Horisontal_Size")/2,
													Vector3FromName(Map.MapDataPool,"World_Position").z - FloatFromName(Map.MapDataPool,"World_Horisontal_Size")/2,
													Vector3FromName(Map.MapDataPool,"World_Position").z + FloatFromName(Map.MapDataPool,"World_Horisontal_Size")/2);
		NextFeuillesShortCut.back()->Parent = NULL;		float FeuilleDimention = NextFeuillesShortCut.back()->size;		while(FeuilleDimention/2 > MinimalFeuilleDimention)
		{
			FeuillesShortCut = NextFeuillesShortCut;
			NextFeuillesShortCut.clear();
			for(Ogre::uint t =0; t < FeuillesShortCut.size(); t++ )
			{
				Faune_Page* ParentPage = FeuillesShortCut[t];
				// Découpe la page en 4				Faune_Page* ChildFaunePage1 = new Faune_Page();
				ParentPage->SubPages.push_back(ChildFaunePage1);
				ParentPage->SubPages.back()->Parent = ParentPage;
				ParentPage->SubPages.back()->initialise(ParentPage->MinXBorder, 
														ParentPage->MinXBorder + ParentPage->size/2, 
														ParentPage->MinZBorder, 
														ParentPage->MinZBorder + ParentPage->size/2);
				NextFeuillesShortCut.push_back(ParentPage->SubPages.back());
				Faune_Page* ChildFaunePage2 = new Faune_Page();
				ParentPage->SubPages.push_back(ChildFaunePage2);
				ParentPage->SubPages.back()->Parent = ParentPage;
				ParentPage->SubPages.back()->initialise(ParentPage->MinXBorder + ParentPage->size/2, 
														ParentPage->MaxXBorder, 
														ParentPage->MinZBorder, 
														ParentPage->MinZBorder + ParentPage->size/2);
				NextFeuillesShortCut.push_back(ParentPage->SubPages.back());
				Faune_Page* ChildFaunePage3 = new Faune_Page();
				ParentPage->SubPages.push_back(ChildFaunePage3);
				ParentPage->SubPages.back()->Parent = ParentPage;
				ParentPage->SubPages.back()->initialise(ParentPage->MinXBorder, 
														ParentPage->MinXBorder + ParentPage->size/2, 
														ParentPage->MinZBorder+ ParentPage->size/2, 
														ParentPage->MaxZBorder);
				NextFeuillesShortCut.push_back(ParentPage->SubPages.back());
				Faune_Page* ChildFaunePage4 = new Faune_Page();
				ParentPage->SubPages.push_back(ChildFaunePage4);
				ParentPage->SubPages.back()->Parent = ParentPage;
				ParentPage->SubPages.back()->initialise(ParentPage->MinXBorder + ParentPage->size/2, 
														ParentPage->MaxXBorder, 
														ParentPage->MinZBorder + ParentPage->size/2, 
														ParentPage->MaxZBorder);
				NextFeuillesShortCut.push_back(ParentPage->SubPages.back());
			}
			FeuilleDimention = FeuillesShortCut[0]->SubPages.back()->size;
		}
		FeuillesShortCut = NextFeuillesShortCut;
		this->ChainageOctupleFirstPass(&RootPage);
		this->ChainageOctupleSecondPass(&RootPage);		Faune_Entity* NewAnimal;
		Ogre::Vector3 AnimalPos;
		//on peuple les pages		// Essai : on place les poissons uniquement sous l'eau
		int atemptsCount = 10; // 10 essais pour lacer correctement l'animal, sinon, on le zappe
		int totalNanimoCount = 0;
		for(Ogre::uint t =0; t < FeuillesShortCut.size(); t++ )
		{
			Faune_Page* CurrentPage = FeuillesShortCut[t];
			std::vector<Faune_Entity*>* WorkELst = &FeuillesShortCut[t]->ContainedEntities;			Ogre::uint nanimoCount = int(20*pow(Math::RangeRandom(0,5)/4,8)); //  jusqu'a 120 animaux par pages, mais moyenne a 11 anomaux
			for(Ogre::uint i = 0; i < nanimoCount; i++) // 1 nanimo par page
			{				atemptsCount = 10;
				AnimalPos = Ogre::Vector3(	Math::RangeRandom(CurrentPage->MinXBorder,CurrentPage->MaxXBorder),
											0,
											Math::RangeRandom(CurrentPage->MinZBorder,CurrentPage->MaxZBorder));
				while (atemptsCount > 0 && terrain_height(AnimalPos.x, AnimalPos.z,0) + 1 > Hydrax_man.sea_level)  // essaye de re-placer l'animal si l'emplacement ne va pas
				{
					
					AnimalPos = Ogre::Vector3(	Math::RangeRandom(CurrentPage->MinXBorder,CurrentPage->MaxXBorder),
												0,
												Math::RangeRandom(CurrentPage->MinZBorder,CurrentPage->MaxZBorder));
					atemptsCount--;
				}				if (terrain_height(AnimalPos.x, AnimalPos.z,0) + 1 < Hydrax_man.sea_level)  // ne pose un nanimo que si la place est correcte
				{
					totalNanimoCount++;
					NewAnimal = new Faune_Entity;
					WorkELst->push_back(NewAnimal);
					AnimalPos.y = terrain_height(AnimalPos.x, AnimalPos.z,0);
					WorkELst->back()->initialise(CurrentPage,AnimalPos);
				}
			}
			FeuillesShortCut[t]->setVisible(false);
		}
		GuessedPlayerPage = this->LocatePlayer(Vector3FromName(Map.MapDataPool,"Spawn_Position"));
		ldbg.send("Just popped " + toOgStr(totalNanimoCount) + " cutes animals !");
		/*
		//Uses cubes to visually delimit bottom layer pages
		Ogre::Entity* BaliseEntity = NULL;
		Ogre::SceneNode* BaliseNode = NULL;
		for(Ogre::uint t =0; t < FeuillesShortCut.size(); t++ )
		{
			BaliseEntity = sys0.mgr->createEntity("Balise" + StringConverter::toString(sys0.timer.getMicroseconds()),"Cube.mesh");
			BaliseEntity->setMaterial(MaterialManager::getSingleton().getByName("fur"));
			BaliseNode = sys0.mgr->getRootSceneNode()->createChildSceneNode();
			BaliseNode->setScale(0.5,1000,0.5);
			BaliseNode->attachObject(BaliseEntity);
			BaliseNode->setPosition(	FeuillesShortCut[t]->MinXBorder,
										terrain_height(FeuillesShortCut[t]->MinXBorder,FeuillesShortCut[t]->MinZBorder,0),
										FeuillesShortCut[t]->MinZBorder);
		}
		*/	}
}
void Faune_mgr::ChainageOctupleFirstPass(Faune_Page* CurrentPage) // Ne lie que quadruplement par top, bot, left et right
{
	Faune_Page		*SearchCursor = NULL,
					*SearchResult = NULL;
	std::vector<int> CurrentPagePath;
	int index = 0;
	bool founded = false;
	// Recherche de la Page Bottom
	SearchCursor = CurrentPage;
	CurrentPagePath.clear();
	founded = false;
	index = 0;
	while(SearchCursor->Parent != NULL && !founded)
	{
		index = getIndexInParentSubPages(SearchCursor);
		CurrentPagePath.push_back(index);
		if(index == 0 || index == 1) founded = true;
		else SearchCursor = SearchCursor->Parent;
	}
	if(founded)
	{
			if(CurrentPagePath.back() == 0) SearchResult = SearchCursor->Parent->SubPages[2];
			if(CurrentPagePath.back() == 1) SearchResult = SearchCursor->Parent->SubPages[3];			for(int t = CurrentPagePath.size()-2;t >= 0;t--)
			{
				if(CurrentPagePath[t] == 2) SearchResult = SearchResult->SubPages[0];
				if(CurrentPagePath[t] == 3) SearchResult = SearchResult->SubPages[1];
			}
	}
	else
	{
		SearchResult = NULL;
		SearchCursor = NULL;
	}
	CurrentPage->Bottom = SearchResult;
	//if(founded)
	//ldbg.send("Page centered in " + Ogre::StringConverter::toString(CurrentPage->Center) + " with a size of "  + Ogre::StringConverter::toString(CurrentPage->size) + " have bottom link with the page centered in " + Ogre::StringConverter::toString(CurrentPage->Bottom->Center) + "with a size of "  + Ogre::StringConverter::toString(CurrentPage->Bottom->size));	
	// Recherche de la Page Left
	SearchCursor = CurrentPage;
	CurrentPagePath.clear();
	founded = false;
	index = 0;
	while(SearchCursor->Parent != NULL && !founded)
	{
		index = getIndexInParentSubPages(SearchCursor);
		CurrentPagePath.push_back(index);
		if(index == 1 || index == 3) founded = true;
		else SearchCursor = SearchCursor->Parent;
	}
	if(founded)
	{
		if(CurrentPagePath.back() == 1) SearchResult = SearchCursor->Parent->SubPages[0];
		if(CurrentPagePath.back() == 3) SearchResult = SearchCursor->Parent->SubPages[2];		for(int t = CurrentPagePath.size()-2;t >= 0;t--)
		{
			if(CurrentPagePath[t] == 0) SearchResult = SearchResult->SubPages[1];
			if(CurrentPagePath[t] == 2) SearchResult = SearchResult->SubPages[3];
		}
	}
	else
	{
		SearchResult = NULL;
		SearchCursor = NULL;
	}
	CurrentPage->Left = SearchResult;
	
	//if(founded)
	//ldbg.send("Page centered in " + Ogre::StringConverter::toString(CurrentPage->Center) + " with a size of "  + Ogre::StringConverter::toString(CurrentPage->size) + " have Left link with the page centered in " + Ogre::StringConverter::toString(CurrentPage->Left->Center) + " with a size of "  + Ogre::StringConverter::toString(CurrentPage->Left->size));
	// Recherche de la Page Right
	SearchCursor = CurrentPage;
	CurrentPagePath.clear();
	founded = false;
	index = 0;
	while(SearchCursor->Parent != NULL && !founded)
	{
		index = getIndexInParentSubPages(SearchCursor);
		CurrentPagePath.push_back(index);
		if(index == 0 || index == 2) founded = true;
		else SearchCursor = SearchCursor->Parent;
	}
	if(founded)
	{
		if(CurrentPagePath.back() == 0) SearchResult = SearchCursor->Parent->SubPages[1];
		if(CurrentPagePath.back() == 2) SearchResult = SearchCursor->Parent->SubPages[3];		for(int t = CurrentPagePath.size()-2;t >= 0;t--)
		{
			if(CurrentPagePath[t] == 1) SearchResult = SearchResult->SubPages[0];
			if(CurrentPagePath[t] == 3) SearchResult = SearchResult->SubPages[2];
		}
	}
	else
	{
		SearchResult = NULL;
		SearchCursor = NULL;
	}
	CurrentPage->Right = SearchResult;
	
	//if(founded)
	//ldbg.send("Page centered in " + Ogre::StringConverter::toString(CurrentPage->Center) + " with a size of "  + Ogre::StringConverter::toString(CurrentPage->size) + " have right link with the page centered in " + Ogre::StringConverter::toString(CurrentPage->Right->Center) + " with a size of "  + Ogre::StringConverter::toString(CurrentPage->Right->size));	// Recherche de la Page Top
	SearchCursor = CurrentPage;
	CurrentPagePath.clear();
	founded = false;
	index = 0;
	while(SearchCursor->Parent != NULL && !founded)
	{
		index = getIndexInParentSubPages(SearchCursor);
		CurrentPagePath.push_back(index);
		if(index == 2 || index == 3) founded = true;
		else SearchCursor = SearchCursor->Parent;
	}
	if(founded)
	{
		if(CurrentPagePath.back() == 2) SearchResult = SearchCursor->Parent->SubPages[0];
		if(CurrentPagePath.back() == 3) SearchResult = SearchCursor->Parent->SubPages[1];		for(int t = CurrentPagePath.size()-2;t >= 0;t--)
		{
			if(CurrentPagePath[t] == 0) SearchResult = SearchResult->SubPages[2];
			if(CurrentPagePath[t] == 1) SearchResult = SearchResult->SubPages[3];
		}
	}
	else
	{
		SearchResult = NULL;
		SearchCursor = NULL;
	}
	CurrentPage->Top = SearchResult;
	
	//if(founded)
	//ldbg.send("Page centered in " + Ogre::StringConverter::toString(CurrentPage->Center) + " with a size of "  + Ogre::StringConverter::toString(CurrentPage->size) + " have top link with the page centered in " + Ogre::StringConverter::toString(CurrentPage->Top->Center) + " with a size of "  + Ogre::StringConverter::toString(CurrentPage->Top->size));
	
	if(CurrentPage->SubPages.size() != 0)
	{
		ChainageOctupleFirstPass(CurrentPage->SubPages[0]);
		ChainageOctupleFirstPass(CurrentPage->SubPages[1]);
		ChainageOctupleFirstPass(CurrentPage->SubPages[2]);
		ChainageOctupleFirstPass(CurrentPage->SubPages[3]);	}
}void Faune_mgr::ChainageOctupleSecondPass(Faune_Page* CurrentPage) // Lie les 4 fois manquantes
{
	if(CurrentPage->Left != NULL)	CurrentPage->BottomLeft = CurrentPage->Left->Bottom;
	else							CurrentPage->BottomLeft = NULL;
	if(CurrentPage->Left != NULL)	CurrentPage->TopLeft = CurrentPage->Left->Top;
	else							CurrentPage->TopLeft = NULL;
	if(CurrentPage->Right != NULL)	CurrentPage->BottomRight = CurrentPage->Right->Bottom;
	else							CurrentPage->BottomRight = NULL;
	if(CurrentPage->Right != NULL)	CurrentPage->TopRight = CurrentPage->Right->Top;
	else							CurrentPage->TopRight = NULL;	if(CurrentPage->SubPages.size() != 0) //Tant que la page a des Subpages, on les lies récusivement
	{
		ChainageOctupleSecondPass(CurrentPage->SubPages[0]);
		ChainageOctupleSecondPass(CurrentPage->SubPages[1]);
		ChainageOctupleSecondPass(CurrentPage->SubPages[2]);
		ChainageOctupleSecondPass(CurrentPage->SubPages[3]);
	}
}int Faune_mgr::getIndexInParentSubPages(Faune_Page* CurrentPage)
{
	if(CurrentPage->Parent != NULL)
	{
		if(CurrentPage == CurrentPage->Parent->SubPages[0]) return 0;
		if(CurrentPage == CurrentPage->Parent->SubPages[1]) return 1;
		if(CurrentPage == CurrentPage->Parent->SubPages[2]) return 2;
		if(CurrentPage == CurrentPage->Parent->SubPages[3]) return 3;
	}
	else
	{
		// On peut metttre un message de debug, ici typiquement la RootPage arrivera
		return -1;
	}
	return -1;
}Faune_Page* Faune_mgr::LocatePlayer(Ogre::Vector3 playerpos)
{
	Faune_Page* SearchScope = &RootPage;
	Ogre::uint t = 0;
	while(t < SearchScope->SubPages.size())
	{
		if(	SearchScope->SubPages[t]->MinXBorder <= playerpos.x && 
			SearchScope->SubPages[t]->MaxXBorder >= playerpos.x && 
			SearchScope->SubPages[t]->MinZBorder <= playerpos.z && 
			SearchScope->SubPages[t]->MaxZBorder >= playerpos.z )
		{
			if(SearchScope->SubPages[t]->SubPages.size() == 0)
				return SearchScope->SubPages[t];
			else
			{
				SearchScope = SearchScope->SubPages[t];
				t = -1; // reset le "for" avec un nouveau champ de recherche
			}
		}
		t++;
	}
	ldbg.send("Faune_mgr : Falied to locate player : No player founded in Paged World");}void Faune_mgr::destroy(void)
{
}
void Faune_mgr::update(float ellapsed_time, Ogre::Vector3 playerpos)
{
	Faune_Page* LastAdded;
	if(GuessedPlayerPage == NULL)
	{
		GuessedPlayerPage = this->LocatePlayer(playerpos);
		UpdateList.clear();
		UpdateList.push_back(GuessedPlayerPage);
	}	if(GuessedPlayerPage->SubPages.size() != 0) // Si on guess pas une feuille, on essaye de locate dans cette page
	{
		GuessedPlayerPage = this->LocatePlayer(playerpos);
		UpdateList.clear();
		UpdateList.push_back(GuessedPlayerPage);
	}
	// Si le joueur est pas la ou on l'attend, on fait une synthèse de la ou il peut être
	posID =		char(GuessedPlayerPage->MaxXBorder < playerpos.x)*1 +
				char(playerpos.x < GuessedPlayerPage->MinXBorder)*2 + 
				char(GuessedPlayerPage->MaxZBorder < playerpos.z)*4 + 
				char(playerpos.z < GuessedPlayerPage->MinZBorder)*8 ;	if(posID != 0)
	{
		if(posID ==  1)GuessedPlayerPage = GuessedPlayerPage->Right;
		if(posID ==  2)GuessedPlayerPage = GuessedPlayerPage->Left;
		if(posID ==  4)GuessedPlayerPage = GuessedPlayerPage->Top;
		if(posID ==  5)GuessedPlayerPage = GuessedPlayerPage->TopRight;
		if(posID ==  6)GuessedPlayerPage = GuessedPlayerPage->TopLeft;
		if(posID ==  8)GuessedPlayerPage = GuessedPlayerPage->Bottom;
		if(posID ==  9)GuessedPlayerPage = GuessedPlayerPage->BottomRight;
		if(posID == 10)GuessedPlayerPage = GuessedPlayerPage->BottomLeft;
		if(GuessedPlayerPage != NULL)
		{
			posID =		char(GuessedPlayerPage->MaxXBorder < playerpos.x)*1 +
						char(playerpos.x < GuessedPlayerPage->MinXBorder)*2 + 
						char(GuessedPlayerPage->MaxZBorder < playerpos.z)*4 + 
						char(playerpos.z < GuessedPlayerPage->MinZBorder)*8 ;
		}
		else
			posID = -1; // -1 est une valeur non nulle, pour faire faire le LoactePlayer
		if(posID != 0) GuessedPlayerPage = this->LocatePlayer(playerpos);		// Destruction de l'ancienne updatelist
		for(Ogre::uint t = 0; t < UpdateList.size(); t++) // Top bullshit
			UpdateList[t]->setVisible(false);
		UpdateList.clear();
		UpdateList.push_back(GuessedPlayerPage);
		
		// Generation de la nouvelle updatelist
		// Va tout a droite
		LastAdded = GuessedPlayerPage;
		while(LastAdded->Right != NULL && abs(LastAdded->Right->Center.x-playerpos.x) < DisplayDistance)
		{
			UpdateList.push_back(LastAdded->Right);
			LastAdded = UpdateList.back();
		}
		// Tout a gauche
		LastAdded = GuessedPlayerPage;
		while(LastAdded->Left != NULL && abs(LastAdded->Left->Center.x-playerpos.x) < DisplayDistance)
		{
			UpdateList.push_back(LastAdded->Left);
			LastAdded = UpdateList.back();
		}
		
		// Extrude verticalement
		int initialSize = UpdateList.size(); // Hum, allocation mémoire real time ?
		for(int t = 0; t < initialSize; t++)
		{
			LastAdded = UpdateList[t];
			while(LastAdded->Top != NULL && FakeDistance2D(LastAdded->Top->Center.x,LastAdded->Top->Center.z,GuessedPlayerPage->Center.x,GuessedPlayerPage->Center.z) < DisplayDistance)
			{
				UpdateList.push_back(LastAdded->Top);
				LastAdded = UpdateList.back();
			}
			LastAdded = UpdateList[t];
			while(LastAdded->Bottom != NULL && FakeDistance2D(LastAdded->Bottom->Center.x,LastAdded->Bottom->Center.z,GuessedPlayerPage->Center.x,GuessedPlayerPage->Center.z) < DisplayDistance)
			{
				UpdateList.push_back(LastAdded->Bottom);
				LastAdded = UpdateList.back();
			}
		}		for(Ogre::uint t = 0; t < UpdateList.size(); t++) // The return Of Top bullshit
			UpdateList[t]->setVisible(true);
	}
	if(!GuessedPlayerPage->isVisible)
		for(Ogre::uint t = 0; t < UpdateList.size(); t++) 
			UpdateList[t]->setVisible(true);	// Update tout ce joli monde :
	for(Ogre::uint t = 0; t < UpdateList.size(); t++)
		UpdateList[t]->update(ellapsed_time);
}
#include "Namuh_Main_H.h"using namespace Ogre;FileSerialiser File_Serialiser;// Code des méthodes de la classe
FileSerialiser::FileSerialiser(void)
{
}
FileSerialiser::~FileSerialiser(void)
{
}void FileSerialiser::WriteFile(std::vector<NamedDataPool*> Data, string FileName)
{
	ofstream file (&FileName[0], ios::out | ios::trunc);
	if(!file)
		ldbg.send("(File Serialiser Exeption) Unable to open "+ FileName +", abording...");
	else
	{
		for(	std::vector<NamedDataPool*>::iterator DataIterator = Data.begin();
				DataIterator != Data.end();
				++DataIterator)
			file << SerialisePool(*DataIterator) << endl;
		file.close();
		ldbg.send("(File Serialiser info) File "+FileName+" sucessfully written ");
	}}inline std::string FileSerialiser::SerialisePool(NamedDataPool* Pool, string lineprefix)
{
	string	out = "",
			PreviousLevelineprefix  = lineprefix;
	lineprefix += "	";	out += PreviousLevelineprefix + getOpenBaliseStr(Pool->Name);	for(	std::vector<NamedBool>::iterator DataIterator = Pool->Bool_Data.begin();
			DataIterator != Pool->Bool_Data.end();
			++DataIterator)
		out += lineprefix + getAffectStr((*DataIterator).Name) + StringConverter::toString((*DataIterator).data) + "\n";	for(	std::vector<NamedInt>::iterator DataIterator = Pool->Int_Data.begin();
			DataIterator != Pool->Int_Data.end();
			++DataIterator)
		out += lineprefix + getAffectStr((*DataIterator).Name) + StringConverter::toString((*DataIterator).data) + "\n";	for(	std::vector<NamedFloat>::iterator DataIterator = Pool->Float_Data.begin();
			DataIterator != Pool->Float_Data.end();
			++DataIterator)
		out += lineprefix + getAffectStr((*DataIterator).Name) + StringConverter::toString((*DataIterator).data) + "\n";	for(	std::vector<NamedVector3>::iterator DataIterator = Pool->Vector3_Data.begin();
			DataIterator != Pool->Vector3_Data.end();
			++DataIterator)
		out += lineprefix + getAffectStr((*DataIterator).Name) + StringConverter::toString((*DataIterator).data) + "\n";	for(	std::vector<NamedString>::iterator DataIterator = Pool->String_Data.begin();
			DataIterator != Pool->String_Data.end();
			++DataIterator)
		out += lineprefix + getAffectStr((*DataIterator).Name) + (*DataIterator).data + "\n";	for(	std::vector<NamedDataPool>::iterator SubPoolIterator = Pool->SubPool.begin();
			SubPoolIterator != Pool->SubPool.end();
			++SubPoolIterator)
		out += SerialisePool(&(*SubPoolIterator), lineprefix);	out += PreviousLevelineprefix + getCloseBaliseStr(Pool->Name);	return out;
}inline std::string FileSerialiser::getOpenBaliseStr(string BaliseName)
{
	return "["+BaliseName+"]\n";
}inline std::string FileSerialiser::getCloseBaliseStr(string BaliseName)
{
	return "[/"+BaliseName+"]\n";
}inline std::string FileSerialiser::getAffectStr(string DataName)
{
	return DataName+" = ";
}
 #include "Namuh_Main_H.h"using namespace Ogre;
// Code des méthodes de la classe
LdbgGraph::LdbgGraph(void)
{
	// Default params
	BackgroundColor = Ogre::ColourValue::Black*0.75;
	sizeX = 0.20f;
	sizeY = 0.1236f;
	posX = 0.28f;
	posY = 0.025f;
	automatic_update = true;
	draw_cursors = true;
	// Create the graph's texture and store a pointer of it
	Texture = TextureManager::getSingleton().createManual(
		"Graph"+ StringConverter::toString(sys0.timer.getMicroseconds()), // name
		ResourceGroupManager::DEFAULT_RESOURCE_GROUP_NAME,
		TEX_TYPE_2D,      // type
		floor(sizeX*sys0.vp->getActualWidth()), floor(sizeY*sys0.vp->getActualHeight()),     // width & height
		0,                // number of mipmaps
		PF_BYTE_RGBA,     // pixel format
		TU_DYNAMIC_WRITE_ONLY_DISCARDABLE);
	PixelBuffer = Texture->getBuffer();
	 
	// Create a material using the texture
	MaterialPtr material = MaterialManager::getSingleton().create(Texture->getName(),ResourceGroupManager::DEFAULT_RESOURCE_GROUP_NAME);
	material->getTechnique(0)->getPass(0)->createTextureUnitState(Texture->getName());
	material->getTechnique(0)->getPass(0)->setSceneBlending(SBT_TRANSPARENT_ALPHA);	// Create a panel
	panel = static_cast<Ogre::OverlayContainer*>(OverlayManager::getSingleton().createOverlayElement("Panel",Texture->getName()));
	panel->setMetricsMode(Ogre::GMM_RELATIVE);
	panel->setPosition(posX,posY);
	panel->setDimensions(sizeX,sizeY);
	panel->setMaterialName(material->getName());
	ldbg.overlay->add2D(panel);
}
LdbgGraph::~LdbgGraph(void)
{
}void LdbgGraph::ConnectFlowToXAxis(string AxisName, string FlowName)
{
	XFlowConnexions[AxisName] = FlowName;
}void LdbgGraph::ConnectFlowToYAxis(string AxisName, string FlowName)
{
	YFlowConnexions[AxisName] = FlowName;
}void LdbgGraph::ConnectTimeToXAxis(string AxisName)
{
	XTimeConnexions.insert(AxisName);
}void LdbgGraph::ConnectTimeToYAxis(string AxisName)
{
	YTimeConnextions.insert(AxisName);
}void LdbgGraph::ConnectValueCountToXAxis(string AxisName, string FlowName)
{
	XValueCountConnexions[AxisName] = FlowName;
}void LdbgGraph::ConnectValueCountToYAxis(string AxisName, string FlowName)
{
	YValueCountConnexions[AxisName] = FlowName;
}void LdbgGraph::AddValue(string AxisName, float value)
{
	if(XDatas.count(AxisName))XDatas[AxisName].Datas.push_back(value);
	if(YDatas.count(AxisName))YDatas[AxisName].Datas.push_back(value);
}
void LdbgGraph::Draw()
{	// Repositionne le grpahe, des fois qu'il aurai bougé
	panel->setPosition(posX,posY);	// Enlève tout les child du panel (Pour pouvoir en avoir un nombre dynamique) TODO : Find a solution do dignostic if a child is already attached to the panel
	{
		Ogre::OverlayContainer::ChildIterator it = panel->getChildIterator();
		while(it.hasMoreElements())
		  panel->removeChild(dynamic_cast<Ogre::TextAreaOverlayElement*>(it.getNext())->getName());
	}	PixelBuffer->lock(HardwareBuffer::HBL_DISCARD);
	const PixelBox& PixelBox = PixelBuffer->getCurrentLock();	Ogre::uint32 *data = static_cast<Ogre::uint32*>(PixelBox.data);
	size_t height = PixelBox.getHeight();
	size_t width = PixelBox.getWidth();
	size_t pitch = PixelBox.rowPitch; // Skip between rows of image	// Remplit le graphe avec l'arrière plan
	for(size_t y=0; y<height; ++y)
		for(size_t x=0; x<width; ++x)
		{
			data[pitch*y + x] =  static_cast<Ogre::uint32>(BackgroundColor.getAsARGB());
		}
		
	// Chaque Yaxis trace une coube par Xaxis
	for (	std::map<string, LdbgGraphAxis >::iterator XAxisIterator = XDatas.begin();
			XAxisIterator != XDatas.end();
			XAxisIterator++)
	{
		// Trace la grille X
		Ogre::uint Xgridpixelstep = 0.9*width*XAxisIterator->second.GridInterval/(XAxisIterator->second.max-XAxisIterator->second.min);
		if(Xgridpixelstep != 0)
			for(Ogre::uint  x=0.1*width; x<width; x += Xgridpixelstep)
				for(Ogre::uint  y=0; y<height*0.9; ++y)
					data[pitch*y + x] =  static_cast<Ogre::uint32>(XAxisIterator->second.GridColour.getAsARGB());		// Trace l'axe X
		for(size_t x=(0.1*width+1); x<width; ++x)
			data[pitch*size_t(height*0.9) + x] =  static_cast<Ogre::uint32>(XAxisIterator->second.DataColour.getAsARGB());		for (	std::map<string, LdbgGraphAxis >::iterator YAxisIterator = YDatas.begin();
				YAxisIterator != YDatas.end();
				YAxisIterator++)
		{
			
			// Trace la grille Y
			Ogre::uint Ygridpixelstep = 0.9*height*YAxisIterator->second.GridInterval/(YAxisIterator->second.max-YAxisIterator->second.min);
			if(Ygridpixelstep != 0)
				for(Ogre::uint y=0; y<(height*0.9-1); y += Ygridpixelstep)
					for(Ogre::uint  x=0.1*width; x<width; ++x)
						data[pitch*y + x] =  static_cast<Ogre::uint32>(XAxisIterator->second.GridColour.getAsARGB());			// Trace l'axe Y
			for(size_t y=0; y<height*0.9; ++y)
				data[pitch*y + size_t(width*0.1)] =  static_cast<Ogre::uint32>(YAxisIterator->second.DataColour.getAsARGB());			// Trace le graphe pour cette paire d'axe
			for (	std::vector<float>::iterator YValueIterator = YAxisIterator->second.Datas.begin(), XValueIterator = XAxisIterator->second.Datas.begin();
					YValueIterator != YAxisIterator->second.Datas.end() || XValueIterator != XAxisIterator->second.Datas.end();
					YValueIterator++, XValueIterator++)
			{
				if( XAxisIterator->second.max > *XValueIterator && *XValueIterator > XAxisIterator->second.min &&
					YAxisIterator->second.max > *YValueIterator && *YValueIterator > YAxisIterator->second.min )
				{
					Ogre::uint	x = 0.1*width+0.9*width*(*XValueIterator-XAxisIterator->second.min)/(XAxisIterator->second.max-XAxisIterator->second.min),
								y = 0.9*height*(1-(*YValueIterator-YAxisIterator->second.min)/(YAxisIterator->second.max-YAxisIterator->second.min));
					
					data[pitch*y + x] = static_cast<Ogre::uint32>(YAxisIterator->second.DataColour.getAsARGB());
				}
			}
		}
	}	//  Trace les RulesMarks
	for (	std::map<string, LdbgGraphAxis >::iterator XAxisIterator = XDatas.begin();
			XAxisIterator != XDatas.end();
			XAxisIterator++)
		for (	float Rulervalue = XAxisIterator->second.min;Rulervalue < XAxisIterator->second.max;Rulervalue += XAxisIterator->second.RulerInterval)
		{
			Ogre::uint	x = 0.1*width+0.9*width*(Rulervalue-XAxisIterator->second.min)/(XAxisIterator->second.max-XAxisIterator->second.min);
			for (	size_t y=(0.9*height-XAxisIterator->second.Rulersize/2);
					y<(height*0.9+XAxisIterator->second.Rulersize/2); 
					++y)
				data[pitch*y + x] =  static_cast<Ogre::uint32>(XAxisIterator->second.RulerColour.getAsARGB());
		}
		
	for (	std::map<string, LdbgGraphAxis >::iterator YAxisIterator = YDatas.begin();
			YAxisIterator != YDatas.end();
			YAxisIterator++)
		for (	float Rulervalue = YAxisIterator->second.min;Rulervalue < YAxisIterator->second.max;Rulervalue += YAxisIterator->second.RulerInterval)
		{
			Ogre::uint	y = 0.9*height*(1-(Rulervalue-YAxisIterator->second.min)/(YAxisIterator->second.max-YAxisIterator->second.min));
			for (	size_t x=(0.1*width-YAxisIterator->second.Rulersize/2);
					x<(width*0.1+YAxisIterator->second.Rulersize/2);
					++x)
				data[pitch*y + x] =  static_cast<Ogre::uint32>(YAxisIterator->second.RulerColour.getAsARGB());
		}		// Si activé, trace les curseurs
		if(draw_cursors)
		{
			for (	std::map<string, LdbgGraphAxis >::iterator XAxisIterator = XDatas.begin();
					XAxisIterator != XDatas.end();
					XAxisIterator++)
			{
				for (	std::map<string, LdbgGraphAxis >::iterator YAxisIterator = YDatas.begin();
						YAxisIterator != YDatas.end();
						YAxisIterator++)
				{
					// Trace le curseur pour cet axe
					Ogre::uint	y = 0.9*height*(1-(YAxisIterator->second.Datas.back()-YAxisIterator->second.min)/(YAxisIterator->second.max-YAxisIterator->second.min));
					for (size_t x=0.1*width; x<width; ++x)
						data[pitch*y + x] =  static_cast<Ogre::uint32>(YAxisIterator->second.RulerColour.getAsARGB());					// Affiche la valeur
					if(y>12)y-=12;
					YAxisIterator->second.CursorValue->setPosition(0.1*width,y);
					panel->addChild(YAxisIterator->second.CursorValue);				}				// Trace le curseur pour cet axe
				Ogre::uint	x = 0.1*width+0.9*width*(XAxisIterator->second.Datas.back()-XAxisIterator->second.min)/(XAxisIterator->second.max-XAxisIterator->second.min);
				for (size_t y=0; y<height*0.9; ++y)
					data[pitch*y + x] =  static_cast<Ogre::uint32>(XAxisIterator->second.RulerColour.getAsARGB());				// Affiche la valeur
				if(x+16 > width)x-=20;
				XAxisIterator->second.CursorValue->setPosition(x,height*0.9-12);
				panel->addChild(XAxisIterator->second.CursorValue);
			}
		}				PixelBuffer->unlock();	
	// Met a jour les rulers	
	for (	std::map<string, LdbgGraphAxis >::iterator XAxisIterator = XDatas.begin();// Remet les nouveaux sur X
			XAxisIterator != XDatas.end();
			XAxisIterator++)
			for (Ogre::uint i=0;i<XAxisIterator->second.RulerValue.size();i++)
		{
			XAxisIterator->second.RulerValue[i].second->setPosition(0.1*width+0.9*width*(XAxisIterator->second.RulerValue[i].first-XAxisIterator->second.min)/(XAxisIterator->second.max-XAxisIterator->second.min),0.92*height);
			panel->addChild(XAxisIterator->second.RulerValue[i].second);
		}
	
	for (	std::map<string, LdbgGraphAxis >::iterator YAxisIterator = YDatas.begin();// Remet les nouveaux sur Y
			YAxisIterator != YDatas.end();
			YAxisIterator++)
		for (Ogre::uint i=0;i<YAxisIterator->second.RulerValue.size();i++)
		{
			YAxisIterator->second.RulerValue[i].second->setPosition(0.01*width,0.9*height*(1-(YAxisIterator->second.RulerValue[i].first-YAxisIterator->second.min)/(YAxisIterator->second.max-YAxisIterator->second.min)));
			panel->addChild(YAxisIterator->second.RulerValue[i].second);
		}}void LdbgGraph::FeedAxes()
{
	// Met dans les Datas des Axis les valeurs courantes des Flow
	for (	std::map<string, string >::iterator ConnexionsIterator = XFlowConnexions.begin();
			ConnexionsIterator != XFlowConnexions.end();
			ConnexionsIterator++)
		XDatas[ConnexionsIterator->first].Datas.push_back(*ldbg.Flows[ConnexionsIterator->second]);
	for (	std::map<string, string >::iterator ConnexionsIterator = YFlowConnexions.begin();
			ConnexionsIterator != YFlowConnexions.end();
			ConnexionsIterator++)
		YDatas[ConnexionsIterator->first].Datas.push_back(*ldbg.Flows[ConnexionsIterator->second]);	// Met dans les Datas des Axis la date
	for (	std::set<string>::iterator ConnexionsIterator = XTimeConnexions.begin();
			ConnexionsIterator != XTimeConnexions.end();
			ConnexionsIterator++)
		XDatas[*ConnexionsIterator].Datas.push_back(float(sys0.timer.getMilliseconds())/1000.0f);
	for (	std::set<string>::iterator ConnexionsIterator = YTimeConnextions.begin();
			ConnexionsIterator != YTimeConnextions.end();
			ConnexionsIterator++)
		YDatas[*ConnexionsIterator].Datas.push_back(float(sys0.timer.getMilliseconds())/1000.0f);
	
	// Met dans les Datas des Axis la nombre de valeurs mémorisé par l'axis connecté
	for (	std::map<string, string >::iterator ConnexionsIterator = XValueCountConnexions.begin();
			ConnexionsIterator != XValueCountConnexions.end();
			ConnexionsIterator++)
		XDatas[ConnexionsIterator->first].Datas.push_back(XDatas[ConnexionsIterator->second].Datas.size());
	for (	std::map<string, string >::iterator ConnexionsIterator = YValueCountConnexions.begin();
			ConnexionsIterator != YValueCountConnexions.end();
			ConnexionsIterator++)
		YDatas[ConnexionsIterator->first].Datas.push_back(YDatas[ConnexionsIterator->second].Datas.size());
}void LdbgGraph::Update()
{
	this->FeedAxes();	for (	std::map<string, LdbgGraphAxis > ::iterator AxisIterator = XDatas.begin();
			AxisIterator != XDatas.end();
			AxisIterator++)
		AxisIterator->second.update();
	for (	std::map<string, LdbgGraphAxis > ::iterator AxisIterator = YDatas.begin();
			AxisIterator != YDatas.end();
			AxisIterator++)
		AxisIterator->second.update();
	this->Draw();
}#include "Namuh_Main_H.h"using namespace Ogre;
// Code des méthodes de la classe
LdbgGraphAxis::LdbgGraphAxis(void)
{
	origin = 0;
	max = 0;
	min = 0;
	RulerInterval = 1.5;
	GridInterval = 5;
	AutoFollowRange = 50; // Unused till Autofollow activated
	MaxRuler = 5;
	Rulersize = 4;	AutoCenterLastValue = false;
	AutoFollowLastValue = false;
	AutoKeepAllInRange = true;
	AutoKeepOrigin = false;	DataColour = Ogre::ColourValue(	Ogre::Math::RangeRandom(0.5,1.0),
									Ogre::Math::RangeRandom(0.5,1.0),
									Ogre::Math::RangeRandom(0.5,1.0),
									1.0);
	DataColour.saturate();
	GridColour = Ogre::ColourValue(0.3f,0.3f,0.3f,1.0f);
	RulerColour = Ogre::ColourValue::White;
	TextColour = Ogre::ColourValue::White;	CursorValue = static_cast<Ogre::TextAreaOverlayElement*>(OverlayManager::getSingleton().createOverlayElement("TextArea", "CursorValue"+ StringConverter::toString(sys0.timer.getMicroseconds())));
	CursorValue->setMetricsMode(Ogre::GMM_PIXELS);
	CursorValue->setDimensions(16, 100);
	CursorValue->setCharHeight(12);
	CursorValue->setFontName("DejaVuSans");
	CursorValue->setColourBottom(TextColour);
	CursorValue->setColourTop(TextColour);}
LdbgGraphAxis::~LdbgGraphAxis(void)
{
}void LdbgGraphAxis::setRange_FollowLastValue(bool flag, float range)
{
	AutoFollowLastValue = flag;
	if(flag)
	{
		if(range > 0.0f) AutoFollowRange = range;
		else 
		{
			ldbg.send("(Internal LDBG_GraphAxis Exeption) setRange_FollowLastValue : This range (" + StringConverter::toString(range) + ") isn't greater than 0. Command ingored.");
			AutoFollowRange = -1;
			AutoFollowLastValue = false;
		}
	}
	else
		AutoFollowRange = -1;}void LdbgGraphAxis::setRange_CenterLastValue(bool flag, float range)
{
	AutoCenterLastValue = flag;
	if(flag)
	{
		if(range > 0.0f) AutoFollowRange = range;
		else 
		{
			ldbg.send("(Internal LDBG_GraphAxis Exeption) setRange_CenterLastValue : This range (" + StringConverter::toString(range) + ") isn't greater than 0. Command ingored.");
			AutoFollowRange = -1;
			AutoFollowLastValue = false;
		}
	}
	else
		AutoFollowRange = -1;}void LdbgGraphAxis::setRange_KeepAllInRange(bool flag, bool keeporgin)
{
	AutoKeepAllInRange = flag;
	AutoKeepOrigin = keeporgin;	if(!AutoKeepAllInRange)
		AutoKeepOrigin = false;
}
void LdbgGraphAxis::update()
{
	if(AutoKeepAllInRange && AutoFollowLastValue)
	{
		AutoKeepAllInRange = AutoFollowLastValue = false;
		ldbg.send("(Internal LDBG_GraphAxis Exeption) Axis configured both to keep all datas in range and to follow only the last. Both are now disabled");
	}	CursorValue->setCaption(StringConverter::toString(Datas.back(),3,3));	if(Datas.size() > 0)
	{
		if(AutoKeepAllInRange)
		{
			// Ajust min to the smallest value
			if(AutoKeepOrigin) min = origin;
			else min = Datas[0];			for (	std::vector<float>::iterator DataIterator = Datas.begin();
					DataIterator != Datas.end();
					DataIterator++)
				if(*DataIterator < min) min = *DataIterator;			
			// Ajust max to the greatest value
			if(AutoKeepOrigin) max = origin;
			else max = Datas[0];			for (	std::vector<float>::iterator DataIterator = Datas.begin();
					DataIterator != Datas.end();
					DataIterator++)
				if(*DataIterator > max) max = *DataIterator;
		}
		if(AutoFollowLastValue)
		{
			min = Datas.back()-AutoFollowRange; 
			max = Datas.back();
		}
		if(AutoCenterLastValue)
		{
			// La dernière valeure ajoutée est centrée sur le scope.
			max = Datas.back()+AutoFollowRange;	
			min = Datas.back()-AutoFollowRange;
		}
	}	// Recrée les valeurs du ruler
	if(RulerInterval != 0)
	{
		if((max-min)/RulerInterval > MaxRuler) // Evite que le nombre d'overlay diverge
			RulerInterval = (max-min)/MaxRuler;
				
		while((max-min)/RulerInterval > RulerValue.size()) // Ajoute des overlay si besoin
		{
			std::pair<Ogre::uint, Ogre::TextAreaOverlayElement*> NewRulerOverlay;
			NewRulerOverlay.first = 0;
			NewRulerOverlay.second = static_cast<Ogre::TextAreaOverlayElement*>(OverlayManager::getSingleton().createOverlayElement("TextArea", "GraphRuler"+ StringConverter::toString(sys0.timer.getMicroseconds())));
			NewRulerOverlay.second->setMetricsMode(Ogre::GMM_PIXELS);
			NewRulerOverlay.second->setDimensions(16, 100);
			NewRulerOverlay.second->setCharHeight(12);
			NewRulerOverlay.second->setFontName("DejaVuSans");
			NewRulerOverlay.second->setColourBottom(TextColour);
			NewRulerOverlay.second->setColourTop(TextColour);
			RulerValue.push_back(NewRulerOverlay);
		}		{
			unsigned int i = 0;
			for (	float Rulervalue = min;
					i<RulerValue.size() && Rulervalue < max;
					i++, Rulervalue += RulerInterval)
			{
				RulerValue[i].second->setCaption(StringConverter::toString(Rulervalue,3,3));
				RulerValue[i].first = Rulervalue;
			}
		}
	}
	else
		for (Ogre::uint i=0; i<RulerValue.size(); i++)
			RulerValue[i].second->setCaption("");}#include "Namuh_Main_H.h"using namespace Ogre;static CEGUI::uint _considerNumpadKey(OIS::KeyCode argkey,unsigned int* text=NULL)
{
    switch (argkey)
    {
    case OIS::KC_NUMPAD0: if (text) *text=48; return 1;
    case OIS::KC_NUMPAD1: if (text) *text=49; return 2;
    case OIS::KC_NUMPAD2: if (text) *text=50; return 3;
    case OIS::KC_NUMPAD3: if (text) *text=51; return 4;
    case OIS::KC_NUMPAD4: if (text) *text=52; return 5;
    case OIS::KC_NUMPAD5: if (text) *text=53; return 6;
    case OIS::KC_NUMPAD6: if (text) *text=54; return 7;
    case OIS::KC_NUMPAD7: if (text) *text=55; return 8;
    case OIS::KC_NUMPAD8: if (text) *text=56; return 9;
    case OIS::KC_NUMPAD9: if (text) *text=57; return 10;
	case OIS::KC_DECIMAL: if (text) *text=46; return 46;
    }    return argkey;
}CEGUI::OgreRenderer* Gui_manager::mRenderer = 0;
CEGUI::System* Gui_manager::sys = 0;
CEGUI::WindowManager* Gui_manager::winMgr = 0;void Gui_manager::initialise_CEGUI(void)
{
	
	CEGUI::MouseCursor::getSingleton().setVisible(!CEGUI::MouseCursor::getSingleton().isVisible());
	mouseX = mouseY = mouseZ = 0;
	sys0.mKeyboard->setEventCallback( this );
	sys0.mMouse->setEventCallback(this);
};Gui_manager::~Gui_manager(void) //Destructeur
{
	CEGUI::WindowManager::getSingleton().destroyAllWindows();
};
void Gui_manager::Update(float time) // Charge l'interface de la Sandbox
{	//SetCursorPos(0,0); // le curseur win32 est indépendant de celui d'OIS
	sys0.mMouse->capture(); const OIS::MouseState &ms = sys0.mMouse->getMouseState(); // Met a jour la souris
	
	sys->injectTimePulse(time);	sys->renderGUI();
	mouseX += ms.X.rel;
	mouseY += ms.Y.rel;
	mouseZ += ms.Z.rel;
};
 
bool Gui_manager::keyPressed( const OIS::KeyEvent &arg )
{
	Ogre::uint text = arg.text;
	sys->injectKeyDown(_considerNumpadKey(arg.key,&text));
	sys->injectChar(text);
     return true;
}
 
bool Gui_manager::keyReleased( const OIS::KeyEvent &arg )
{
 	sys->injectKeyUp(_considerNumpadKey(arg.key));
     return true;
} 
bool Gui_manager::mouseMoved( const OIS::MouseEvent &e )
{
	sys->injectMouseMove(e.state.X.rel, e.state.Y.rel);
    return true;
}
 
bool Gui_manager::mousePressed( const OIS::MouseEvent &e, OIS::MouseButtonID id )
{
	if(e.state.buttonDown( OIS::MB_Right )) sys->injectMouseButtonDown(CEGUI::RightButton);
	else sys->injectMouseButtonUp(CEGUI::RightButton);
	if(e.state.buttonDown( OIS::MB_Left )) CEGUI::System::getSingleton().injectMouseButtonDown(CEGUI::LeftButton);
	else sys->injectMouseButtonUp(CEGUI::LeftButton);
	if(e.state.buttonDown( OIS::MB_Middle )) sys->injectMouseButtonDown(CEGUI::MiddleButton);
	else sys->injectMouseButtonUp(CEGUI::MiddleButton);
    return true;
}
 
bool Gui_manager::mouseReleased( const OIS::MouseEvent &e, OIS::MouseButtonID id )
{
	if(e.state.buttonDown( OIS::MB_Right )) sys->injectMouseButtonDown(CEGUI::RightButton);
	else sys->injectMouseButtonUp(CEGUI::RightButton);
	if(e.state.buttonDown( OIS::MB_Left )) CEGUI::System::getSingleton().injectMouseButtonDown(CEGUI::LeftButton);
	else sys->injectMouseButtonUp(CEGUI::LeftButton);
	if(e.state.buttonDown( OIS::MB_Middle )) sys->injectMouseButtonDown(CEGUI::MiddleButton);
	else sys->injectMouseButtonUp(CEGUI::MiddleButton);
 
    return true;
}
 
void Gui_manager::CreateMsgBox(MsgBoxType type, string msg)
{
	ldbg.send("(CreateMsgBox TODO) Extend the API to create a wider variety of dialog boxes",false);
	ldbg.send("(CreateMsgBox TODO) Aw, and also make a standard prefix for all loaded layouts (Wich is time dependent, so avoid conflicts)",false);
	string prefix = "MGBox" + StringConverter::toString(sys0.timer.getMicroseconds());
	sys->getGUISheet()->addChildWindow(CEGUI::WindowManager::getSingleton().loadWindowLayout("MSGBox1Bttn.layout",prefix));
	winMgr->getWindow(prefix + "MSGBox1Bttn/msg")->setText(msg);
	winMgr->getWindow(prefix + "MSGBox1Bttn/OkBttn")->setText("Ok");	// Suscribe new UI elements
	CEGUI::FrameWindow* msgWin = static_cast<CEGUI::FrameWindow*>(winMgr->getWindow(prefix+"MSGBox1Bttn"));
	msgWin->subscribeEvent(CEGUI::FrameWindow::EventCloseClicked, CEGUI::Event::Subscriber(&Gui_manager::HandleDeleteMsgBox, this));	CEGUI::PushButton* Boutton = static_cast<CEGUI::PushButton*>(winMgr->getWindow(prefix+"MSGBox1Bttn/OkBttn"));
	Boutton->subscribeEvent(CEGUI::PushButton::EventClicked, CEGUI::Event::Subscriber(&Gui_manager::HandleDeleteMsgBox, this));
	
}
 
bool Gui_manager::HandleDeleteMsgBox(const CEGUI::EventArgs &e)
{
	// Ferme la fenètre
	CEGUI::Window *winToDestroy = static_cast<const CEGUI::WindowEventArgs&>(e).window;
	if(string(winToDestroy->getType().c_str()) == "TaharezLook/Button")
		winToDestroy = static_cast<const CEGUI::WindowEventArgs&>(e).window->getParent();	sys->getGUISheet()->removeChildWindow(winToDestroy);
	winToDestroy->destroy();
	return true;
}#include "Namuh_Main_H.h"
using namespace Ogre;void Gui_FPS_manager::Initialise(void)
{	this ->initialise_CEGUI(); 
	layout = CEGUI::WindowManager::getSingleton().loadWindowLayout("FPS.layout"); 
	sys->setGUISheet(layout);
	//if(raknet_man.isServer)
	{
//		ldbg.enable(); // A partir de la, le Live Debugger est opérationnel
//		GuiSandboxMan.winMgr->getWindow("Live_debugger")->setUserString("BackgroundEnabled","True");
	}
	ldbg.enable(); // A partir de la, le Live Debugger est opérationnel
	WinStats = winMgr->getWindow("FPS_interface/Stats");
	WinStats->setText("Loading....\n ");	WinEndGame = winMgr->getWindow("FPS_interface/EndGameBoxFrameWindow");
	WinEndGame->setVisible(false);
	WinEndGameText = winMgr->getWindow("FPS_interface/EndGameBox");	CEGUI::MouseCursor::getSingleton().setVisible(false);	menucirc_armesA.create(Menuci_Type_Four);
	menucirc_armesE.create(Menuci_Type_Four);
	menucirc_cstr.create(Menuci_Type_Four);
	Affichage_vie.initialise();
};void Gui_FPS_manager::UpdateFPS_UI(float dt)
{
	if(!raknet_man.isServer)
	{
		/* ======================================================== Code Client ===========================================================================
		***************************************************************************************************************************************************/
		if(!Ruler.EndOfGame)
		{
			// Gestion de la souris
			local_player.OrientationInput.x = -mouseX*0.4*(!Menuci::isthereOneVisible);
			local_player.OrientationInput.y = -mouseY*0.4*(!Menuci::isthereOneVisible);
			mouseX = mouseY = mouseZ = 0;			// Grstion du tir
			local_player.FireInput = sys0.ms->buttonDown(OIS::MB_Left);			// Gestion du clavier
			local_player.MotionInput = local_player.movespeed*Ogre::Vector4(	sys0.mKeyboard->isKeyDown(OIS::KC_W),
																				sys0.mKeyboard->isKeyDown(OIS::KC_S),
																				sys0.mKeyboard->isKeyDown(OIS::KC_A),
																				sys0.mKeyboard->isKeyDown(OIS::KC_D));
			local_player.JumpInput = sys0.mKeyboard->isKeyDown(OIS::KC_SPACE) || !local_player.CharCtrl->hasCollidedDown();			//Update l'UI
			Update(dt/5);			// Les menus circulaires de changement d'arme
			menucirc_armesA.isVisible = sys0.mKeyboard->isKeyDown(OIS::KC_Q);
			menucirc_armesE.isVisible = sys0.mKeyboard->isKeyDown(OIS::KC_E);
			menucirc_cstr.isVisible = sys0.ms->buttonDown(OIS::MB_Middle);
			menucirc_armesA.update();
			menucirc_armesE.update();
			menucirc_cstr.update();			// Fabrication de construction
			if(menucirc_cstr.output == 1)this->MakeCstr(0);
			if(menucirc_cstr.output == 2)this->MakeCstr(1);
			if(menucirc_cstr.output == 3)this->MakeCstr(2);
			if(menucirc_cstr.output == 4)this->MakeCstr(3);
			// Changement d'arme
			if(menucirc_armesA.output == 1)local_player.SwichWeapon(0,true);// Lance Pierre
			if(menucirc_armesA.output == 2)local_player.SwichWeapon(2,true);// Javelot
			if(menucirc_armesA.output == 4)local_player.SwichWeapon(1,true);// Arc
		}
		else
		{
			if(!WinEndGame->isVisible()) WinEndGame->setVisible(true);
			//refaire cette fenêtre
		}
	}
	else
	{		/* ======================================================== Code Serveur ===========================================================================
	       ************************************************************************************************************************************************* */
		if(!Ruler.EndOfGame)
		{
			
			std::map<RakNet::RakNetGUID, Perso*>::iterator PlayerIterator = PlayerList.begin();
			std::map<RakNet::RakNetGUID, KeyState>::iterator KeyIterator = KeyPlayer.begin();
			while ( PlayerIterator != PlayerList.end() && KeyIterator != KeyPlayer.end() )
			{
				if(PlayerIterator->second != &local_player)
				{
					// Prédiction des mouvements de la souris (Le client reste maitre de son orientation)
					PlayerIterator->second->OrientationInput = PlayerIterator->second->rotative_velocity*dt*1000;
					//*(sys0.timer.getMilliseconds()-PlayerIterator->second->Last_rotatetime);
					Debug_Text += "rotative_velocity.x : " + StringConverter::toString(float(PlayerIterator->second->rotative_velocity.x)) + "\n";					// Gestion des movements
					PlayerIterator->second->MotionInput = ((*raknet_man.gametime-KeyIterator->second.timestamp)/dt) // facteur de prédiction des mouvement clientside (réduit la latence percue)
														  * PlayerIterator->second->movespeed*Ogre::Vector4(	KeyIterator->second.up,
																												KeyIterator->second.down,
																												KeyIterator->second.left,
																												KeyIterator->second.right);
					PlayerIterator->second->JumpInput = KeyIterator->second.jump || !PlayerIterator->second->CharCtrl->hasCollidedDown();					// Gestion du tir
					PlayerIterator->second->FireInput = KeyIterator->second.fire; 
				}
				PlayerIterator++;
				KeyIterator++;
			}
		}
		else
		{
			if(!WinEndGame->isVisible()) WinEndGame->setVisible(true);
			WinEndGameText->setText("Fin du Jeu ! \n Player 1 : ");//+StringConverter::toString(Ruler.PointList[0])+"pts \n Player2 : "+StringConverter::toString(Ruler.PointList[1])+"pts");
		}
	}
	
}			void Gui_FPS_manager::UpdateStats(void)
{	
	//Debug_Text += "Points : " + StringConverter::toString(Ruler.PointList[0]) + "\n";
	Debug_Text += "FPS : " + StringConverter::toString(sys1.FPS) + "\n";
	//Debug_Text += "gametime : " + StringConverter::toString(float(*raknet_man.gametime)) + "\n";
	//Debug_Text += "rotative_velocity.x : " + StringConverter::toString(float(local_player.rotative_velocity.x)) + "\n";
	WinStats->setText(Debug_Text);
	Debug_Text = "";
}void Gui_FPS_manager::Destroy(void)
{	
	ldbg.disable();
	CEGUI::WindowManager::getSingleton().destroyAllWindows();
}void Gui_FPS_manager::MakeCstr(Ogre::uint FavIndex)
{		if(FavIndex < ProfileMgr.getCurrent()->FavoritesConstructions.size())
		CstrMgr.Load(ProfileMgr.getCurrent()->FavoritesConstructions[FavIndex],local_player.pos);
	else
		ldbg.send("(Gui_FPS_manager MakeCstr  Exception) REquested to build a favorited construction with a number out of bound. Command ignored.");
}
#include "Namuh_Main_H.h"
using namespace Ogre;Gui_MainMenu_manager GuiMainMenuMan;Gui_MainMenu_manager::Gui_MainMenu_manager(void)
{
	IsBackGroundInitialised = false;
}void Gui_MainMenu_manager::Initialise(void)
{	
    this->initialise_CEGUI();	// Construct loading screen
	this->ConstructLoadingScreen();
	sys1.update(1/60);
	this->Update(1);
	this->winMgr->destroyAllWindows();	layout = winMgr->loadWindowLayout("Menu Principal.layout"); 
	sys->setGUISheet(layout);
	Main.create(Menuci_Type_MainMenu);
	sys0.mKeyboard->setEventCallback( this );
//	ldbg.enable(); // A partir de la, le Live Debugger est opérationnel
	//TODO : retrouver ou est chargé le fichier Namuh.cfg	// Si aucun profil n'est diponible, on en crée un et sinon, on l'applique
	if(!ProfileMgr.isCurrentProfileValid)
	{
		Current_Submenu = Submenu_Other;
		//Charge la fenètre qui demande le nom du profil
		sys->getGUISheet()->addChildWindow(CEGUI::WindowManager::getSingleton().loadWindowLayout("FirstProfileNamePrompt.layout"));
		
		CEGUI::PushButton* Boutton = static_cast<CEGUI::PushButton*>(winMgr->getWindow("FirstProfileNameInput/OkBttn"));
		Boutton->subscribeEvent(CEGUI::PushButton::EventClicked, CEGUI::Event::Subscriber(&Gui_MainMenu_manager::HandleFirstProfileNamePromtOk, this));		CreateMsgBox(BttnOk,"TODO : when Namuh.cfg is deleted, try first to pick one of existing profiles rather than lauching the first-lauch assistant");
		CreateMsgBox(BttnOk,"Hey, I guess you're new here ! \n Before anything serious between us, you have to create yourself a profile first. Don't worry, it won't be long. \n Just do it !");
	}
	else
	{
		Data.Network.Defaut_IP = ProfileMgr.getCurrent()->Default_IP;
		Current_Submenu = Submenu_Main;
	}	Window.EntryNameBox = GuiMainMenuMan.winMgr->createWindow("TaharezLook/StaticText","MainMenu/EntryName");
		Window.EntryNameBox->setArea(CEGUI::URect( CEGUI::UDim(0.4,0),CEGUI::UDim(0.15,0) ,CEGUI::UDim(0.6,0),CEGUI::UDim(0.2,0) ));
		Window.EntryNameBox->setText("Menu Principal");
		//Window.EntryNameBox->setHorizontalAlignment(CEGUI::HorizontalAlignment::HA_CENTRE);
	GuiMainMenuMan.winMgr->getWindow("root")->addChildWindow(Window.EntryNameBox);	lastEscKey = false;	// Load background
	//this->SetupBackground();
}MainMenuUpdaterOutput Gui_MainMenu_manager::UpdateMainMenu(void)
{	
	// Load background
	this->UpdateBackground();
	// TODO : implement keyboard navigation
	MenuOutData.LancerPartie = false;	
	if(!sys0.mKeyboard->isKeyDown(OIS::KC_ESCAPE) && lastEscKey && Current_Submenu != Submenu_EscMenu)
	{
		this->ConstructEscmenu();
		lastEscKey = false;
	}	switch (Current_Submenu)
	{
		case(Submenu_Main):
		{
			Main.isVisible = !sys0.ms_releasing(OIS::MB_Left);			if(Main.Current_highlighted==1)Window.EntryNameBox->setText("Sandbox");
			if(Main.Current_highlighted==2)Window.EntryNameBox->setText("Partie Réseau");			Main.update();			if(Main.output == 1)
			{
				MenuOutData.LancerPartie = true;
				MenuOutData.Param.Net_Status = Partie_Locale;
				MenuOutData.Param.isSandbox = true;
				//MenuOutData.Param.Mapfile = "Maps/Chutes Bresiliennes/Chutes Bresiliennes.map";
				MenuOutData.Param.Mapfile = "Maps/Caribean Lost Island/Caribean Lost Island.map";
				//MenuOutData.Param.Mapfile = "Maps/Main Menu background/Main Menu background.map";				// Destroy background
				this->DestroyBackground();			}
			if(Main.output == 2)
			{
				Main.output = -1; // pour ne pas retourner directement dans le sous menu d'ou l'on vient
				Current_Submenu = Submenu_Network;
				ConstructSubmenu(Submenu_Network);				Main.isVisible = true;
				Main.update(); // garder le main a l'écran
			}
		}
		break;		case(Submenu_Network):
		{
			Network.isVisible = !sys0.ms_releasing(OIS::MB_Left);			if(Network.Current_highlighted==1)Window.EntryNameBox->setText("IP a connecter");
			if(Network.Current_highlighted==2)Window.EntryNameBox->setText("Retour");
			if(Network.Current_highlighted==3)Window.EntryNameBox->setText("Créer un serveur");
			if(Network.Current_highlighted==4)Window.EntryNameBox->setText("Connexion au serveur");			Network.update();			if(Network.output == 4)
			{
				MenuOutData.LancerPartie = true;
				MenuOutData.Param.Net_Status = Partie_Client;
				MenuOutData.Param.isSandbox = false;
				MenuOutData.Param.IPofSrv = Window.Network.IPEditBox->getText().c_str();
				MenuOutData.Param.Mapfile = "Maps/Chutes Bresiliennes/Chutes Bresiliennes.map";
				//MenuOutData.Param.Mapfile = "Maps/Caribean Lost Island/Caribean Lost Island.map";				
				// Destroy background
				this->DestroyBackground();			}
			if(Network.output == 3)
			{
				MenuOutData.LancerPartie = true;
				MenuOutData.Param.Net_Status = Partie_Server;
				MenuOutData.Param.isSandbox = false;
				//MenuOutData.Param.Mapfile = "Maps/Chutes Bresiliennes/Chutes Bresiliennes.map";
				MenuOutData.Param.Mapfile = "Maps/Caribean Lost Island/Caribean Lost Island.map";
		
				// Destroy background
				this->DestroyBackground();			}
			if(Network.output != -1 && Network.output != 1)
			{
				ofstream ocfg_file ("Namuh.conf",ios::out|ios::trunc);
				ocfg_file << Window.Network.IPEditBox->getText();
				Data.Network.Defaut_IP = Window.Network.IPEditBox->getText().c_str();
			}
			if(Network.output == 2)
			{
				DestructSubmenu(Submenu_Network);
				Current_Submenu = Submenu_Main;
				ConstructSubmenu(Submenu_Main);
			}
			if(Network.output == 1)
			{
				if(!Window.Network.IPEditBox->isDisabled())
				{
					Window.Network.IPEditBox->deactivate();
					Window.Network.IPEditBox->disable();
				}
				else
				{
					Window.Network.IPEditBox->enable();
					Window.Network.IPEditBox->activate();
				}
			}
			if(!Window.Network.IPEditBox->isDisabled() && (sys0.mKeyboard->isKeyDown(OIS::KC_RETURN) || sys0.mKeyboard->isKeyDown(OIS::KC_NUMPADENTER))) // Sortie de la config d'ip via touche entrée
			{
				Window.Network.IPEditBox->deactivate();
				Window.Network.IPEditBox->disable();
			}		}
		break;
		case(Submenu_EscMenu):
		{
			EscMenu.isVisible = !sys0.ms_releasing(OIS::MB_Left) && !lastEscKey;
			EscMenu.update();			if(EscMenu.Current_highlighted==1)GuiMainMenuMan.winMgr->getWindow("EscMenuWin/Infotext")->setText("Unused");
			if(EscMenu.Current_highlighted==2)GuiMainMenuMan.winMgr->getWindow("EscMenuWin/Infotext")->setText("Profil joueur");
			if(EscMenu.Current_highlighted==3)GuiMainMenuMan.winMgr->getWindow("EscMenuWin/Infotext")->setText("Quitter Namuh");
			if(EscMenu.Current_highlighted==4)GuiMainMenuMan.winMgr->getWindow("EscMenuWin/Infotext")->setText("Options");
			// Profil du joueur
			if(EscMenu.output == 2)
			{
				ConstructPlayerProfilemenu();
				Current_Submenu = Submenu_PlayerProfile;
			}			// Quitte le jeu
			if(EscMenu.output == 3)
			{
				ldbg.send("(MainMenuEscMenu info) recieved quit command, sending MusQuit signal.");
				sys1.MustQuit = true;
				
				// Destroy background
				this->DestroyBackground();			}			// Quitte le menu
			if(!sys0.mKeyboard->isKeyDown(OIS::KC_ESCAPE) && lastEscKey)
			{
				lastEscKey = false;
				this->DestructEscmenu();
			}
		}
		break;
	}	lastEscKey = sys0.mKeyboard->isKeyDown(OIS::KC_ESCAPE);
	
	sys1.update(1/60);
	Update(1/sys1.FPS);
	return MenuOutData;
}void Gui_MainMenu_manager::ConstructSubmenu(Submenu type)
{
	switch (Current_Submenu)
	{
		case(Submenu_Main):
		{
			CEGUI::MouseCursor::getSingleton().setPosition(CEGUI::Point(sys0.vp->getActualWidth()/2,sys0.vp->getActualHeight()/2));
		}
		break;
		case(Submenu_Network):
		{
			Network.create(Menuci_Type_Four,(sys0.vp->getActualWidth()/2)-sys0.vp->getActualHeight()*0.2,(sys0.vp->getActualHeight()/2));			Window.Network.IPEditBox = GuiMainMenuMan.winMgr->createWindow("TaharezLook/Editbox","Submenu_Network/IPEditbox");
				Window.Network.IPEditBox->setSize(CEGUI::UVector2(CEGUI::UDim(0,250),CEGUI::UDim(0,30)));
				Window.Network.IPEditBox->setPosition(CEGUI::UVector2(CEGUI::UDim(0,(sys0.vp->getActualWidth()/2)-sys0.vp->getActualHeight()*0.2-125),CEGUI::UDim(0,(sys0.vp->getActualHeight()/2)-sys0.vp->getActualHeight()*0.10-30)));
				Window.Network.IPEditBox->setInheritsAlpha(false);
				Window.Network.IPEditBox->setAlpha(1.0f); 
				Window.Network.IPEditBox->setText(Data.Network.Defaut_IP);
				Window.Network.IPEditBox->deactivate();
				Window.Network.IPEditBox->disable();
			GuiMainMenuMan.winMgr->getWindow("root")->addChildWindow(Window.Network.IPEditBox);
		}
	}
};void Gui_MainMenu_manager::DestructSubmenu(Submenu type)
{
	switch (Current_Submenu)
	{
		case(Submenu_Network):
		{
			//Network.destroy ?
			CEGUI::WindowManager::getSingleton().destroyWindow(Window.Network.IPEditBox);
		}
	}
}void Gui_MainMenu_manager::ConstructEscmenu(void)
{
	if(!CEGUI::WindowManager::getSingleton().isWindowPresent("EscMenuWin"))
	{
		// TODO : Makes the circular menu a child of the window
		EscMenu_Previous_Submenu = Current_Submenu;
		Current_Submenu = Submenu_EscMenu;		sys->getGUISheet()->addChildWindow(CEGUI::WindowManager::getSingleton().loadWindowLayout("MainMenuEscMenu.layout"));
		EscMenu.create(	Menuci_Type_Four,
						sys0.vp->getActualWidth()/2,
						sys0.vp->getActualHeight()/2);
		EscMenu.setAllwaysOnTop(true);
					//	GuiMainMenuMan.winMgr->getWindow("EscMenuWin")->getArea().getWidth().asAbsolute(sys0.vp->getActualWidth())/2,
					//	GuiMainMenuMan.winMgr->getWindow("EscMenuWin")->getArea().getHeight().asAbsolute(sys0.vp->getActualHeight())/2);
						//"EscMenuWin");
	}
	else
		ldbg.send("(ConstructEscmenu Exeption) Called ConstructEscmenu while the EscMenu is already present. Command ignored.");
}
bool Gui_MainMenu_manager::DestructEscmenu(const CEGUI::EventArgs&)
{
	//EscMenu.destroy ?
	Current_Submenu = EscMenu_Previous_Submenu;	// Ferme la fenètre
	sys->getGUISheet()->removeChildWindow("EscMenuWin");
	winMgr->destroyWindow("EscMenuWin");	return true;
}
void Gui_MainMenu_manager::ConstructPlayerProfilemenu(void)
{
	CEGUI::MouseCursor::getSingleton().setPosition(CEGUI::Point(sys0.vp->getActualWidth()/2,sys0.vp->getActualHeight()/2));	//Charge la layout
	sys->getGUISheet()->addChildWindow(CEGUI::WindowManager::getSingleton().loadWindowLayout("PlayerProfileMenu.layout"));
	
	// Suscribe new UI elements
	CEGUI::FrameWindow* SaveAsWin = static_cast<CEGUI::FrameWindow*>(winMgr->getWindow("PlayerProfileWin"));
	SaveAsWin->subscribeEvent(CEGUI::FrameWindow::EventCloseClicked, CEGUI::Event::Subscriber(&Gui_MainMenu_manager::HandlePlayerProfileClose, this));	CEGUI::PushButton* Boutton = static_cast<CEGUI::PushButton*>(winMgr->getWindow("PlayerProfileWin/CancelBttn"));
	Boutton->subscribeEvent(CEGUI::PushButton::EventClicked, CEGUI::Event::Subscriber(&Gui_MainMenu_manager::HandlePlayerProfileClose, this));
	Boutton = static_cast<CEGUI::PushButton*>(winMgr->getWindow("PlayerProfileWin/EditConstructionsFavorites"));
	Boutton->subscribeEvent(CEGUI::PushButton::EventClicked, CEGUI::Event::Subscriber(&Gui_MainMenu_manager::HandlePlayerProfileEditFavoriteConstruction, this));
}
   
void Gui_MainMenu_manager::ConstructLoadingScreen(void) // a mettre dans ConstructSubmenu ?
{
	CEGUI::Window* Rootwindow;
	if(winMgr->isWindowPresent("root")) // Root n'existe pas forcément
		Rootwindow = GuiMainMenuMan.winMgr->getWindow("root");
	else
	{
		Rootwindow = GuiMainMenuMan.winMgr->createWindow( "DefaultWindow", "root" );
		CEGUI::System::getSingleton().setGUISheet(Rootwindow);
	}	CEGUI::Window *LoadingScreen = GuiMainMenuMan.winMgr->createWindow("TaharezLook/StaticImage","MainMenu/Loading Screen");
	LoadingScreen->setProperty("Image","set:Loading_Screen image:LoadingScreen");
		Rootwindow->addChildWindow(LoadingScreen);
};
bool Gui_MainMenu_manager::HandleFirstProfileNamePromtOk(const CEGUI::EventArgs&)
{
	//Crée le profil et le définit comme le profil courant
	ProfileMgr.CreateNew(string(winMgr->getWindow("FirstProfileNameInput/ProfileName")->getText().c_str()));
	ProfileMgr.setCurrent(ProfileMgr.Load("Players Profiles Datas/"+string(winMgr->getWindow("FirstProfileNameInput/ProfileName")->getText().c_str())+"/MainFile.cfg"));	Data.Network.Defaut_IP = ProfileMgr.getCurrent()->Default_IP;
	//Active le menu principal
	Current_Submenu = Submenu_Main;	// Ferme la fenètre
	sys->getGUISheet()->removeChildWindow("FirstProfileNameInput");
	winMgr->getWindow("FirstProfileNameInput")->destroy();
	return true;
}#include "Namuh_Main_H.h"
using namespace Ogre;
bool Gui_MainMenu_manager::HandlePlayerProfileClose(const CEGUI::EventArgs&)
{
	Current_Submenu = Submenu_EscMenu;	// Ferme la fenètre
	sys->getGUISheet()->removeChildWindow("PlayerProfileWin");
	winMgr->destroyWindow("PlayerProfileWin");	return true;
}
bool Gui_MainMenu_manager::HandlePlayerProfileEditFavoriteConstruction(const CEGUI::EventArgs&)
{
	Current_Submenu = Submenu_PlayerProfileEditFavoritesConstructions;	CEGUI::MouseCursor::getSingleton().setPosition(CEGUI::Point(sys0.vp->getActualWidth()/2,sys0.vp->getActualHeight()/2));	//Charge la layout
	sys->getGUISheet()->addChildWindow(CEGUI::WindowManager::getSingleton().loadWindowLayout("PlayerProfileEditFavoritesConstructionsMenu.layout"));	// Liste les constuctions favorites
	CEGUI::Listbox* FavLst = static_cast<CEGUI::Listbox*>(GuiSandboxMan.winMgr->getWindow("PlayerProfileEditFavCstrsWin/FavoritedConstructionSelector"));
	FavLst->resetList();
	CEGUI::ListboxTextItem* FavListItem;
	for( Ogre::uint i = 0; i<ProfileMgr.getCurrent()->FavoritesConstructions.size(); ++i)
	{
		FavListItem = new CEGUI::ListboxTextItem(ProfileMgr.getCurrent()->FavoritesConstructions[i]);
		FavListItem->setSelectionBrushImage("TaharezLook", "ListboxSelectionBrush");
		FavLst->addItem(FavListItem);
	}
	
	// Liste les constuctions tout court
	CEGUI::Combobox* CstrLst = static_cast<CEGUI::Combobox*>(GuiSandboxMan.winMgr->getWindow("PlayerProfileEditFavCstrsWin/ConstructionSelector"));
	CstrLst->resetList();
	WIN32_FIND_DATA findFileData;
	HANDLE hFind = FindFirstFile(&string("Players Profiles Datas\\"+ProfileMgr.getCurrent()->Name+"\\Constructions\\*.nmh")[0], &findFileData);
	if (hFind != INVALID_HANDLE_VALUE)
	{
		CEGUI::ListboxTextItem* CstrListItem = NULL;
		//FindNextFile(hFind, &findFileData);
		do
		{
			CstrListItem = new CEGUI::ListboxTextItem(findFileData.cFileName);
			CstrListItem->setSelectionBrushImage("TaharezLook", "ListboxSelectionBrush");
			CstrLst->addItem(CstrListItem);
		} 
		while(FindNextFile(hFind, &findFileData));
		
		FindClose(hFind);
	}
	else
		ldbg.send("(SandboxLoadFile Exeption) No file founded");	
	// grise le boutton save (on ne peut sauvegarder sans chagements)
	static_cast<CEGUI::PushButton*>(winMgr->getWindow("PlayerProfileEditFavCstrsWin/SaveBttn"))->disable();	// Suscribe new UI elements
	CEGUI::FrameWindow* SaveAsWin = static_cast<CEGUI::FrameWindow*>(winMgr->getWindow("PlayerProfileEditFavCstrsWin"));
	SaveAsWin->subscribeEvent(CEGUI::FrameWindow::EventCloseClicked, CEGUI::Event::Subscriber(&Gui_MainMenu_manager::HandlePlayerProfileEditFavoriteConstructionClose, this));	CEGUI::PushButton* Boutton = static_cast<CEGUI::PushButton*>(winMgr->getWindow("PlayerProfileEditFavCstrsWin/CancelBttn"));
	Boutton->subscribeEvent(CEGUI::PushButton::EventClicked, CEGUI::Event::Subscriber(&Gui_MainMenu_manager::HandlePlayerProfileEditFavoriteConstructionClose, this));
	Boutton = static_cast<CEGUI::PushButton*>(winMgr->getWindow("PlayerProfileEditFavCstrsWin/AddFavBttn"));
	Boutton->subscribeEvent(CEGUI::PushButton::EventClicked, CEGUI::Event::Subscriber(&Gui_MainMenu_manager::HandlePlayerProfileEditFavoriteConstructionAddBttn, this));
	Boutton = static_cast<CEGUI::PushButton*>(winMgr->getWindow("PlayerProfileEditFavCstrsWin/ReplaceFavBttn"));
	Boutton->subscribeEvent(CEGUI::PushButton::EventClicked, CEGUI::Event::Subscriber(&Gui_MainMenu_manager::HandlePlayerProfileEditFavoriteConstructionEditBttn, this));
	Boutton = static_cast<CEGUI::PushButton*>(winMgr->getWindow("PlayerProfileEditFavCstrsWin/DelFavBttn"));
	Boutton->subscribeEvent(CEGUI::PushButton::EventClicked, CEGUI::Event::Subscriber(&Gui_MainMenu_manager::HandlePlayerProfileEditFavoriteConstructionDelBttn, this));
	Boutton = static_cast<CEGUI::PushButton*>(winMgr->getWindow("PlayerProfileEditFavCstrsWin/SaveBttn"));
	Boutton->subscribeEvent(CEGUI::PushButton::EventClicked, CEGUI::Event::Subscriber(&Gui_MainMenu_manager::HandlePlayerProfileEditFavoriteConstructionSave, this));
	Boutton = static_cast<CEGUI::PushButton*>(winMgr->getWindow("PlayerProfileEditFavCstrsWin/SaveAndCloseBttn"));
	Boutton->subscribeEvent(CEGUI::PushButton::EventClicked, CEGUI::Event::Subscriber(&Gui_MainMenu_manager::HandlePlayerProfileEditFavoriteConstructionSaveAndClose, this));	return true;
}bool Gui_MainMenu_manager::HandlePlayerProfileEditFavoriteConstructionAddBttn(const CEGUI::EventArgs&)
{	CEGUI::Combobox* CstrLst = static_cast<CEGUI::Combobox*>(GuiSandboxMan.winMgr->getWindow("PlayerProfileEditFavCstrsWin/ConstructionSelector"));
	if(CstrLst->getSelectedItem() != NULL) // S'il y a bien une construction de sélectionnée
	{
		CEGUI::ListboxTextItem* FavListItem = new CEGUI::ListboxTextItem(CstrLst->getSelectedItem()->getText());
		FavListItem->setSelectionBrushImage("TaharezLook", "ListboxSelectionBrush");
		static_cast<CEGUI::Listbox*>(GuiSandboxMan.winMgr->getWindow("PlayerProfileEditFavCstrsWin/FavoritedConstructionSelector"))->addItem(FavListItem);
	}
	else
		CreateMsgBox(BttnOk,"Please select a construction in the combo list before adding it.");			// dégrise le boutton (on peut sauvegarder les chagements)
	static_cast<CEGUI::PushButton*>(winMgr->getWindow("PlayerProfileEditFavCstrsWin/SaveBttn"))->enable();	return true;
}bool Gui_MainMenu_manager::HandlePlayerProfileEditFavoriteConstructionEditBttn(const CEGUI::EventArgs&)
{
	CEGUI::Combobox* CstrLst = static_cast<CEGUI::Combobox*>(GuiSandboxMan.winMgr->getWindow("PlayerProfileEditFavCstrsWin/ConstructionSelector"));
	CEGUI::Listbox* FavLst = static_cast<CEGUI::Listbox*>(GuiSandboxMan.winMgr->getWindow("PlayerProfileEditFavCstrsWin/FavoritedConstructionSelector"));	if(CstrLst->getSelectedItem() != NULL) // S'il y a bien un favoris de sélectionné
	{
		if(FavLst->getFirstSelectedItem() != NULL) // S'il y a bien une construction avec laquelle interchanger de sélectionnée
			FavLst->getFirstSelectedItem()->setText(CstrLst->getSelectedItem()->getText());
		else
			CreateMsgBox(BttnOk,"Please select a favorite in the list to remplace the one you've selected.");
	}
	else
		CreateMsgBox(BttnOk,"Please select a construction in the combo list before editing it.");			
	// dégrise le boutton (on peut sauvegarder les chagements)
	static_cast<CEGUI::PushButton*>(winMgr->getWindow("PlayerProfileEditFavCstrsWin/SaveBttn"))->enable();	return true;
}bool Gui_MainMenu_manager::HandlePlayerProfileEditFavoriteConstructionDelBttn(const CEGUI::EventArgs&)
{	CEGUI::Listbox* FavLst = static_cast<CEGUI::Listbox*>(GuiSandboxMan.winMgr->getWindow("PlayerProfileEditFavCstrsWin/FavoritedConstructionSelector"));
	if(FavLst->getFirstSelectedItem() != NULL) // S'il y a bien un favoris sélectionnée
	{
		FavLst->getFirstSelectedItem()->setAutoDeleted(true);
		FavLst->removeItem(FavLst->getFirstSelectedItem());
	}
	else
		CreateMsgBox(BttnOk,"Please select a construction in the combo list before deleting it.");			// dégrise le boutton (on peut sauvegarder les chagements)
	static_cast<CEGUI::PushButton*>(winMgr->getWindow("PlayerProfileEditFavCstrsWin/SaveBttn"))->enable();	return true;
}bool Gui_MainMenu_manager::HandlePlayerProfileEditFavoriteConstructionClose(const CEGUI::EventArgs&)
{
	Current_Submenu = Submenu_PlayerProfile;	// Ferme la fenètre
	sys->getGUISheet()->removeChildWindow("PlayerProfileEditFavCstrsWin");
	winMgr->destroyWindow("PlayerProfileEditFavCstrsWin");	return true;
}
bool Gui_MainMenu_manager::HandlePlayerProfileEditFavoriteConstructionSaveAndClose(const CEGUI::EventArgs&)
{
	Current_Submenu = Submenu_PlayerProfile;
	CEGUI::Listbox* FavLst = static_cast<CEGUI::Listbox*>(GuiSandboxMan.winMgr->getWindow("PlayerProfileEditFavCstrsWin/FavoritedConstructionSelector"));	//Réécris la liste des favoris
	ProfileMgr.getCurrent()->FavoritesConstructions.clear();
	for(Ogre::uint i = 0; i<FavLst->getItemCount(); ++i)
		ProfileMgr.getCurrent()->FavoritesConstructions.push_back(string(FavLst->getListboxItemFromIndex(i)->getText().c_str()));	// Ferme la fenètre
	sys->getGUISheet()->removeChildWindow("PlayerProfileEditFavCstrsWin");
	winMgr->destroyWindow("PlayerProfileEditFavCstrsWin");	return true;
}bool Gui_MainMenu_manager::HandlePlayerProfileEditFavoriteConstructionSave(const CEGUI::EventArgs&)
{
	CEGUI::Listbox* FavLst = static_cast<CEGUI::Listbox*>(GuiSandboxMan.winMgr->getWindow("PlayerProfileEditFavCstrsWin/FavoritedConstructionSelector"));	//Réécris la liste des favoris
	ProfileMgr.getCurrent()->FavoritesConstructions.clear();
	for(Ogre::uint i = 0; i<FavLst->getItemCount(); ++i)
		ProfileMgr.getCurrent()->FavoritesConstructions.push_back(string(FavLst->getListboxItemFromIndex(i)->getText().c_str()));	// grise le boutton (on ne peut sauvegarder sans chagements)
	static_cast<CEGUI::PushButton*>(winMgr->getWindow("PlayerProfileEditFavCstrsWin/SaveBttn"))->disable();	return true;
}#include "Namuh_Main_H.h"
using namespace Ogre;void Gui_sandbox_manager::Initialise(void)
{
	this->initialise_CEGUI(); 	layout = CEGUI::WindowManager::getSingleton().loadWindowLayout("Sandbox.layout"); 
	sys->setGUISheet(layout);
	ldbg.enable(); // A partir de la, le Live Debugger est opérationnel	Info_Text = winMgr->getWindow("Sandbox_interface/System_info/Info_text");
	Info_Text->setText("Loading Sandbox");
	camctrl = true;
	cameravolanteswitch = true;
	CEGUI::MouseCursor::getSingleton().setVisible(false);
	lastFileNameSaved = "";	// Inscription des handelers
	this->Suscribe();
	
	// Initialisation controles
	last_spacekey = last_ctrlkey = false;
};void Gui_sandbox_manager::UpdateSandbox(float inv_FPS)
{
	// Gestion de la souris
	if(camctrl)
	{
		local_player.OrientationInput.x = -mouseX*0.4*(!Menuci::isthereOneVisible);
		local_player.OrientationInput.y = -mouseY*0.4*(!Menuci::isthereOneVisible);
		mouseX = mouseY = 0;
	}	// Gestion du clavier
	local_player.MotionInput = local_player.movespeed*Ogre::Vector4(	Ogre::Real(sys0.mKeyboard->isKeyDown(OIS::KC_W)),
																		Ogre::Real(sys0.mKeyboard->isKeyDown(OIS::KC_S)),
																		Ogre::Real(sys0.mKeyboard->isKeyDown(OIS::KC_A)),
																		Ogre::Real(sys0.mKeyboard->isKeyDown(OIS::KC_D)));
	local_player.JumpInput = sys0.mKeyboard->isKeyDown(OIS::KC_SPACE);// || !local_player.CharCtrl->hasCollidedDown();	// Ctrl donne la souris
	if(sys0.mKeyboard->isKeyDown( OIS::KC_LCONTROL )&& !last_ctrlkey) 
	{
		camctrl = !camctrl;
		CEGUI::MouseCursor::getSingleton().setVisible(!CEGUI::MouseCursor::getSingleton().isVisible());
		mouseX = mouseY = 0;
	}
	if(sys0.mKeyboard->isKeyDown( OIS::KC_LCONTROL ))
		last_ctrlkey = true;
	else 
		last_ctrlkey = false;	// Shift pour courir
	if(sys0.mKeyboard->isKeyDown( OIS::KC_LSHIFT ) || sys0.mKeyboard->isKeyDown( OIS::KC_RSHIFT ))
		local_player.movespeed=48*inv_FPS;
	else 
		local_player.movespeed=24*inv_FPS;
}void Gui_sandbox_manager::UpdateDebugtext(void)
{	
	Debug_Text = "FPS Actuel : " + StringConverter::toString(int(10*sys1.FPS)/10) + "\n";
	Debug_Text += "Constructeur.RondinCursor_n : " + StringConverter::toString(Constructeur.RondinCursor_n->getPosition()) + "\n";
	Debug_Text += "Constructeur.zcursor : " + StringConverter::toString(Constructeur.zcursor) + "\n";
	Debug_Text += "UI : " + StringConverter::toString(Watch_UI,2,2) + " % \n";
	Debug_Text += "PhysX : " + StringConverter::toString(Watch_PhysX,2,2) + " % \n";
	Debug_Text += "Atm : " + StringConverter::toString(Watch_Atm,2,2) + " % \n";
	Debug_Text += "Hydrax : " + StringConverter::toString(Watch_Hydrax,2,2) + " % \n";
	Debug_Text += "Terrain : " + StringConverter::toString(Watch_Terrain,2,2) + " % \n";
	Debug_Text += "PagedGeometry : " + StringConverter::toString(Watch_PagedGeometry,3,3) + " % \n";
	Debug_Text += "Sys1 : " + StringConverter::toString(Watch_Sys,4,4) + " % \n";
	Info_Text->setText(Debug_Text);
}void Gui_sandbox_manager::Destroy(void)
{	
	ldbg.disable();
	CEGUI::WindowManager::getSingleton().destroyAllWindows();
}
#include "Namuh_Main_H.h"
using namespace Ogre;bool Gui_sandbox_manager::HandleNewLnkOk(const CEGUI::EventArgs&)
{
	
	CEGUI::Listbox* Objlist = static_cast<CEGUI::Listbox*>(winMgr->getWindow("SanboxLinkCreator/FirstObjLst"));
	string objName = "";
	NxOgre::RigidBody	*FirstObj = NULL,
						*SecondObj = NULL;
	// Récupère le premier objet sélectionné
	if(Objlist->getFirstSelectedItem() != NULL) // S'il y a bien un 1er obj sélectionnée
		objName = Objlist->getFirstSelectedItem()->getText().c_str();
	for (	std::vector<Critter::Body*>::iterator itt = Constructeur.BuiltCstr[Constructeur.getConstruction_num()]->element.begin();
			itt != Constructeur.BuiltCstr[Constructeur.getConstruction_num()]->element.end();
			++itt)
			if((*itt)->getName() == objName)
				FirstObj = *itt;
	// Récupère le second objet séléctionné
	Objlist = static_cast<CEGUI::Listbox*>(winMgr->getWindow("SanboxLinkCreator/SecondObjLst"));
	if(Objlist->getFirstSelectedItem() != NULL) // S'il y a bien un 1er obj sélectionnée
		objName = Objlist->getFirstSelectedItem()->getText().c_str();
	for (	std::vector<Critter::Body*>::iterator itt = Constructeur.BuiltCstr[Constructeur.getConstruction_num()]->element.begin();
			itt != Constructeur.BuiltCstr[Constructeur.getConstruction_num()]->element.end();
			++itt)
			if((*itt)->getName() == objName)
				SecondObj = *itt;	if(SecondObj == FirstObj)
	{
		ldbg.send("(SanboxHandleNewLnkOk Exeption) Cannot create link : selected twice the same object");
		CreateMsgBox(BttnOk,"Cannot create link : You selected twice the same object !");
		return true;
	}
	else
	{
		// Fais le lien
			Constructeur.BuiltCstr[Constructeur.getConstruction_num()]->CreateFixedLink(FirstObj, SecondObj);
			// test :
			//Constructeur.BuiltCstr[Constructeur.getConstruction_num()]->CreateRevoluteLink(FirstObj, SecondObj);
				
		// Crée un élément dans la liste
		CEGUI::ListboxTextItem* LinkListItem = new CEGUI::ListboxTextItem(Constructeur.BuiltCstr[Constructeur.getConstruction_num()]->joint.back().name);
		LinkListItem->setSelectionBrushImage("TaharezLook", "ListboxSelectionBrush");
		static_cast<CEGUI::Listbox*>(GuiSandboxMan.winMgr->getWindow("Sandbox_interface/Sandbox/Liste_liaisons"))->addItem(LinkListItem);		// Ferme la fenètre
		sys->getGUISheet()->removeChildWindow("SanboxLinkCreator");
		winMgr->getWindow("SanboxLinkCreator")->destroy();
	}
	return true;
}
bool Gui_sandbox_manager::HandleNewLnkPickFrstObjBttn(const CEGUI::EventArgs&)
{
	winMgr->getWindow("SanboxLinkCreator")->disable();
	winMgr->getWindow("SanboxLinkCreator")->hide();	Constructeur.setConstructionMode(CREATE_LINK_PICK_FIRST);
	return true;
}
bool Gui_sandbox_manager::HandleNewLnkPickSecondObjBttn(const CEGUI::EventArgs&)
{
	// Cache la fenètre
	winMgr->getWindow("SanboxLinkCreator")->disable();
	winMgr->getWindow("SanboxLinkCreator")->hide();
	Constructeur.setConstructionMode(CREATE_LINK_PICK_SECOND);
	return true;
}bool Gui_sandbox_manager::HandleNewLnkCancel(const CEGUI::EventArgs&)
{
	// Ferme la fenètre
	sys->getGUISheet()->removeChildWindow("SanboxLinkCreator");
	winMgr->getWindow("SanboxLinkCreator")->destroy();
	return true;
}
#include "Namuh_Main_H.h"
using namespace Ogre;bool Gui_sandbox_manager::HandleLoadConstructionOk(const CEGUI::EventArgs&)
{
	string FileName = "";
	if(static_cast<CEGUI::Listbox*>(winMgr->getWindow("FileSelector/Filelist"))->getFirstSelectedItem() != NULL)
		FileName = static_cast<CEGUI::Listbox*>(winMgr->getWindow("FileSelector/Filelist"))->getFirstSelectedItem()->getText().c_str();
	if(FileName != "")
		Constructeur.BuiltCstr.push_back(CstrMgr.Load(FileName,Constructeur.ComputeCursor3DPos()));	// Crée un élément dans la liste
	CEGUI::Listbox* Cstrlist = static_cast<CEGUI::Listbox*>(GuiSandboxMan.winMgr->getWindow("Sandbox_interface/Sandbox/Liste_constructions"));
	CEGUI::ListboxTextItem* CstrListItem = new CEGUI::ListboxTextItem(Constructeur.BuiltCstr.back()->name);
	CstrListItem->setSelectionBrushImage("TaharezLook", "ListboxSelectionBrush");
	Cstrlist->addItem(CstrListItem);	// Ferme la fenètre
	sys->getGUISheet()->removeChildWindow("FileSelector");
	winMgr->getWindow("FileSelector")->destroy();	return true;
}bool Gui_sandbox_manager::HandleLoadConstructionCancel(const CEGUI::EventArgs&)
{
	// Ferme la fenètre
	sys->getGUISheet()->removeChildWindow("FileSelector");
	winMgr->getWindow("FileSelector")->destroy();
	return true;
}#include "Namuh_Main_H.h"
using namespace Ogre;/* 
=====================================================================================================================================================================================================================================================================================
============================================================================ Inscription des  Mains handlers ======================================================================================================================================================
===========================================================================================================================================================================================================================================================================
*/
void Gui_sandbox_manager::Suscribe(void)
{
	CEGUI::MenuItem* MenuItem = static_cast<CEGUI::MenuItem*>(winMgr->getWindow("Sandbox_interface/Menubar/FileButton/FileMenu/Load"));
	MenuItem->subscribeEvent(CEGUI::MenuItem::EventClicked, CEGUI::Event::Subscriber(&Gui_sandbox_manager::HandleLoadConstruction, this));
	MenuItem = static_cast<CEGUI::MenuItem*>(winMgr->getWindow("Sandbox_interface/Menubar/FileButton/FileMenu/Save"));
	MenuItem->subscribeEvent(CEGUI::MenuItem::EventClicked, CEGUI::Event::Subscriber(&Gui_sandbox_manager::HandleSaveConstruction, this));
	MenuItem = static_cast<CEGUI::MenuItem*>(winMgr->getWindow("Sandbox_interface/Menubar/FileButton/FileMenu/SaveAs"));
	MenuItem->subscribeEvent(CEGUI::MenuItem::EventClicked, CEGUI::Event::Subscriber(&Gui_sandbox_manager::HandleSaveConstructionAs, this));
	CEGUI::Checkbox* checkBox = static_cast<CEGUI::Checkbox*>(winMgr->getWindow("Sandbox_interface/System_info/Camera_volante"));
	checkBox->subscribeEvent(CEGUI::Checkbox::EventCheckStateChanged, CEGUI::Event::Subscriber(&Gui_sandbox_manager::Handlecameravolanteswitch, this));	CEGUI::PushButton* Boutton = static_cast<CEGUI::PushButton*>(winMgr->getWindow("Sandbox_interface/Sandbox/Log/Bttn"));
	Boutton->subscribeEvent(CEGUI::PushButton::EventClicked, CEGUI::Event::Subscriber(&Gui_sandbox_manager::HandleSandboxRondin, this));
	Boutton = static_cast<CEGUI::PushButton*>(winMgr->getWindow("Sandbox_interface/Sandbox/Rocher/Bttn"));
	Boutton->subscribeEvent(CEGUI::PushButton::EventClicked, CEGUI::Event::Subscriber(&Gui_sandbox_manager::HandleSandboxRocher, this));
	Boutton = static_cast<CEGUI::PushButton*>(winMgr->getWindow("Sandbox_interface/Sandbox/Disk/Bttn"));
	Boutton->subscribeEvent(CEGUI::PushButton::EventClicked, CEGUI::Event::Subscriber(&Gui_sandbox_manager::HandleSandboxDisk, this));
	Boutton = static_cast<CEGUI::PushButton*>(winMgr->getWindow("Sandbox_interface/Sandbox/Triangle/Bttn"));
	Boutton->subscribeEvent(CEGUI::PushButton::EventClicked, CEGUI::Event::Subscriber(&Gui_sandbox_manager::HandleSandboxTriangle, this));
	Boutton = static_cast<CEGUI::PushButton*>(winMgr->getWindow("Sandbox_interface/Sandbox/DelObjBttn"));
	Boutton->subscribeEvent(CEGUI::PushButton::EventClicked, CEGUI::Event::Subscriber(&Gui_sandbox_manager::HandleDelObj, this));
	Boutton = static_cast<CEGUI::PushButton*>(winMgr->getWindow("Sandbox_interface/Sandbox/NewLnkBttn"));
	Boutton->subscribeEvent(CEGUI::PushButton::EventClicked, CEGUI::Event::Subscriber(&Gui_sandbox_manager::HandleNewLnk, this));
	Boutton = static_cast<CEGUI::PushButton*>(winMgr->getWindow("Sandbox_interface/Sandbox/DelLnkBttn"));
	Boutton->subscribeEvent(CEGUI::PushButton::EventClicked, CEGUI::Event::Subscriber(&Gui_sandbox_manager::HandleDelLnk, this));	CEGUI::Scrollbar* scroller = static_cast<CEGUI::Scrollbar*>(winMgr->getWindow("Sandbox_interface/Sandbox/Log/Orientation/Scroller"));
	scroller->subscribeEvent(CEGUI::Scrollbar::EventScrollPositionChanged, CEGUI::Event::Subscriber(&Gui_sandbox_manager::HandleSandboxRondinOrientation, this));
	scroller = static_cast<CEGUI::Scrollbar*>(winMgr->getWindow("Sandbox_interface/Sandbox/Log/Length/Scroller"));
	scroller->subscribeEvent(CEGUI::Scrollbar::EventScrollPositionChanged, CEGUI::Event::Subscriber(&Gui_sandbox_manager::HandleSandboxRondinLength, this));
	scroller = static_cast<CEGUI::Scrollbar*>(winMgr->getWindow("Sandbox_interface/Sandbox/Log/Radius/Scroller"));
	scroller->subscribeEvent(CEGUI::Scrollbar::EventScrollPositionChanged, CEGUI::Event::Subscriber(&Gui_sandbox_manager::HandleSandboxRondinRadius, this));
	scroller = static_cast<CEGUI::Scrollbar*>(winMgr->getWindow("Sandbox_interface/Sandbox/Disk/Orientation/Scroller"));
	scroller->subscribeEvent(CEGUI::Scrollbar::EventScrollPositionChanged, CEGUI::Event::Subscriber(&Gui_sandbox_manager::HandleSandboxDiskOrientation, this));
	scroller = static_cast<CEGUI::Scrollbar*>(winMgr->getWindow("Sandbox_interface/Sandbox/Disk/Thickness/Scroller"));
	scroller->subscribeEvent(CEGUI::Scrollbar::EventScrollPositionChanged, CEGUI::Event::Subscriber(&Gui_sandbox_manager::HandleSandboxDiskThichness, this));
	scroller = static_cast<CEGUI::Scrollbar*>(winMgr->getWindow("Sandbox_interface/Sandbox/Disk/Radius/Scroller"));
	scroller->subscribeEvent(CEGUI::Scrollbar::EventScrollPositionChanged, CEGUI::Event::Subscriber(&Gui_sandbox_manager::HandleSandboxDiskRadius, this));
	scroller = static_cast<CEGUI::Scrollbar*>(winMgr->getWindow("Sandbox_interface/Sandbox/Triangle/Orientation/Scroller"));
	scroller->subscribeEvent(CEGUI::Scrollbar::EventScrollPositionChanged, CEGUI::Event::Subscriber(&Gui_sandbox_manager::HandleSandboxTriangleOrientation, this));
	scroller = static_cast<CEGUI::Scrollbar*>(winMgr->getWindow("Sandbox_interface/Sandbox/Triangle/Direction/Scroller"));
	scroller->subscribeEvent(CEGUI::Scrollbar::EventScrollPositionChanged, CEGUI::Event::Subscriber(&Gui_sandbox_manager::HandleSandboxTriangleDirection, this));
	scroller = static_cast<CEGUI::Scrollbar*>(winMgr->getWindow("Sandbox_interface/Sandbox/Triangle/Length/Scroller"));
	scroller->subscribeEvent(CEGUI::Scrollbar::EventScrollPositionChanged, CEGUI::Event::Subscriber(&Gui_sandbox_manager::HandleSandboxTriangleLength, this));
	scroller = static_cast<CEGUI::Scrollbar*>(winMgr->getWindow("Sandbox_interface/Sandbox/Triangle/Radius/Scroller"));
	scroller->subscribeEvent(CEGUI::Scrollbar::EventScrollPositionChanged, CEGUI::Event::Subscriber(&Gui_sandbox_manager::HandleSandboxTriangleRadius, this));	
	CEGUI::Listbox* cstrList = static_cast<CEGUI::Listbox*>(winMgr->getWindow("Sandbox_interface/Sandbox/Liste_constructions"));
	cstrList->subscribeEvent(CEGUI::Listbox::EventSelectionChanged, CEGUI::Event::Subscriber(&Gui_sandbox_manager::HandleSwitchConstruction, this));
};
/*
=====================================================================================================================================================================================================================================================================================
===================================================================== Définition des handlers ===============================================================================================================================================================
===========================================================================================================================================================================================================================================================================
*/
bool Gui_sandbox_manager::Handlecameravolanteswitch(const CEGUI::EventArgs &e)
{
	cameravolanteswitch = !cameravolanteswitch;
	return true;
};/*
 ============================================ Handlers du Menu File ====================================================
*/
bool Gui_sandbox_manager::HandleLoadConstruction(const CEGUI::EventArgs &e)
{	//Charge le sélecteur de fichiers
	sys->getGUISheet()->addChildWindow(CEGUI::WindowManager::getSingleton().loadWindowLayout("FileSelector.layout"));
	
	// Liste les fichiers présents
	CEGUI::Listbox* FileList = static_cast<CEGUI::Listbox*>(winMgr->getWindow("FileSelector/Filelist"));
	WIN32_FIND_DATA findFileData;
    HANDLE hFind = FindFirstFile(&string("Players Profiles Datas\\"+ProfileMgr.getCurrent()->Name+"\\Constructions\\*.nmh")[0], &findFileData);
	if (hFind != INVALID_HANDLE_VALUE)
	{
		CEGUI::ListboxTextItem* FileItem = NULL;
		do
		{
			FileItem = new CEGUI::ListboxTextItem(string(findFileData.cFileName));
			FileItem->setSelectionBrushImage("TaharezLook", "ListboxSelectionBrush");
			FileList->addItem(FileItem);
		} 
		while(FindNextFile(hFind, &findFileData));
		
		FindClose(hFind);
	}
	else
		ldbg.send("(SandboxLoadFile Exeption) No file founded");
	// Suscribe new UI elements
	CEGUI::FrameWindow* SaveAsWin = static_cast<CEGUI::FrameWindow*>(winMgr->getWindow("FileSelector"));
	SaveAsWin->subscribeEvent(CEGUI::FrameWindow::EventCloseClicked, CEGUI::Event::Subscriber(&Gui_sandbox_manager::HandleLoadConstructionCancel, this));	CEGUI::PushButton* Boutton = static_cast<CEGUI::PushButton*>(winMgr->getWindow("FileSelector/CancelButton"));
	Boutton->subscribeEvent(CEGUI::PushButton::EventClicked, CEGUI::Event::Subscriber(&Gui_sandbox_manager::HandleLoadConstructionCancel, this));
	Boutton = static_cast<CEGUI::PushButton*>(winMgr->getWindow("FileSelector/OkButton"));
	Boutton->subscribeEvent(CEGUI::PushButton::EventClicked, CEGUI::Event::Subscriber(&Gui_sandbox_manager::HandleLoadConstructionOk, this));
	
	return true;
}
bool Gui_sandbox_manager::HandleSaveConstruction(const CEGUI::EventArgs &e)
{	// Sécurité sur le nom de fichier
	if(lastFileNameSaved == "")
	{
		ldbg.send("(SandBoxSaveFile Exeption) Fired Save Construction with blank file name, using a rendom one.");
		lastFileNameSaved = "Untitled" + StringConverter::toString(sys0.timer.getMicroseconds());
	}	// Sauvegarde le construction
	CstrMgr.SaveAs(Constructeur.BuiltCstr[Constructeur.getConstruction_num()],lastFileNameSaved);	return true;
}
bool Gui_sandbox_manager::HandleSaveConstructionAs(const CEGUI::EventArgs &e)
{	sys->getGUISheet()->addChildWindow(CEGUI::WindowManager::getSingleton().loadWindowLayout("SaveAS.layout"));
	winMgr->getWindow("SaveAsFrameWin/EditBox")->setText(Constructeur.BuiltCstr[Constructeur.getConstruction_num()]->name);	// Suscribe new UI elements
	CEGUI::FrameWindow* SaveAsWin = static_cast<CEGUI::FrameWindow*>(winMgr->getWindow("SaveAsFrameWin"));
	SaveAsWin->subscribeEvent(CEGUI::FrameWindow::EventCloseClicked, CEGUI::Event::Subscriber(&Gui_sandbox_manager::HandleSaveConstructionAsCancel, this));	CEGUI::PushButton* Boutton = static_cast<CEGUI::PushButton*>(winMgr->getWindow("SaveAsFrameWin/CancelButton"));
	Boutton->subscribeEvent(CEGUI::PushButton::EventClicked, CEGUI::Event::Subscriber(&Gui_sandbox_manager::HandleSaveConstructionAsCancel, this));
	Boutton = static_cast<CEGUI::PushButton*>(winMgr->getWindow("SaveAsFrameWin/OkButton"));
	Boutton->subscribeEvent(CEGUI::PushButton::EventClicked, CEGUI::Event::Subscriber(&Gui_sandbox_manager::HandleSaveConstructionAsOk, this));
	
	return true;
}
/*
 ============================================ Handlers des curseurs ====================================================
*/
	// ==============  Log cursors :bool Gui_sandbox_manager::HandleSandboxRondinOrientation(const CEGUI::EventArgs &e)
{	
	CEGUI::WindowManager * winMgr = CEGUI::WindowManager::getSingletonPtr();
	CEGUI::Scrollbar* scroller = static_cast<CEGUI::Scrollbar*>(winMgr->getWindow("Sandbox_interface/Sandbox/Log/Orientation/Scroller"));
	Constructeur.orientation_rondin = scroller->getScrollPosition();
	winMgr->getWindow("Sandbox_interface/Sandbox/Log/Orientation/Label")->setText("Orientation : " + StringConverter::toString(Constructeur.orientation_rondin));
	return true;
};bool Gui_sandbox_manager::HandleSandboxRondinLength(const CEGUI::EventArgs &e)
{	
	CEGUI::WindowManager * winMgr = CEGUI::WindowManager::getSingletonPtr();
	CEGUI::Scrollbar* scroller = static_cast<CEGUI::Scrollbar*>(winMgr->getWindow("Sandbox_interface/Sandbox/Log/Length/Scroller"));
	Constructeur.longeur_rondin = scroller->getScrollPosition()+5; // la longueur s'ajuste de 5 a 50m
	winMgr->getWindow("Sandbox_interface/Sandbox/Log/Length/Label")->setText("Length : " + StringConverter::toString(Constructeur.longeur_rondin)+"m");
	return true;
};
bool Gui_sandbox_manager::HandleSandboxRondinRadius(const CEGUI::EventArgs &e)
{	
	CEGUI::WindowManager * winMgr = CEGUI::WindowManager::getSingletonPtr();
	CEGUI::Scrollbar* scroller = static_cast<CEGUI::Scrollbar*>(winMgr->getWindow("Sandbox_interface/Sandbox/Log/Radius/Scroller"));
	Constructeur.diametre_rondin = scroller->getScrollPosition();
	winMgr->getWindow("Sandbox_interface/Sandbox/Log/Radius/Label")->setText("Radius : " + StringConverter::toString(Constructeur.diametre_rondin));
	return true;
};	// ==============  Disk cursors :bool Gui_sandbox_manager::HandleSandboxDiskOrientation(const CEGUI::EventArgs &e)
{	
	CEGUI::WindowManager * winMgr = CEGUI::WindowManager::getSingletonPtr();
	CEGUI::Scrollbar* scroller = static_cast<CEGUI::Scrollbar*>(winMgr->getWindow("Sandbox_interface/Sandbox/Disk/Orientation/Scroller"));
	Constructeur.diskOrientation = scroller->getScrollPosition();
	winMgr->getWindow("Sandbox_interface/Sandbox/Disk/Orientation/Label")->setText("Orientation : " + StringConverter::toString(Constructeur.diskOrientation));
	return true;
};bool Gui_sandbox_manager::HandleSandboxDiskThichness(const CEGUI::EventArgs &e)
{	
	CEGUI::WindowManager * winMgr = CEGUI::WindowManager::getSingletonPtr();
	CEGUI::Scrollbar* scroller = static_cast<CEGUI::Scrollbar*>(winMgr->getWindow("Sandbox_interface/Sandbox/Disk/Thickness/Scroller"));
	Constructeur.diskLength = scroller->getScrollPosition(); 
	winMgr->getWindow("Sandbox_interface/Sandbox/Disk/Thickness/Label")->setText("Thickness : " + StringConverter::toString(Constructeur.diskLength)+"m");
	return true;
};
bool Gui_sandbox_manager::HandleSandboxDiskRadius(const CEGUI::EventArgs &e)
{	
	CEGUI::WindowManager * winMgr = CEGUI::WindowManager::getSingletonPtr();
	CEGUI::Scrollbar* scroller = static_cast<CEGUI::Scrollbar*>(winMgr->getWindow("Sandbox_interface/Sandbox/Disk/Radius/Scroller"));
	Constructeur.diskRadius = scroller->getScrollPosition();
	winMgr->getWindow("Sandbox_interface/Sandbox/Disk/Radius/Label")->setText("Radius : " + StringConverter::toString(Constructeur.diskRadius));
	return true;
};
	// ==============  Triangle cursors :bool Gui_sandbox_manager::HandleSandboxTriangleOrientation(const CEGUI::EventArgs &e)
{	
	CEGUI::WindowManager * winMgr = CEGUI::WindowManager::getSingletonPtr();
	CEGUI::Scrollbar* scroller = static_cast<CEGUI::Scrollbar*>(winMgr->getWindow("Sandbox_interface/Sandbox/Triangle/Orientation/Scroller"));
	Constructeur.triangleOrientation = scroller->getScrollPosition();
	winMgr->getWindow("Sandbox_interface/Sandbox/Triangle/Orientation/Label")->setText("Orientation : " + StringConverter::toString(Constructeur.triangleOrientation));
	return true;
};bool Gui_sandbox_manager::HandleSandboxTriangleDirection(const CEGUI::EventArgs &e)
{	
	CEGUI::WindowManager * winMgr = CEGUI::WindowManager::getSingletonPtr();
	CEGUI::Scrollbar* scroller = static_cast<CEGUI::Scrollbar*>(winMgr->getWindow("Sandbox_interface/Sandbox/Triangle/Direction/Scroller"));
	Constructeur.triangleDirection = scroller->getScrollPosition();
	winMgr->getWindow("Sandbox_interface/Sandbox/Triangle/Direction/Label")->setText("Direction : " + StringConverter::toString(Constructeur.triangleDirection));
	return true;
};bool Gui_sandbox_manager::HandleSandboxTriangleLength(const CEGUI::EventArgs &e)
{	
	CEGUI::WindowManager * winMgr = CEGUI::WindowManager::getSingletonPtr();
	CEGUI::Scrollbar* scroller = static_cast<CEGUI::Scrollbar*>(winMgr->getWindow("Sandbox_interface/Sandbox/Triangle/Length/Scroller"));
	Constructeur.triangleLength = scroller->getScrollPosition()+0.001;
	winMgr->getWindow("Sandbox_interface/Sandbox/Triangle/Length/Label")->setText("Length : " + StringConverter::toString(Constructeur.triangleLength)+"m");
	return true;
};
bool Gui_sandbox_manager::HandleSandboxTriangleRadius(const CEGUI::EventArgs &e)
{	
	CEGUI::WindowManager * winMgr = CEGUI::WindowManager::getSingletonPtr();
	CEGUI::Scrollbar* scroller = static_cast<CEGUI::Scrollbar*>(winMgr->getWindow("Sandbox_interface/Sandbox/Triangle/Radius/Scroller"));
	Constructeur.triangleRadius = scroller->getScrollPosition();
	winMgr->getWindow("Sandbox_interface/Sandbox/Triangle/Radius/Label")->setText("Radius : " + StringConverter::toString(Constructeur.triangleRadius));
	return true;
};/*
 ============================================ Handlers des Outils ====================================================
*/bool Gui_sandbox_manager::HandleSandboxRondin(const CEGUI::EventArgs &e)
{
	if(Constructeur.getConstructionMode() == RONDIN)
		Constructeur.setConstructionMode(NONE);
	else
	{
		if(Constructeur.getConstructionMode()  == NONE)
			if(!Constructeur.BuiltCstr.size())
				Constructeur.NewConstruction();
			else
				if(Constructeur.BuiltCstr[Constructeur.getConstruction_num()]->element.size())// Ne crée pas de nouvelle construction si la précédente est vide
					Constructeur.NewConstruction();
		Constructeur.setConstructionMode(RONDIN);
	}
	return true;
};bool Gui_sandbox_manager::HandleSandboxRocher(const CEGUI::EventArgs &e)
{
	if(Constructeur.getConstructionMode()  == ROCHER)
		Constructeur.setConstructionMode(NONE);
	else
	{
		if(Constructeur.getConstructionMode()  == NONE)
			if(!Constructeur.BuiltCstr.size())
				Constructeur.NewConstruction();
			else
			{
				if(Constructeur.BuiltCstr[Constructeur.getConstruction_num()]->element.size())// Ne crée pas de nouvelle construction si la précédente est vide
					Constructeur.NewConstruction();
				else
					CreateMsgBox(BttnOk,"Current construction empty, will not create a new one");
			}		Constructeur.setConstructionMode(ROCHER);
	}
	return true;
};
bool Gui_sandbox_manager::HandleSandboxDisk(const CEGUI::EventArgs &e)
{
	if(Constructeur.getConstructionMode() == DISK)
		Constructeur.setConstructionMode(NONE);
	else
	{
		if(Constructeur.getConstructionMode()  == NONE)
			if(!Constructeur.BuiltCstr.size())
				Constructeur.NewConstruction();
			else
				if(Constructeur.BuiltCstr[Constructeur.getConstruction_num()]->element.size())// Ne crée pas de nouvelle construction si la précédente est vide
					Constructeur.NewConstruction();
		Constructeur.setConstructionMode(DISK);
	}
	return true;
};
bool Gui_sandbox_manager::HandleSandboxTriangle(const CEGUI::EventArgs &e)
{
	if(Constructeur.getConstructionMode() == TRIANGLE)
		Constructeur.setConstructionMode(NONE);
	else
	{
		if(Constructeur.getConstructionMode()  == NONE)
			if(!Constructeur.BuiltCstr.size())
				Constructeur.NewConstruction();
			else
				if(Constructeur.BuiltCstr[Constructeur.getConstruction_num()]->element.size())// Ne crée pas de nouvelle construction si la précédente est vide
					Constructeur.NewConstruction();
		Constructeur.setConstructionMode(TRIANGLE);
	}
	return true;
};bool Gui_sandbox_manager::HandleSwitchConstruction(const CEGUI::EventArgs &e)
{
	CEGUI::Listbox* Cstrlist = static_cast<CEGUI::Listbox*>(winMgr->getWindow("Sandbox_interface/Sandbox/Liste_constructions"));	if(Cstrlist->getFirstSelectedItem() != NULL) // S'il y a bien une construction sélectionnée
	{
		string requestedCstr = Cstrlist->getFirstSelectedItem()->getText().c_str();
		for (Ogre::uint i = 0; i<Constructeur.BuiltCstr.size(); ++i)
			if(Constructeur.BuiltCstr[i]->name == requestedCstr)
				Constructeur.setConstruction_num(i);
	}
	else
	{
	//	ldbg.send("(SandBox HandleSwitchConstruction Exeption) Unable to swich construction : no construction selected ! Swiching to last made one.");
//		Constructeur.setConstruction_num(Construction.size()-1);
		Constructeur.setConstruction_num(Constructeur.getConstruction_num());
	}	return true;
};bool Gui_sandbox_manager::HandleDelObj(const CEGUI::EventArgs &e)
{
	if(Constructeur.getConstructionMode()  != DELOBJ)
		Constructeur.setConstructionMode(DELOBJ);
	else
		Constructeur.setConstructionMode(NONE);	return true;
};
bool Gui_sandbox_manager::HandleNewLnk(const CEGUI::EventArgs &e)
{
	if(!GuiSandboxMan.winMgr->isWindowPresent("SanboxLinkCreator"))
	{
		//Charge le sélecteur de fichiers
		sys->getGUISheet()->addChildWindow(CEGUI::WindowManager::getSingleton().loadWindowLayout("SandboxLnkCreator.layout"));
		if(Constructeur.BuiltCstr.size() && Constructeur.BuiltCstr[Constructeur.getConstruction_num()]->element.size())
		{
			// Remplit la première liste d'objets
			CEGUI::Listbox* ObjLst = static_cast<CEGUI::Listbox*>(winMgr->getWindow("SanboxLinkCreator/FirstObjLst"));
			CEGUI::ListboxTextItem* FileItem = NULL;
			for (	std::vector<Critter::Body*>::iterator itt = Constructeur.BuiltCstr[Constructeur.getConstruction_num()]->element.begin();
					itt != Constructeur.BuiltCstr[Constructeur.getConstruction_num()]->element.end();
					++itt)
			{
					FileItem = new CEGUI::ListboxTextItem((*itt)->getName());
					FileItem->setSelectionBrushImage("TaharezLook", "ListboxSelectionBrush");
					ObjLst->addItem(FileItem);
			}			// Remplit la seconde liste d'objets
			ObjLst = static_cast<CEGUI::Listbox*>(winMgr->getWindow("SanboxLinkCreator/SecondObjLst"));
			FileItem = NULL;
			for (	std::vector<Critter::Body*>::iterator itt = Constructeur.BuiltCstr[Constructeur.getConstruction_num()]->element.begin();
					itt != Constructeur.BuiltCstr[Constructeur.getConstruction_num()]->element.end();
					++itt)
			{
					FileItem = new CEGUI::ListboxTextItem((*itt)->getName());
					FileItem->setSelectionBrushImage("TaharezLook", "ListboxSelectionBrush");
					ObjLst->addItem(FileItem);
			}		}		// Suscribe new UI elements
		CEGUI::FrameWindow* SaveAsWin = static_cast<CEGUI::FrameWindow*>(winMgr->getWindow("SanboxLinkCreator"));
		SaveAsWin->subscribeEvent(CEGUI::FrameWindow::EventCloseClicked, CEGUI::Event::Subscriber(&Gui_sandbox_manager::HandleNewLnkCancel, this));		CEGUI::PushButton* Boutton = static_cast<CEGUI::PushButton*>(winMgr->getWindow("SanboxLinkCreator/CancelBttn"));
		Boutton->subscribeEvent(CEGUI::PushButton::EventClicked, CEGUI::Event::Subscriber(&Gui_sandbox_manager::HandleNewLnkCancel, this));
		Boutton = static_cast<CEGUI::PushButton*>(winMgr->getWindow("SanboxLinkCreator/OkBttn"));
		Boutton->subscribeEvent(CEGUI::PushButton::EventClicked, CEGUI::Event::Subscriber(&Gui_sandbox_manager::HandleNewLnkOk, this));
		Boutton = static_cast<CEGUI::PushButton*>(winMgr->getWindow("SanboxLinkCreator/PickFrstObjBttn"));
		Boutton->subscribeEvent(CEGUI::PushButton::EventClicked, CEGUI::Event::Subscriber(&Gui_sandbox_manager::HandleNewLnkPickFrstObjBttn, this));
		Boutton = static_cast<CEGUI::PushButton*>(winMgr->getWindow("SanboxLinkCreator/PickSecondObjBttn"));
		Boutton->subscribeEvent(CEGUI::PushButton::EventClicked, CEGUI::Event::Subscriber(&Gui_sandbox_manager::HandleNewLnkPickSecondObjBttn, this));
	}
	else
		CreateMsgBox(BttnOk,"Link creator is already open");	return true;
};bool Gui_sandbox_manager::HandleDelLnk(const CEGUI::EventArgs &e)
{
	CEGUI::Listbox* LnkLst = static_cast<CEGUI::Listbox*>(GuiSandboxMan.winMgr->getWindow("Sandbox_interface/Sandbox/Liste_liaisons"));
	string lnkName = "";
	if(LnkLst->getFirstSelectedItem() != NULL) // S'il y a bien un 1er obj sélectionnée
		lnkName = LnkLst->getFirstSelectedItem()->getText().c_str();
	else
	{
		ldbg.send("(SandBoxHandleDelLnk Exeption) Unable to delete link : no one selected");
		CreateMsgBox(BttnOk,"You must select a link before deleting it.");
		return true;
	}	for (Ogre::uint i = 0; i<Constructeur.BuiltCstr[Constructeur.getConstruction_num()]->joint.size(); ++i)
		if(Constructeur.BuiltCstr[Constructeur.getConstruction_num()]->joint[i].name == lnkName)
		{
			Constructeur.BuiltCstr[Constructeur.getConstruction_num()]->DestroyJoint(Constructeur.BuiltCstr[Constructeur.getConstruction_num()]->joint[i].joint); // Don't seems to work. Can't explain why...
			Constructeur.refreshLinkLst();
		} 
		return true;
};
#include "Namuh_Main_H.h"
using namespace Ogre;bool Gui_sandbox_manager::HandleSaveConstructionAsOk(const CEGUI::EventArgs&)
{
	// Sécurité sur le nom de fichier
	string Filename =  winMgr->getWindow("SaveAsFrameWin/EditBox")->getText().c_str();
	if(Filename == "")
		Filename = "Untitled" + StringConverter::toString(sys0.timer.getMicroseconds());	// SAvegarde le construction
	CstrMgr.SaveAs(Constructeur.BuiltCstr[Constructeur.getConstruction_num()],Filename);	// Ferme la fenètre
	sys->getGUISheet()->removeChildWindow("SaveAsFrameWin");
	winMgr->getWindow("SaveAsFrameWin")->destroy();	lastFileNameSaved = Filename;
	winMgr->getWindow("Sandbox_interface/Menubar/FileButton/FileMenu/Save")->enable();
	return true;
}bool Gui_sandbox_manager::HandleSaveConstructionAsCancel(const CEGUI::EventArgs&)
{
	// Ferme la fenètre
	sys->getGUISheet()->removeChildWindow("SaveAsFrameWin");
	winMgr->getWindow("SaveAsFrameWin")->destroy();
	return true;
}#include "Namuh_Main_H.h"using namespace Ogre;class HDRListener: public Ogre::CompositorInstance::Listener
{
protected:
	int mVpWidth, mVpHeight;
	int mBloomSize;
	// Array params - have to pack in groups of 4 since this is how Cg generates them
	// also prevents dependent texture read problems if ops don't require swizzle
	float mBloomTexWeights[15][4];
	float mBloomTexOffsetsHorz[15][4];
	float mBloomTexOffsetsVert[15][4];
public:
	HDRListener();
	virtual ~HDRListener();
	void notifyViewportSize(int width, int height);
	void notifyCompositor(Ogre::CompositorInstance* instance);
	virtual void notifyMaterialSetup(Ogre::uint32 pass_id, Ogre::MaterialPtr &mat);
	virtual void notifyMaterialRender(Ogre::uint32 pass_id, Ogre::MaterialPtr &mat);
};Ogre::CompositorInstance::Listener* HDRLogic::createListener(Ogre::CompositorInstance* instance)
{
	HDRListener* listener = new HDRListener;
	Ogre::Viewport* vp = instance->getChain()->getViewport();
	listener->notifyViewportSize(vp->getActualWidth(), vp->getActualHeight());
	listener->notifyCompositor(instance);
	return listener;
}/*************************************************************************
HDRListener Methods
*************************************************************************/
//---------------------------------------------------------------------------
HDRListener::HDRListener()
{
}
//---------------------------------------------------------------------------
HDRListener::~HDRListener()
{
}
//---------------------------------------------------------------------------
void HDRListener::notifyViewportSize(int width, int height)
{
	mVpWidth = width;
	mVpHeight = height;
}
//---------------------------------------------------------------------------
void HDRListener::notifyCompositor(Ogre::CompositorInstance* instance)
{
	// Get some RTT dimensions for later calculations
	Ogre::CompositionTechnique::TextureDefinitionIterator defIter =
		instance->getTechnique()->getTextureDefinitionIterator();
	while (defIter.hasMoreElements())
	{
		Ogre::CompositionTechnique::TextureDefinition* def =
			defIter.getNext();
		if(def->name == "rt_bloom0")
		{
			mBloomSize = (int)def->width; // should be square
			// Calculate gaussian texture offsets & weights
			float deviation = 3.0f;
			float texelSize = 1.0f / (float)mBloomSize;			// central sample, no offset
			mBloomTexOffsetsHorz[0][0] = 0.0f;
			mBloomTexOffsetsHorz[0][1] = 0.0f;
			mBloomTexOffsetsVert[0][0] = 0.0f;
			mBloomTexOffsetsVert[0][1] = 0.0f;
			mBloomTexWeights[0][0] = mBloomTexWeights[0][1] =
				mBloomTexWeights[0][2] = Ogre::Math::gaussianDistribution(0, 0, deviation);
			mBloomTexWeights[0][3] = 1.0f;			// 'pre' samples
			for(int i = 1; i < 8; ++i)
			{
				mBloomTexWeights[i][0] = mBloomTexWeights[i][1] =
					mBloomTexWeights[i][2] = 1.15f * Ogre::Math::gaussianDistribution(i, 0, deviation);
				mBloomTexWeights[i][3] = 1.0f;
				mBloomTexOffsetsHorz[i][0] = i * texelSize;
				mBloomTexOffsetsHorz[i][1] = 0.0f;
				mBloomTexOffsetsVert[i][0] = 0.0f;
				mBloomTexOffsetsVert[i][1] = i * texelSize;
			}
			// 'post' samples
			for(int i = 8; i < 15; ++i)
			{
				mBloomTexWeights[i][0] = mBloomTexWeights[i][1] =
					mBloomTexWeights[i][2] = mBloomTexWeights[i - 7][0];
				mBloomTexWeights[i][3] = 1.0f;				mBloomTexOffsetsHorz[i][0] = -mBloomTexOffsetsHorz[i - 7][0];
				mBloomTexOffsetsHorz[i][1] = 0.0f;
				mBloomTexOffsetsVert[i][0] = 0.0f;
				mBloomTexOffsetsVert[i][1] = -mBloomTexOffsetsVert[i - 7][1];
			}		}
	}
}
//---------------------------------------------------------------------------
void HDRListener::notifyMaterialSetup(Ogre::uint32 pass_id, Ogre::MaterialPtr &mat)
{
	// Prepare the fragment params offsets
	switch(pass_id)
	{
	//case 994: // rt_lum4
	case 993: // rt_lum3
	case 992: // rt_lum2
	case 991: // rt_lum1
	case 990: // rt_lum0
		break;
	case 800: // rt_brightpass
		break;
	case 701: // rt_bloom1
		{
			// horizontal bloom
			mat->load();
			Ogre::GpuProgramParametersSharedPtr fparams =
				mat->getBestTechnique()->getPass(0)->getFragmentProgramParameters();
			fparams->setNamedConstant("sampleOffsets", mBloomTexOffsetsHorz[0], 15);
			fparams->setNamedConstant("sampleWeights", mBloomTexWeights[0], 15);			break;
		}
	case 700: // rt_bloom0
		{
			// vertical bloom
			mat->load();
			Ogre::GpuProgramParametersSharedPtr fparams =
				mat->getTechnique(0)->getPass(0)->getFragmentProgramParameters();
			fparams->setNamedConstant("sampleOffsets", mBloomTexOffsetsVert[0], 15);
			fparams->setNamedConstant("sampleWeights", mBloomTexWeights[0], 15);			break;
		}
	}
}
//---------------------------------------------------------------------------
void HDRListener::notifyMaterialRender(Ogre::uint32 pass_id, Ogre::MaterialPtr &mat)
{
}
//---------------------------------------------------------------------------
#include "Namuh_Main_H.h"using namespace Ogre;
Hydrax_mgr Hydrax_man;
// Code des méthodes de la classe
Hydrax_mgr::Hydrax_mgr(void)
{
	first_ini = true;
	initialised = false;
}
Hydrax_mgr::~Hydrax_mgr(void)
{
	delete mHydrax; 
}void Hydrax_mgr::initialise(void)
{
	sea_level= FloatFromName(Map.MapDataPool,"World_Water_Height");
	if(first_ini)mHydrax = new Hydrax::Hydrax(sys0.mgr,sys0.cam,sys0.vp);
	mModule = new Hydrax::Module::ProjectedGrid(mHydrax,new Hydrax::Noise::Perlin(),Ogre::Plane(Ogre::Vector3(0,1,0), Ogre::Vector3(0,0,0)),Hydrax::MaterialManager::NM_VERTEX,Hydrax::Module::ProjectedGrid::Options());
	mHydrax->setModule(static_cast<Hydrax::Module::Module*>(mModule));
	mHydrax->loadCfg("Namuh.hdx");
	mHydrax->create();
	mHydrax->setUnderwaterCameraSwitchDelta(0.01f);	mHydrax->getMaterialManager()->addDepthTechnique(static_cast<Ogre::MaterialPtr>(Ogre::MaterialManager::getSingleton().getByName("base_material"))->createTechnique());
	mHydrax->getMaterialManager()->addDepthTechnique(static_cast<Ogre::MaterialPtr>(Ogre::MaterialManager::getSingleton().getByName("lambert2SGaa"))->createTechnique());
	mHydrax->getMaterialManager()->addDepthTechnique(static_cast<Ogre::MaterialPtr>(Ogre::MaterialManager::getSingleton().getByName("material16"))->createTechnique());
	mHydrax->getMaterialManager()->addDepthTechnique(static_cast<Ogre::MaterialPtr>(Ogre::MaterialManager::getSingleton().getByName("Falaise_long"))->createTechnique());
	mHydrax->getMaterialManager()->addDepthTechnique(static_cast<Ogre::MaterialPtr>(Ogre::MaterialManager::getSingleton().getByName("grass"))->createTechnique());
	mHydrax->getMaterialManager()->addDepthTechnique(static_cast<Ogre::MaterialPtr>(Ogre::MaterialManager::getSingleton().getByName("Falaise_vert"))->createTechnique());
	mHydrax->getMaterialManager()->addDepthTechnique(static_cast<Ogre::MaterialPtr>(Ogre::MaterialManager::getSingleton().getByName("particles_generic"))->createTechnique());
	mHydrax->getMaterialManager()->addDepthTechnique(static_cast<Ogre::MaterialPtr>(Ogre::MaterialManager::getSingleton().getByName("FresnelReflectionRefraction"))->createTechnique());
	mHydrax->getMaterialManager()->addDepthTechnique(static_cast<Ogre::MaterialPtr>(Map.terrain->getMaterial())->createTechnique());
	mHydrax->setPosition(Vector3(sys0.cam->getPosition().x,//ici point de parent node
								 -2,
								sys0.cam->getPosition().z));
	
	initialised = true;
	first_ini = false; // a garder a la fin
}void Hydrax_mgr::update(float ellapsed_time)
{/*
	mHydrax->setWaterColor(Atm_man.mWaterGradient.getColor(((Atm_man.lightDir.y + 1.0f) / 2.0f)));
	mHydrax->setSunPosition(Atm_man.sunPos);
	mHydrax->setSunColor(Atm_man.sunCol);*/
	mHydrax->setPosition(Vector3(sys0.cam->getParentNode()->convertLocalToWorldPosition(sys0.cam->getPosition()).x,
								sea_level,//+2*sin(-3.14*Atm_man.mControler.getTime().x/12)
								sys0.cam->getParentNode()->convertLocalToWorldPosition(sys0.cam->getPosition()).z));
	mHydrax->update(ellapsed_time);
		
}void Hydrax_mgr::destroy(void)
{
	initialised = false;
	mHydrax->remove();
	mModule->remove();
	//delete mModule;
}
// Fast itoa from http://www.jb.man.ac.uk/~slowe/cpp/itoa.html for Linux since it seems like Linux doesn't support this function.
// I modified it to remove the std dependencies.
char* Itoa( int value, char* result, int base )
 {
	// check that the base if valid
	if (base < 2 || base > 16) { *result = 0; return result; }
	char* out = result;
	int quotient = value;	int absQModB;	do {
		// KevinJ - get rid of this dependency
		//*out = "0123456789abcdef"[ std::abs( quotient % base ) ];
		absQModB=quotient % base;
		if (absQModB < 0)
			absQModB=-absQModB;
		*out = "0123456789abcdef"[ absQModB ];
		++out;
		quotient /= base;
	} while ( quotient );	// Only apply negative sign for base 10
	if ( value < 0 && base == 10) *out++ = '-';	// KevinJ - get rid of this dependency
	// std::reverse( result, out );
	*out = 0;	// KevinJ - My own reverse code
    char *start = result;
	char temp;
	out--;
	while (start < out)
	{
		temp=*start;
		*start=*out;
		*out=temp;
		start++;
		out--;
	}	return result;
}#include "Namuh_Main_H.h"using namespace Ogre;
// Code des méthodes de la classe
Javelot::Javelot(void)
{
}
Javelot::~Javelot(void)
{
}
void Javelot::initialise(RakNet::RakNetGUID Requested_Owner_id) // Tir !!
{
	NextProjectileID =0;
	Cooldown = 1200; //0.8 Javelot/sec, (ptet un peu bcp)	JavelotDescription.mMass = 5.0f;
	JavelotDescription.mLinearDamping = 0.007f;  
	JavelotDescription.mAngularDamping = 0.001f;
	//JavelotDescription.mDynamicRigidbodyFlags += NxOgre::DynamicRigidbodyFlags::DisableGravity;	Owner = PlayerList[Requested_Owner_id];	WeaponMesh = sys0.mgr->createEntity("Javelot" + StringConverter::toString(sys0.timer.getMilliseconds()),"Javelot.mesh"); // Attention, risque de problème de nommage d'entité lors de plusieurs lance pierre (SAuf que 1 seul par joueur, m'enfin...)
	WeaponNode = Owner->CamNode->createChildSceneNode();
		WeaponNode->attachObject(WeaponMesh);
		WeaponNode->setPosition(0.2f,-0.30f,-0.5f);
}void Javelot::fire(void) // Tir !!
{	if(LastfiredTimer+Cooldown < sys0.timer.getMilliseconds())
	{
		ldbg.send("Lancé de javelot");
		Ogre::Radian	angle_horizontal = Owner->Node->getOrientation().getYaw(),
						angle_vertical = Owner->rot.getPitch();
		NxOgre::Vec3 projectilepos = NxOgre::Vec3(	Owner->pos.x-Ogre::Math::Sin(angle_horizontal)*1.4,
													Owner->pos.y+0.5, 
													Owner->pos.z-Ogre::Math::Cos(angle_horizontal)*1.4);
		
		Critter::BodyDescription currentJavelotDescription = JavelotDescription; // New node for the projectile
		Projectile CurrentProjectile(Owner);
		CurrentProjectile.body = PhysX_man.mRenderSystem->createBody(NxOgre::BoxDescription(0.1f,0.1f,1.0f),NxOgre::Vec3(Owner->pos.x,Owner->pos.y,Owner->pos.z), "Javelot_projectile.mesh",currentJavelotDescription);
		CurrentProjectile.body->setGlobalPosition(projectilepos);
		CurrentProjectile.body->setGlobalOrientationQuat(NxOgre::Quat(WeaponNode->convertLocalToWorldOrientation(WeaponNode->getOrientation()))); //caméra, bofbof
		CurrentProjectile.body->addLocalForce(NxOgre::Vec3(0,0,-40.0*currentJavelotDescription.mMass), NxOgre::Enums::ForceMode_SmoothImpulse);
		CurrentProjectile.body->setCCDMotionThreshold(0);
		CurrentProjectile.Date_Fired = sys0.timer.getMilliseconds();
		CurrentProjectile.CanDamage = true;
		ProjectileList.push_back(CurrentProjectile);		for (	std::map<RakNet::RakNetGUID, Perso*>::iterator PlayerIterator = PlayerList.begin();
			PlayerIterator != PlayerList.end();
			PlayerIterator++)
		{
			if(PlayerIterator->second->id != Owner->id)
			{
				
				ProjCallback myCallback;
				myCallback.ProjectileID = ProjectileList.size()-1;
				myCallback.AgressorID = Owner->id;
				myCallback.TargetID = PlayerIterator->second->id ;
				myCallback.type = Javelot_;
				ProjCallbackList.push_back(myCallback);
				CurrentProjectile.body->setContactCallback(&ProjCallbackList.back());				PlayerIterator->second->CharCtrl->setContactCallback(&ProjCallbackList.back());
				PhysX_man.mScene->setActorFlags(ProjectileList.back().body,PlayerIterator->second->CharCtrl, NxOgre::Enums::ContactPairFlags_All);
			}
		}
		NextProjectileID++;
		LastfiredTimer = sys0.timer.getMilliseconds();
	}
}
#include "Namuh_Main_H.h"using namespace Ogre;
// Code des méthodes de la classe
Lance_Pierre::Lance_Pierre(void)
{
}
Lance_Pierre::~Lance_Pierre(void)
{
}
void Lance_Pierre::initialise(RakNet::RakNetGUID Requested_Owner_id) // Tir !!
{
	NextProjectileID =0;
	Cooldown = 909; // 1.1 pierre/seconde (Like UT3 Rocket Launcher)
	// For Further details about UT3 Rocket Lancher, see http://liandri.beyondunreal.com/Rocket_Launcher	PierreDescription.mMass = 200.6f;
	PierreDescription.mLinearDamping = 0.002f;  
	PierreDescription.mAngularDamping = 0.001f;
	PierreDescription.mDynamicRigidbodyFlags += NxOgre::DynamicRigidbodyFlags::DisableGravity;	Owner = PlayerList[Requested_Owner_id];	WeaponMesh = sys0.mgr->createEntity("Lance Pierre" + StringConverter::toString(sys0.timer.getMilliseconds()),"Lance Pierre.mesh"); // Attention, risque de problème de nommage d'entité lors de plusieurs lance pierre (SAuf que 1 seul par jouer, m'enfin...)
	WeaponNode = Owner->CamNode->createChildSceneNode();
		WeaponNode->attachObject(WeaponMesh);
		WeaponNode->setPosition(0.2,-0.30,-0.5);
}void Lance_Pierre::fire(void) // Tir !!
{
	if(LastfiredTimer+Cooldown < sys0.timer.getMilliseconds())
	{
		ldbg.send("Tir au lance pierre");
		Ogre::Radian	angle_horizontal = Owner->Node->getOrientation().getYaw(),
						angle_vertical = Owner->rot.getPitch();
		NxOgre::Vec3 projectilepos = NxOgre::Vec3(	Owner->pos.x-Ogre::Math::Sin(angle_horizontal)*.7,
													Owner->pos.y-0.2, 
													Owner->pos.z-Ogre::Math::Cos(angle_horizontal)*.7);
		
		Critter::BodyDescription currentPierreDescription = PierreDescription; // New node for the projectile
		Projectile CurrentProjectile(Owner);
		CurrentProjectile.body = PhysX_man.mRenderSystem->createBody(NxOgre::BoxDescription(0.2f,0.2f,0.7f),NxOgre::Vec3(Owner->pos.x,Owner->pos.y,Owner->pos.z), "Pierre du Lance Pierre.mesh",currentPierreDescription);
		CurrentProjectile.body->setGlobalPosition(projectilepos);
		CurrentProjectile.body->setGlobalOrientationQuat(NxOgre::Quat(WeaponNode->convertLocalToWorldOrientation(WeaponNode->getOrientation()))); //caméra, bofbof
		CurrentProjectile.body->addLocalForce(NxOgre::Vec3(0,0,-60.0*currentPierreDescription.mMass), NxOgre::Enums::ForceMode_SmoothImpulse);
		CurrentProjectile.body->setCCDMotionThreshold(0);
		CurrentProjectile.Date_Fired = sys0.timer.getMilliseconds();
		CurrentProjectile.CanDamage = true;
		ProjectileList.push_back(CurrentProjectile);		for (	std::map<RakNet::RakNetGUID, Perso*>::iterator PlayerIterator = PlayerList.begin();
			PlayerIterator != PlayerList.end();
			PlayerIterator++)
		{
			if(PlayerIterator->second->id != Owner->id)
			{
				
				ProjCallback myCallback;
				myCallback.ProjectileID = ProjectileList.size()-1;
				myCallback.AgressorID = Owner->id;
				myCallback.TargetID = PlayerIterator->second->id ;
				myCallback.type = LancePierre;
				ProjCallbackList.push_back(myCallback);
				CurrentProjectile.body->setContactCallback(&ProjCallbackList.back());				PlayerIterator->second->CharCtrl->setContactCallback(&ProjCallbackList.back());
				PhysX_man.mScene->setActorFlags(ProjectileList.back().body,PlayerIterator->second->CharCtrl, NxOgre::Enums::ContactPairFlags_All);
			}
		}
		NextProjectileID++;
		LastfiredTimer = sys0.timer.getMilliseconds();
	}
}
#include "Namuh_Main_H.h"using namespace Ogre;
LiveDebugger ldbg;
// Code des méthodes de la classe
LiveDebugger::LiveDebugger(void)
{
	initialised = false;
	overlay = NULL;
}
LiveDebugger::~LiveDebugger(void)
{
}void LiveDebugger::enable()
{
	overlay =  Ogre::OverlayManager::getSingleton().create( "GraphOverlay" );
	overlay->show();	if(GuiSandboxMan.winMgr->isWindowPresent("Live_debugger") && !initialised)
	{
		window = GuiSandboxMan.winMgr->getWindow("Live_debugger");
		window->setText("======= Live Debugger Initialised =======\n");
		sys1.logmsg("[Live Debugger] : Initialisation completed");
		initialised = true;
	}
	else
	{
		if(initialised)sys1.logmsg("(Live Debugger Exeption) while enabling : Debugger already enabled");
		else sys1.logmsg("(Live Debugger Exeption) while enabling : No window named 'Sandbox_interface/Live_debugger' can be found");
	}
}void LiveDebugger::send(string msg, bool immediaterender)
{
	if(initialised)
	{
		if(raknet_man.initialised)
		{
			RakNet::BitStream bsOut;
			bsOut.Write((RakNet::MessageID)ID_REMOTE_DEBUG_MESSAGE);
			bsOut.Write(RakNet::RakString(&msg[0]));
			//raknet_man.peer->Send(&bsOut,HIGH_PRIORITY,RELIABLE_ORDERED,0,RakNet::UNASSIGNED_SYSTEM_ADDRESS,true);
		}
		if(window->getText().size() > 12000) // protection contre la divergence de la taille du log
			window->setText("");
		window->setText(window->getText()+msg+"\n");
		window->setProperty("VertScrollPosition", window->getProperty("VertExtent"));
		if(immediaterender)GuiSandboxMan.sys->renderGUI(); // met a jour l'écran, des fois que...
		if(immediaterender)sys0.mRoot->renderOneFrame();
		sys1.logmsg("(Live Debugger Trace) : "+msg);
	}
	else
	{
		sys1.logmsg("(Live Debugger Exeption) Unable to send message '"+msg+"' : Debugger not enbled ");
	}
}void LiveDebugger::disable()
{
	if(initialised)
	{
		if(GuiSandboxMan.winMgr->isWindowPresent("Live_debugger"))
		{
			window = GuiSandboxMan.winMgr->getWindow("Live_debugger");
			window->setText("Live Debugger disabled\n");
		}
		sys1.logmsg("(Live Debugger) : Disabled");
		initialised = false;
	}
	else
		sys1.logmsg("(Live Debugger Exeption) Unable to disable : Debugger not initialised ");
}void LiveDebugger::graph(string Name, string YFlowName)
{
	Graphs[Name].YFlowConnexions[YFlowName] = YFlowName;
	Graphs[Name].ConnectTimeToXAxis("Time");	Graphs[Name].XDatas["Time"].AutoKeepAllInRange = false;
	Graphs[Name].XDatas["Time"].AutoFollowLastValue = true;
	Graphs[Name].XDatas["Time"].AutoFollowRange = 60; // 1min/graph	Graphs[Name].YDatas[YFlowName].AutoFollowLastValue = false;
	Graphs[Name].YDatas[YFlowName].AutoCenterLastValue = false;
	Graphs[Name].YDatas[YFlowName].DataColour = Ogre::ColourValue(	Ogre::Math::RangeRandom(0.5,1.0),
																	Ogre::Math::RangeRandom(0.5,1.0),
																	Ogre::Math::RangeRandom(0.5,1.0),
																	1.0);
	
	Graphs[Name].posY = 0.025f + (Graphs[Name].sizeY +0.005f) * (Graphs.size()-1);
}void LiveDebugger::UpdateGrantedGraphes()
{
	for (	std::map<std::string, LdbgGraph>::iterator GraphIterator = Graphs.begin();
			GraphIterator != Graphs.end();
			GraphIterator++)
		if(GraphIterator->second.automatic_update)
			GraphIterator->second.Update();
}#include "Namuh_Main_H.h"using namespace Ogre;void Gui_MainMenu_manager::SetupBackground(void)
{
	if(!IsBackGroundInitialised)
	{
		Perso::cam_sync = raknet_man.peer->GetGuidFromSystemAddress(RakNet::UNASSIGNED_SYSTEM_ADDRESS); // On met la camera dans le joueur local		Map.load("Maps/Main Menu background/Main Menu background.map");
		//Map.load("Maps/Caribean Lost Island/Caribean Lost Island.map");
		ldbg.send("Terrain loaded sucessfully");	//	Hydrax_man.initialise();
		Atm_man.initialise();
		ldbg.send("Atmophere manager loaded sucessfully");		PhysX_man.initialise();
		ldbg.send("PhysX loaded sucessfully");		Map.terrain->dirtyLightmap(); //a faire au moins une fois quand meme
		if(sys0.RefractionRenderTarget)
			sys0.RefractionRenderTarget->update(); // Pareil
		Map.terrain->update();		local_player.initialise();
		local_player.spawn(Vector3FromName(Map.MapDataPool,"Spawn_Position"),true);
		local_player.update(1/60,Mvt_Fly,false);
		local_player.OrientationInput =  Ogre::Vector3(	150,//				-local_player.Node->getOrientation().getYaw().valueDegrees(),
														-10				-local_player.rot.getPitch().valueDegrees(),0);
			
		ldbg.send("loading Paged geometry ");
		Paged_man.initialise();
		ldbg.send("Paged geometry loaded sucessfully");
	/*
		//TODO : Amnesic_Faune_man and Faune_man destroyer not implemented
		ldbg.send("Loading Amnesic Faune "); 
		Amnesic_Faune_man.initialise(); 
		ldbg.send("Amnesic Faune Loaded sucessfully");		ldbg.send("Loading Faune "); 
		Faune_man.initialise();
		ldbg.send("Faune Loaded sucessfully");
	*/
		ldbg.send("Loading static geometry"); 
		Entity* Grotte = sys0.mgr->createEntity("Grotte","Grotte.mesh");
		SceneNode* Grotte_n = sys0.mgr->getRootSceneNode()->createChildSceneNode();
		Grotte_n->attachObject(Grotte);
		Grotte_n->setPosition(100,45,100);
		CstrMgr.Load("Estrade Menu principal.nmh",Ogre::Vector3(115,45,115),Ogre::Quaternion(Ogre::Radian(0),Ogre::Vector3::UNIT_Y));		
		IsBackGroundInitialised = true;
	}
}
void Gui_MainMenu_manager::UpdateBackground(void)
{
	if(IsBackGroundInitialised)
	{
		float inv_FPS = 1/60;	// Otherwise PhysX freeze Oo   (yup, because inv_FPS should be passed from the main loop, otherwise inv_FPS = 0)
		PhysX_man.update(inv_FPS);
		local_player.update(inv_FPS,Mvt_Fly,false);
			
		//Faune_man.update(inv_FPS,local_player.pos);
		//Amnesic_Faune_man.update(inv_FPS,Ogre::Vector2(local_player.pos.x,local_player.pos.z)); 
		Atm_man.update(inv_FPS);
	//	Hydrax_man.update(inv_FPS);
		Map.terrain->update();
		Paged_man.update();
	}
}
void Gui_MainMenu_manager::DestroyBackground(void)
{
	if(IsBackGroundInitialised)
	{
		ldbg.send("Destroying Ruler");
		Ruler.destroy();
		ldbg.send("Destroying Partie");
	sys1.logmsg("*** Debug flag reached (n°1) ***");
	//	Hydrax_man.destroy();
	sys1.logmsg("*** Debug flag reached (n°2) ***");
		Atm_man.destroy();
	sys1.logmsg("*** Debug flag reached (n°3) ***");
		PhysX_man.destroy();
	sys1.logmsg("*** Debug flag reached (n°4) ***");
		local_player.destroy();
	sys1.logmsg("*** Debug flag reached (n°5) ***");
		//Paged_man.destroy();
	sys1.logmsg("*** Debug flag reached (n°6) ***");
		Map.unload();
		ldbg.send("Partie Destroyed");
		sys0.mgr->destroyEntity("Grotte");
		ldbg.disable();		IsBackGroundInitialised = false;
	}
}/**=====================================================================================
*.*.*.*.*.*.*.*.*.*.*.*.*.*.*.*.*.*.*.*.*.*.*.*.*.*.*.*.*.*.*.*.*.*.*.*.*.*.*.*.*.*.*.*
---------------------------- Namuh Test main Source File -------- v alpha1 ------------
*.*.*.*.*.*.*.*.*.*.*.*.*.*.*.*.*.*.*.*.*.*.*.*.*.*.*.*.*.*.*.*.*.*.*.*.*.*.*.*.*.*.*.*
========================================================================================ldbg.send("File "+ string(__FILE__) +" passed line n°"+ StringConverter::toString(__LINE__)); // Debug =================================**/
#include "Namuh_Main_H.h"INT WINAPI WinMain(HINSTANCE hInst, HINSTANCE, LPSTR strCmdLine, INT)
{
	 try 
	 {		
		while(true)
		{
			MainMenuUpdaterOutput MenuOut;
			MenuOut.LancerPartie = false;
			{
				Gui_MainMenu_manager GuiMainMenuMan;
				GuiMainMenuMan.Initialise();
				sys1.logmsg("*** Main Menu Loop reached ***");
				while(!MenuOut.LancerPartie)
				{  
					MenuOut = GuiMainMenuMan.UpdateMainMenu();
					if(sys1.MustQuit == 1){sys1.logmsg("*** (sys1) MustQuit signal recived, shutting down ***"); return false;};
				}
				GuiMainMenuMan.ConstructLoadingScreen();
				sys1.update(1/60);
				GuiMainMenuMan.Update(1);
			}			sys1.escQuit = true;
			{
				Partie Namuh(MenuOut.Param);
				sys1.logmsg("*** Main Game loop reached ***");
				while(!sys1.MustQuit)
					Namuh.update();			}
			sys1.resetMustQuit();
		}
	}
	catch(Ogre::Exception& e){MessageBox(NULL, e.getFullDescription().c_str(), "An exception has occurred!",MB_OK | MB_ICONERROR | MB_TASKMODAL);}
	return 0;
}#include "Namuh_Main_H.h"using namespace Ogre;
Map_loader Map;void loadTerrainGeometry(const Ogre::String&, float* , Ogre::uint16, Ogre::Real, Ogre::Real , Ogre::Real , const Ogre::Vector3&);// Code des méthodes de la classe
Map_loader::Map_loader(void)
{
	//Defining map file syntax
	ParserBalise* Map = new ParserBalise;
	Map->Name = "Map";	MapSyntax.push_back(Map);		MapSyntax.back()->BoolKeywords.push_back("Vegetation_Enabled");
		MapSyntax.back()->BoolKeywords.push_back("Weather_Cloud_Enabled");		MapSyntax.back()->IntKeywords.push_back("Heightmap_Size");
		MapSyntax.back()->IntKeywords.push_back("Heightmap_MaxPixelError");
		MapSyntax.back()->IntKeywords.push_back("World_Bach_Size_min");
		MapSyntax.back()->IntKeywords.push_back("World_Bach_Size_Max");		MapSyntax.back()->FloatKeywords.push_back("World_Horisontal_Size");
		MapSyntax.back()->FloatKeywords.push_back("World_Vertical_Size");
		MapSyntax.back()->FloatKeywords.push_back("World_Water_Height");
		MapSyntax.back()->FloatKeywords.push_back("Time_Starting");
		MapSyntax.back()->FloatKeywords.push_back("Time_Multiplier");
		MapSyntax.back()->FloatKeywords.push_back("Time_Sunrise");
		MapSyntax.back()->FloatKeywords.push_back("Time_Sunset");
		MapSyntax.back()->FloatKeywords.push_back("World_East_Direction");
		MapSyntax.back()->FloatKeywords.push_back("Weather_Cloud_Humidity");
		MapSyntax.back()->FloatKeywords.push_back("Weather_Cloud_Average_Width");
		MapSyntax.back()->FloatKeywords.push_back("Weather_Cloud_Altitude");
		MapSyntax.back()->FloatKeywords.push_back("Weather_Cloud_Height");
		MapSyntax.back()->FloatKeywords.push_back("Weather_Wind_Speed");
		MapSyntax.back()->FloatKeywords.push_back("Weather_Wind_Direction");
		MapSyntax.back()->FloatKeywords.push_back("Weather_Sky_Exposure");
		MapSyntax.back()->FloatKeywords.push_back("Weather_Sky_MieMultiplier");
		MapSyntax.back()->FloatKeywords.push_back("Faune_Page_Min_Size");
		MapSyntax.back()->FloatKeywords.push_back("Faune_Display_Distance");		MapSyntax.back()->Vector3Keywords.push_back("Weather_Sky_WaveLength");
		MapSyntax.back()->Vector3Keywords.push_back("World_Position");
		MapSyntax.back()->Vector3Keywords.push_back("Spawn_Position");		MapSyntax.back()->StringKeywords.push_back("Name");
		MapSyntax.back()->StringKeywords.push_back("Heightmap_File");		ParserBalise Layer = {"Layer"};
		MapSyntax.back()->SousBalises.push_back(Layer);
		
			MapSyntax.back()->SousBalises.back().FloatKeywords.push_back("Size");
			MapSyntax.back()->SousBalises.back().FloatKeywords.push_back("MaskFactor");
			
			MapSyntax.back()->SousBalises.back().StringKeywords.push_back("Diffuse");
			MapSyntax.back()->SousBalises.back().StringKeywords.push_back("Normal");
			MapSyntax.back()->SousBalises.back().StringKeywords.push_back("Mask");		ParserBalise Vegetation_object_pager = {"Vegetation object pager"};
		MapSyntax.back()->SousBalises.push_back(Vegetation_object_pager);			MapSyntax.back()->SousBalises.back().IntKeywords.push_back("Impostor_Resolution");
			MapSyntax.back()->SousBalises.back().IntKeywords.push_back("Object_Count");			MapSyntax.back()->SousBalises.back().FloatKeywords.push_back("Page_Size");
			MapSyntax.back()->SousBalises.back().FloatKeywords.push_back("Baches_Distance");
			MapSyntax.back()->SousBalises.back().FloatKeywords.push_back("Baches_FadingDistance");
			MapSyntax.back()->SousBalises.back().FloatKeywords.push_back("Impostor_Distance");
			MapSyntax.back()->SousBalises.back().FloatKeywords.push_back("Impostor_FadingDistance");
			MapSyntax.back()->SousBalises.back().FloatKeywords.push_back("RandomPosition_Y_UpperBound");
			MapSyntax.back()->SousBalises.back().FloatKeywords.push_back("RandomPosition_Y_LowerBound");
			MapSyntax.back()->SousBalises.back().FloatKeywords.push_back("RandomPosition_Y_MaxDelta");
			MapSyntax.back()->SousBalises.back().FloatKeywords.push_back("RandomPosition_Y_minDelta");
			
			ParserBalise Entity = {"Entity"};
			MapSyntax.back()->SousBalises.back().SousBalises.push_back(Entity);				MapSyntax.back()->SousBalises.back().SousBalises.back().FloatKeywords.push_back("RandomScale_MinValue");
				MapSyntax.back()->SousBalises.back().SousBalises.back().FloatKeywords.push_back("RandomScale_MaxValue");
				MapSyntax.back()->SousBalises.back().SousBalises.back().FloatKeywords.push_back("windFactorX");
				MapSyntax.back()->SousBalises.back().SousBalises.back().FloatKeywords.push_back("windFactorY");				MapSyntax.back()->SousBalises.back().SousBalises.back().StringKeywords.push_back("Visual_FileName");
				MapSyntax.back()->SousBalises.back().SousBalises.back().StringKeywords.push_back("PhysX_FileName");
				
		
		ParserBalise Vegetation_image_pager = {"Vegetation image pager"};
		MapSyntax.back()->SousBalises.push_back(Vegetation_image_pager);			MapSyntax.back()->SousBalises.back().IntKeywords.push_back("RenderTechnique");			MapSyntax.back()->SousBalises.back().FloatKeywords.push_back("Page_Size");
			MapSyntax.back()->SousBalises.back().FloatKeywords.push_back("Distance");
			MapSyntax.back()->SousBalises.back().FloatKeywords.push_back("FadeDistance");
			MapSyntax.back()->SousBalises.back().FloatKeywords.push_back("Size_min");
			MapSyntax.back()->SousBalises.back().FloatKeywords.push_back("Size_Max");
			MapSyntax.back()->SousBalises.back().FloatKeywords.push_back("Sway_Distribution");
			MapSyntax.back()->SousBalises.back().FloatKeywords.push_back("Sway_Length");
			MapSyntax.back()->SousBalises.back().FloatKeywords.push_back("Sway_Speed");
			MapSyntax.back()->SousBalises.back().FloatKeywords.push_back("Density");			MapSyntax.back()->SousBalises.back().StringKeywords.push_back("Material_Name");
			MapSyntax.back()->SousBalises.back().StringKeywords.push_back("ColorMap");
			MapSyntax.back()->SousBalises.back().StringKeywords.push_back("DensityMap");		ParserBalise Particle = {"Fluid"};
		MapSyntax.back()->SousBalises.push_back(Particle);
		
			MapSyntax.back()->SousBalises.back().IntKeywords.push_back("MaxParticles");
			MapSyntax.back()->SousBalises.back().IntKeywords.push_back("RenderQueueGroupOffset");			MapSyntax.back()->SousBalises.back().FloatKeywords.push_back("KernelRadiusMultiplier");
			MapSyntax.back()->SousBalises.back().FloatKeywords.push_back("RestParticlesPerMetre");
			MapSyntax.back()->SousBalises.back().FloatKeywords.push_back("MotionLimitMultiplier");
			MapSyntax.back()->SousBalises.back().FloatKeywords.push_back("PacketSizeMultiplier");
			MapSyntax.back()->SousBalises.back().FloatKeywords.push_back("CollisionDistanceMultiplier");
			MapSyntax.back()->SousBalises.back().FloatKeywords.push_back("Stiffness");
			MapSyntax.back()->SousBalises.back().FloatKeywords.push_back("Viscosity");
			MapSyntax.back()->SousBalises.back().FloatKeywords.push_back("ParticleLifetime");
			MapSyntax.back()->SousBalises.back().FloatKeywords.push_back("Rate");
			MapSyntax.back()->SousBalises.back().FloatKeywords.push_back("FluidSpeed");
			MapSyntax.back()->SousBalises.back().FloatKeywords.push_back("RestDensity");
			MapSyntax.back()->SousBalises.back().FloatKeywords.push_back("ReplusionCoefficient");
			MapSyntax.back()->SousBalises.back().FloatKeywords.push_back("ParticleSize");			MapSyntax.back()->SousBalises.back().Vector3Keywords.push_back("Position");
			MapSyntax.back()->SousBalises.back().Vector3Keywords.push_back("Orientation");
			MapSyntax.back()->SousBalises.back().Vector3Keywords.push_back("EmmiterSize"); // width height depth
			
			MapSyntax.back()->SousBalises.back().StringKeywords.push_back("SimulationMethod");
			MapSyntax.back()->SousBalises.back().StringKeywords.push_back("Type");
			MapSyntax.back()->SousBalises.back().StringKeywords.push_back("Material");}
Map_loader::~Map_loader(void)
{
}void Map_loader::load(string mapfile)
{
	// Parsing file with that brand new syntax
	std::vector<NamedDataPool> MapDataPoolArray = Map_Parser.ParseFile(MapSyntax,mapfile);
	MapDataPool = MapDataPoolArray[FindPoolIndexFromName(MapDataPoolArray,"Map")]; // On ne garde que la Pool map	// Map Loading
	terrainGlobals = OGRE_NEW TerrainGlobalOptions();
	terrainGlobals->setCompositeMapDistance(300);
	TerrainMaterialGeneratorA::SM2Profile* matProfile = static_cast<TerrainMaterialGeneratorA::SM2Profile*>(terrainGlobals->getDefaultMaterialGenerator()->getActiveProfile());
//	matProfile->setReceiveDynamicShadowsEnabled(true);
//	matProfile->setReceiveDynamicShadowsPSSM(static_cast<PSSMShadowCameraSetup*>(sys0.mPSSMSetup.get()));	string MapName = StringFromName(MapDataPool,"Heightmap_File");	Ogre::uchar* Heightmap_bin;
	if(MapName != "random")
		img.load(MapName, ResourceGroupManager::DEFAULT_RESOURCE_GROUP_NAME);
	else
	{
		// Perlin noise heightmap
		Heightmap_bin = PerlinNoise(IntFromName(MapDataPool,"Heightmap_Size"), 8, 0.45);
		img.loadDynamicImage(Heightmap_bin,IntFromName(MapDataPool,"Heightmap_Size"),IntFromName(MapDataPool,"Heightmap_Size"),1,PF_L16);
	}
	   Terrain::ImportData imp;
   imp.inputImage = &img;
   imp.terrainSize = IntFromName(MapDataPool,"Heightmap_Size");
   imp.inputScale = FloatFromName(MapDataPool,"World_Vertical_Size");
   imp.worldSize = FloatFromName(MapDataPool,"World_Horisontal_Size");
   imp.minBatchSize = IntFromName(MapDataPool,"World_Bach_Size_min");
   imp.maxBatchSize = IntFromName(MapDataPool,"World_Bach_Size_Max");
   imp.pos = Vector3FromName(MapDataPool,"World_Position");
   terrainGlobals->setMaxPixelError(IntFromName(MapDataPool,"Heightmap_MaxPixelError"));
   terrainGlobals->setLayerBlendMapSize(IntFromName(MapDataPool,"Heightmap_Size")); // Les blends maps seront redimentionnés a la taille de la heightmap
   
    // Light
	Ogre::Light *mLight0;   if(!sys0.mgr->hasLight("SunLight"))
   {
		mLight0 = sys0.mgr->createLight("SunLight"); // True sun
		mLight0->setDiffuseColour(0.6f, 0.6f, 0.6f);
		mLight0->setCastShadows(false);
   }
   else
	   mLight0 = sys0.mgr->getLight("SunLight");   // Create a light
   Ogre::Vector3 lightdir(0, -1, 0);
   lightdir.normalise();   Ogre::Light* l;
   if(!sys0.mgr->hasLight("SunLight1"))
   {
	   l = sys0.mgr->createLight("SunLight1"); // Shadow and parallax light
	   l->setType(Light::LT_DIRECTIONAL);
	  // l->setShadowFarDistance(200);
	   l->setDirection(lightdir);
	   l->setDiffuseColour(ColourValue(0.4f, 0.4f,0.4f));
	   l->setSpecularColour(ColourValue(0.000f, 0.000f, 0.000f));
   }
   else
	   l = sys0.mgr->getLight("SunLight1");   terrainGlobals->setLightMapSize(128);
   terrainGlobals->setLightMapDirection(l->getDerivedDirection());
   terrainGlobals->setCompositeMapDiffuse(l->getDiffuseColour());   std::vector<int> LayerIndexes = SubPoolsIndexesFromName(MapDataPool,"Layer");
   Ogre::uint NbLayer = LayerIndexes.size();
   // textures
   imp.layerList.resize(NbLayer);
   for(Ogre::uint16 t=0;t<NbLayer;++t)
   {
	   imp.layerList[t].worldSize = FloatFromName(MapDataPool.SubPool[LayerIndexes[t]],"Size");
	   imp.layerList[t].textureNames.push_back(StringFromName(MapDataPool.SubPool[LayerIndexes[t]],"Diffuse"));
	   imp.layerList[t].textureNames.push_back(StringFromName(MapDataPool.SubPool[LayerIndexes[t]],"Normal"));
   }   terrain->prepare(imp); terrain->load();
   //terrain->save("terrain.dat");   std::vector<TerrainLayerBlendMap*> blendMapList;
   for(Ogre::uint t=1;t<NbLayer;++t)// la première n'a pas de blendmap, ce pourquoi on part de 1
	   blendMapList.push_back(terrain->getLayerBlendMap(t));    int blendmapsize = terrain->getLayerBlendMapSize();
   std::vector<Ogre::Image> ImageList;
   Ogre::Image temp;
   if (MapName != "random")
	   for(Ogre::uint t=1;t<NbLayer;++t)// la première n'a pas de blendmap, ce pourquoi on part de 1
	   {
			ImageList.push_back(temp);
			ImageList.back().load(StringFromName(MapDataPool.SubPool[LayerIndexes[t]],"Mask"), "General"); //Mask de la première Layer n'est jamais utilisé
		    ImageList.back().resize(blendmapsize, blendmapsize);
	   }
   else
   {
		// Cliffs
		ImageList.push_back(temp);
		ImageList.back().loadDynamicImage(Derivation2D(IntFromName(MapDataPool,"Heightmap_Size"),Heightmap_bin),IntFromName(MapDataPool,"Heightmap_Size"),IntFromName(MapDataPool,"Heightmap_Size"),1,PF_L16);
		// Cliffs
		ImageList.push_back(temp);
		ImageList.back().loadDynamicImage(Derivation2D(IntFromName(MapDataPool,"Heightmap_Size"),Heightmap_bin),IntFromName(MapDataPool,"Heightmap_Size"),IntFromName(MapDataPool,"Heightmap_Size"),1,PF_L16);
		// Dry sand
		ImageList.push_back(temp);
		ImageList.back().loadDynamicImage(Heightmap_bin,IntFromName(MapDataPool,"Heightmap_Size"),IntFromName(MapDataPool,"Heightmap_Size"),1,PF_L16);		ImageList.push_back(temp);
		ImageList.back().loadDynamicImage(Heightmap_bin,IntFromName(MapDataPool,"Heightmap_Size"),IntFromName(MapDataPool,"Heightmap_Size"),1,PF_L16);		ImageList.push_back(temp);
		ImageList.back().loadDynamicImage(Heightmap_bin,IntFromName(MapDataPool,"Heightmap_Size"),IntFromName(MapDataPool,"Heightmap_Size"),1,PF_L16);   }
   std::vector<float*> pBlend;
   for(Ogre::uint t=1;t<NbLayer;++t)// blendMapList[0] est la blendmap de la layer 1 d'ou le décalage en t-1
	   pBlend.push_back(blendMapList[t-1]->getBlendPointer());
   
   // blend textures
   for(Ogre::uint t=0;t<NbLayer-1;++t) 
   {
	   float MaskFactor = FloatFromName(MapDataPool.SubPool[LayerIndexes[t]],"MaskFactor");
	   if(MaskFactor == -1) MaskFactor = 1;       for (Ogre::uint y = 0; y < terrain->getLayerBlendMapSize(); ++y)
	       for (Ogre::uint x = 0; x < terrain->getLayerBlendMapSize(); ++x)
			  *pBlend[t]++ = ImageList[t].getColourAt(x,y,0).r*MaskFactor;
   }   for(Ogre::uint t=0;t<NbLayer-1;++t)
   {
       blendMapList[t]->dirty();
	   blendMapList[t]->update();
   }
  // terrain->setGlobalColourMapEnabled(true,1024);   terrainGlobals->getDefaultMaterialGenerator()->generate(terrain);
   terrain->getMaterial()->setShininess(128);
   terrain->getMaterial()->setSpecular(ColourValue(0.1f,0.1f,0.1f));}
// Perlin noise function
Ogre::uchar* Map_loader::PerlinNoise(Ogre::uint sizeXY, unsigned char octaves, float persistence)
{
	std::vector<unsigned short*> data;
	size_t height = sizeXY;
	size_t width = sizeXY;
	size_t pitch = sizeXY; // Skip between rows of image	// each data element contain an octave image
	for(Ogre::uchar i = 1; i <= octaves; ++i)
	{
		data.push_back(new unsigned short[height*width]);
		Ogre::uint step = (width+1)/(pow((float)2,(int)i));
		Ogre::uint X = 0, Y = 0;
		while (X<width)
		{
			Y = 0;
			while(Y <height)
			{
				//random mid-point elevation
				data.back()[pitch*Y + X] =  Ogre::Math::RangeRandom(0,65536);				size_t miny = Y-step,maxy = Y+step; // Define the y range that can be affected by the interpolated midpoint elevation
				if(miny<0)miny=0;
				if(maxy>height)maxy=height;
				
				size_t minx = X-step,maxx = X+step; // Define the x range that can be affected by the interpolated midpoint elevation
				if(minx<0)minx=0;
				if(maxx>width)maxx=width;				// Cosinusoidal Interpolation (just in the previouly defined range, faster)
				for(size_t y=miny; y<maxy; ++y)
					for(size_t x=minx; x<maxx; ++x)
					{
						// interpolate concernard pixel
						float dist = sqrt(float((x-X)*(x-X)+(y-Y)*(y-Y)));
						dist /= step;
						if(dist < 1)
						{
							dist = (1-cos(3.141*dist))/2;
							data.back()[pitch*y + x] = data.back()[pitch*y + x]*dist + data.back()[pitch*Y + X] * (1-dist);						}
					}
				
				Y += step;
			}
			X += step;
		}
		
	}	float factor;
	data.push_back(new unsigned short[height*width]);// ce dernier élément de data contient la somme (pondéré du factor) des octaves	for(size_t y=0; y<height; ++y)
		for(size_t x=0; x<width; ++x)
		{
			// Chaque pixel est modifié comme étant la somme de tout les octaves pondérés
			factor = (1-persistence)/(1-pow(persistence,(int)octaves));
			for(Ogre::uchar i = 0; i < octaves; ++i)
			{
				data.back()[pitch*y + x] += data[i][pitch*y + x]*factor;
				factor *= persistence;
			}
		}
	return reinterpret_cast<Ogre::uchar*>(data.back());
}// 2D derivation Analysis function
Ogre::uchar* Map_loader::Derivation2D(Ogre::uint sizeXY, Ogre::uchar* input_char)
{
	unsigned short* input = reinterpret_cast<unsigned short*>(input_char);
	size_t height = sizeXY;
	size_t width = sizeXY;
	size_t pitch = sizeXY; // Skip between rows of image
	unsigned short* output = new unsigned short[height*width];
	
	for(size_t y=0; y<height-1; ++y)
		for(size_t x=0; x<width-1; ++x)
		{
			int	deltaX = input[pitch*y + x + 1] - input[pitch*y + x],
				deltaY = input[pitch*(y+1) + x] - input[pitch*y + x];
			output[pitch*y + x] = 100*(unsigned short)sqrt(float(deltaX*deltaX+deltaY*deltaY)); // factor of 100 on the output
		}	return reinterpret_cast<Ogre::uchar*>(output);
}void Map_loader::unload(void)
{
	sys0.mgr->destroyAllLights();
}
Ogre::Real terrain_height(float x,float z, void *userData = NULL)
{
	return Map.terrain->getHeightAtWorldPosition(Ogre::Vector3(x,0,z));
}void loadTerrainGeometry(const Ogre::String& name, float* data, Ogre::uint16 size, Ogre::Real worldSize, Ogre::Real minHeight, Ogre::Real maxHeight, const Ogre::Vector3& position)
{
	// Create the manual heightfield
	NxOgre::ManualHeightField mhf;
	mhf.begin(size, size);
	Ogre::Real normMin = -32768.0f;
	Ogre::Real normMax = 32767.0f;
	// Sample the data to the manual heightfield
	for(int x = 0; x < size; ++x)
	{
		NxOgre::Enums::HeightFieldTesselation tess = NxOgre::Enums::HeightFieldTesselation_NW_SE;
		for(int z = size-1; z >= 0; --z)
		{
			Ogre::Real height = data[(size * z) + x];
			short sample = (short)(((height - minHeight) / (maxHeight - minHeight)) * (normMax - normMin) + normMin);
			mhf.sample(sample, 0, 0, tess);
			if(tess == NxOgre::Enums::HeightFieldTesselation_NE_SW)
				tess = NxOgre::Enums::HeightFieldTesselation_NW_SE;
			else
				tess = NxOgre::Enums::HeightFieldTesselation_NE_SW;
		}
	}
	// Create the actual heightfield
	NxOgre::HeightField *hf = mhf.end(name.c_str());
	Ogre::Real hf_size = worldSize + (worldSize / size);
	Ogre::Real hf_height = (maxHeight - minHeight) / 2.0f;
	Ogre::Real hf_pose_x = position.x - (worldSize / 2.0f);
	Ogre::Real hf_pose_y = position.y + ((maxHeight + minHeight) / 2.0f);
	Ogre::Real hf_pose_z = position.z - (worldSize / 2.0f);
#if NxOgreVersionMajor <= 1 && NxOgreVersionMinor <= 5
	NxOgre::HeightFieldGeometry* hfg = new NxOgre::HeightFieldGeometry(hf, NxOgre::Vec3(hf_size, hf_height, hf_size));
	hfg->setLocalPose(NxOgre::Matrix44(NxOgre::Vec3(hf_pose_x, hf_pose_y, hf_pose_z)));
	mScene->createSceneGeometry(hfg);
#else
	NxOgre::HeightFieldGeometryDescription desc(hf, NxOgre::Vec3(hf_size, hf_height, hf_size));
	PhysX_man.mScene->createSceneGeometry(desc, NxOgre::Matrix44(NxOgre::Vec3(hf_pose_x, hf_pose_y, hf_pose_z)));
#endif}#include "Namuh_Main_H.h"using namespace Ogre;
MapParser Map_Parser;
// Code des méthodes de la classe
MapParser::MapParser(void)
{	
}
MapParser::~MapParser(void)
{
}void MapParser::initialise(void)
{ 
	
}
std::vector<NamedDataPool> MapParser::ParseFile(std::vector<ParserBalise*> Syntax,string File,std::vector<string> ExcludedInclusions, string StartingBalise)
{
	// Espace mémoire du parser
	std::vector<NamedDataPool> Output;
	NamedDataPool* CurrentPool = NULL;
	std::vector<ParserBalise*> ActiveBalise;
	ActiveBalise.push_back(NULL);
	Ogre::uint no_ligne = 0;	// On sépare le nom du fichier de son chemin d'acces
	string FileWOpath = File;
	FileWOpath.replace(0,FileWOpath.rfind("/")+1,"");
	string path = File;
	path.replace(path.rfind("/")+1,path.length()-path.rfind("/"),"");
	
	ldbg.send("(Map Parser Info) Parsing file : "+ FileWOpath );	//entrée dans la balise de départ spécifié
	if(StartingBalise != "")
	{
		while(StartingBalise != "")
		{
			string CurrentBaliseToAdd = StartingBalise;			StartingBalise.replace(0,StartingBalise.find("/")+1,"");//on enlève la balise que l'on considère de la pile a considérer
			CurrentBaliseToAdd.replace(CurrentBaliseToAdd.find("/"),CurrentBaliseToAdd.length()-CurrentBaliseToAdd.find("/"),""); // on ne considère que celle que l'on a enlevée
			if(ActiveBalise.back() == NULL)
				ActiveBalise.push_back(Syntax[FindBaliseIndexFromName(Syntax,CurrentBaliseToAdd)]); //On ajoute la balise
			else 
				ActiveBalise.push_back(&ActiveBalise.back()->SousBalises[FindBaliseIndexFromName(ActiveBalise.back()->SousBalises,CurrentBaliseToAdd)]); // Pareil, masi c'est juste que le protocola dffère si on est pas a la première balise
		}
	ldbg.send("(Map Parser Info) Initial Balise : "+ ActiveBalise.back()->Name );
	}	ifstream file (&File[0],ios::in);
	if(!file)ldbg.send("(Map Parser Exeption) Unable to open "+ FileWOpath +", abording...");
	else
	{		string balise = "",ligne,lignebis,variable,valeur;
		bool ligneType_reconue = false;
		while(getline(file,ligne))
		{
			no_ligne++;
			ligneType_reconue = false;
			if(ligne != "" && ligne.find_first_not_of("	 ") < ligne.length()) // Si la ligne du fichier mérite d'être lue
			{
				if(ligne[ligne.find_first_not_of("	 ")] != '#') // Si la ligne n'est pas vide, on doit vérifier que l'on a pas affaire a un commentaire
				{
					if(ligne.find("#") < ligne.length())
						ligne.replace(ligne.find("#"),ligne.length()-ligne.find("#"),""); //on nettoie les commentaires de fin de ligne					lignebis = ligne; // on recopie dans lignebis car on a besoin d'une deuxième string pour la valeur de la variable
					if(ligne.find("=") < ligne.length() && !ligneType_reconue) //Si c'est une affectation de variable
					{
						ligneType_reconue = true;						variable = ligne.replace(ligne.find("="),ligne.length()-ligne.find("="),"");
							while(variable.find(" ")<= variable.length())
								variable.replace(variable.find(" "),1,""); // On fait sauter tout les espaces dans le nom de la variable			
							while(variable.find("	")<= variable.length())
								variable.replace(variable.find("	"),1,""); // On fait sauter tout les tab dans le nom de la variable						valeur = lignebis.replace(0,lignebis.find("=")+1,"");
							if(valeur.find(" ")<= valeur.find_first_not_of(" "))
								valeur.replace(0,valeur.find_first_not_of(" "),""); // On fait sauter tout les espaces avant la valeur
							if(valeur.rfind(" ")>= valeur.find_last_not_of(" "))
								valeur.replace(valeur.find_last_not_of(" ")+1,valeur.length()-valeur.find_last_not_of(" ")-1,""); // On fait sauter tout les espaces après la valeur
							if(valeur.find("	")<= valeur.find_first_not_of("	"))
								valeur.replace(0,valeur.find_first_not_of("	"),""); // On fait sauter tout les tab avant la valeur
							if(valeur.rfind("	")>= valeur.find_last_not_of("	"))
								valeur.replace(valeur.find_last_not_of("	")+1,valeur.length()-valeur.find_last_not_of("	")-1,""); // On fait sauter tout les tab après la valeur
						
						bool affected = false;						//Affectation
						for(Ogre::uint t=0;t<ActiveBalise.back()->BoolKeywords.size();++t)
							if(variable == ActiveBalise.back()->BoolKeywords[t])
							{
								struct NamedBool mNamedBool = {variable,StringConverter::parseBool(valeur)};
								CurrentPool->Bool_Data.push_back(mNamedBool);
								affected = true;
								//ldbg.send("(Map Parser Info)Registered variable '" + variable + "' with value '"+valeur+"'" );
							}						if(StringConverter::isNumber(valeur))
						{
							for(Ogre::uint t=0;t<ActiveBalise.back()->IntKeywords.size();++t)
								if(variable == ActiveBalise.back()->IntKeywords[t])
								{
									struct NamedInt mNamedInt = {variable,StringConverter::parseInt(valeur)};
									CurrentPool->Int_Data.push_back(mNamedInt);
									affected = true;
									//ldbg.send("(Map Parser Info)Registered variable '" + variable + "' with value '"+valeur+"'" );
								}							for(Ogre::uint t=0;t<ActiveBalise.back()->FloatKeywords.size();++t)
								if(variable == ActiveBalise.back()->FloatKeywords[t])
								{
									struct NamedFloat mNamedFloat = {variable,StringConverter::parseReal(valeur)};
									CurrentPool->Float_Data.push_back(mNamedFloat);
									affected = true;
									//ldbg.send("(Map Parser Info)Registered variable '" + variable + "' with value '"+valeur+"'" );
								}
						}						for(Ogre::uint t=0;t<ActiveBalise.back()->Vector3Keywords.size();++t)
							if(variable == ActiveBalise.back()->Vector3Keywords[t])
							{
								struct NamedVector3 mNamedVector3 = {variable,StringConverter::parseVector3(valeur)};
								CurrentPool->Vector3_Data.push_back(mNamedVector3);
								affected = true;
								//ldbg.send("(Map Parser Info)Registered variable '" + variable + "' with value '"+valeur+"'" );
							}						for(Ogre::uint t=0;t<ActiveBalise.back()->StringKeywords.size();t++)
							if(variable == ActiveBalise.back()->StringKeywords[t])
							{
								struct NamedString mNamedString = {variable,valeur};
								CurrentPool->String_Data.push_back(mNamedString);
								affected = true;
								//ldbg.send("(Map Parser Info)Registered variable '" + variable + "' with value '"+valeur+"'" );
							}
						//Si variable inconnue, erreur
							if(!affected)ldbg.send("(Map Parser Exeption) Unable to find in "+ balise +" the variable named '" + variable + "' ("+valeur+")"+"  (line " + toOgStr(no_ligne)+ " in "+FileWOpath+")" );
					}
					if(!ligneType_reconue)
					{
						
						if(ligne.find(" ")<= ligne.find_first_not_of(" "))
							ligne.replace(0,ligne.find_first_not_of(" "),""); // On fait sauter tout les espaces avant la commande
						if(ligne.rfind(" ")>= ligne.find_last_not_of(" "))
							ligne.replace(ligne.find_last_not_of(" ")+1,ligne.length()-ligne.find_last_not_of(" ")-1,""); // On fait sauter tout les espaces après la commande
						if(ligne.find("	")<= ligne.find_first_not_of("	"))
							ligne.replace(0,ligne.find_first_not_of("	"),""); // On fait sauter tout les tab avant la commande
						if(ligne.rfind("	")>= ligne.find_last_not_of("	"))
							ligne.replace(ligne.find_last_not_of("	")+1,ligne.length()-ligne.find_last_not_of("	")-1,""); // On fait sauter tout les tab après la commande						if(ligne[0] == '[' && ligne[ligne.length()-1] == ']' ) // Si on a affaire a une déclaration de balise
						{
							if(ligne[1] != '/') // Si on se sort pas d'une balise (si on y rentre)
							{
								string balise_a_entrer = ligne;
								balise_a_entrer.replace(0,1,""); // on enlève le 1er crochet
								balise_a_entrer.replace(balise_a_entrer.length()-1,1,""); // on enlève le 2nd crochet
								if(balise != "")balise += "/" + balise_a_entrer;
								else balise += balise_a_entrer;								// entrée en balise
								if(CurrentPool == NULL) 
								{
									NamedDataPool mNamedDataPool = {balise_a_entrer,NULL};
									Output.push_back(mNamedDataPool);
									CurrentPool = &Output.back();
									if(ActiveBalise.back() == NULL)
										ActiveBalise.push_back(Syntax[FindBaliseIndexFromName(Syntax,balise_a_entrer)]);
									else
										ActiveBalise.push_back(&ActiveBalise.back()->SousBalises[FindBaliseIndexFromName(ActiveBalise.back()->SousBalises,balise_a_entrer)]);								}
								else 
								{
									NamedDataPool mNamedDataPool; mNamedDataPool.Name = balise_a_entrer; mNamedDataPool.ParentPool = CurrentPool;
									CurrentPool->SubPool.push_back(mNamedDataPool);
									CurrentPool = &CurrentPool->SubPool.back();
									if(ActiveBalise.back() == NULL)
										ActiveBalise.push_back(Syntax[FindBaliseIndexFromName(Syntax,balise_a_entrer)]);
									else
										ActiveBalise.push_back(&ActiveBalise.back()->SousBalises[FindBaliseIndexFromName(ActiveBalise.back()->SousBalises,balise_a_entrer)]);
								}
								//ldbg.send("Entrée dans la balise : "+ balise_a_entrer + " (Now "+balise+")");
							}
							else //si on sort d'une balise
							{
								
								string balise_a_quitter = ligne;
									balise_a_quitter.replace(0,2,""); // on enlève le 1er crochet et le slash
									balise_a_quitter.replace(balise_a_quitter.length()-1,1,""); // on enlève le 2nd crochet								string Current_lowest_balise = balise;
									if(balise != balise_a_quitter) // Si on ne ferme pas la dernière balise, il faut extraire le nom de la plus basse du chemin total
										Current_lowest_balise = Current_lowest_balise.replace(0,Current_lowest_balise.rfind("/")+1,""); // On enlève les balises supérieures
									
								if(balise_a_quitter ==  Current_lowest_balise) // si on ferme bien la bonne balise
								{
									if(balise != balise_a_quitter) //Si on sors d'une sous balise
									{
										balise.replace(balise.rfind(balise_a_quitter)-1,balise_a_quitter.length()+1,"");
										CurrentPool = CurrentPool->ParentPool;
										ActiveBalise.pop_back();
										//ldbg.send("Sortie de la balise : "+ balise_a_quitter + " (Now "+balise+")");
									}
									else // Si l'on revient a la racine
									{
										CurrentPool = NULL;
										ActiveBalise.pop_back();
										//ldbg.send("Sortie de la balise : "+ balise_a_quitter + " (Now the global dommain)");
									}
								}
								else
								{
									ldbg.send("(Map Parser Exeption) Unable to exit balise : "+balise_a_quitter+"isn't the lowest one "+"(line " + toOgStr(no_ligne) + " in "+FileWOpath+")");
								}
							}
						}						if(ligne[0] == '<' && ligne[ligne.length()-1] == '>' ) // Si on a affaire a une inclsion de fichier
						{
							// On nettoie la ligne
							string fichier_a_parser = ligne;
							fichier_a_parser.replace(0,1,""); // on enlève le >
							fichier_a_parser.replace(fichier_a_parser.length()-1,1,""); // on enlève le <
							ldbg.send("(Map Parser Info) Subfile parsing requested : "+fichier_a_parser);							// Mise en String de la balise courrante
							string Current_Balise_position = "";
							for(int t = 1;t != ActiveBalise.size();t++) // ActiveBalise[0] est NULL
								Current_Balise_position += ActiveBalise[t]->Name+"/";// On génère le path des balises dans une string
							ldbg.send("(Map Parser Info) Subfile parsing active balise path : "+Current_Balise_position);							// Is there any looping recusion in file inclusion ?
							std::vector<string> CurrentExclusion = ExcludedInclusions;
							CurrentExclusion.push_back(FileWOpath);
							bool skipflag = false;
							for(int t = 0;t != CurrentExclusion.size();t++)
								if(fichier_a_parser == CurrentExclusion[t])
									skipflag=true;							if(!skipflag) 	
							{
								// Parse le fichier demandé
								std::vector<NamedDataPool> PoolsToImport = MapParser::ParseFile(Syntax, path+fichier_a_parser,CurrentExclusion,Current_Balise_position);
								for(int t = 0;t != PoolsToImport.size();t++)
									CurrentPool->SubPool.push_back(PoolsToImport[t]);
							}
							else // Ah bah non
								ldbg.send("(Map Parser Exeption) Detected looping recursion in this file inclusion, skippig... (in "+ FileWOpath +", ligne : "+ StringConverter::toString(no_ligne) +", "+fichier_a_parser+")");						}
					}
				}
			}
		}
		file.close();
		ldbg.send("File "+FileWOpath+" sucessfully parsed "+"(Nblines :  " + toOgStr(Ogre::uint(no_ligne))+")");
	}
	return Output;
};void MapParser::destroy(void)
{ 
	
}
// /!\ on parcourt toute la liste de *_Data a l'envert. Comme ca la dernière valeur fournie est retenuebool BoolFromName(NamedDataPool SearchScope, string Name)
{
	for(int t = SearchScope.Bool_Data.size()-1;t >= 0;--t)
		if(Name == SearchScope.Bool_Data[t].Name)
			return SearchScope.Bool_Data[t].data;
	
	ldbg.send("(BoolFromNameExeption) Error while retriving bool : No such NamedBool. Will return false. ( Requested : " + Name + " in the pool named : " + SearchScope.Name + " )" );
	return false;
};int IntFromName(NamedDataPool SearchScope, string Name)
{
	for(int t = SearchScope.Int_Data.size()-1;t >= 0;--t)
		if(Name == SearchScope.Int_Data[t].Name)
			return SearchScope.Int_Data[t].data;	ldbg.send("(IntFromNameExeption) Error while retriving int : No such NamedInt.  Will return  -1. ( Requested : " + Name + " in the pool named : " + SearchScope.Name + " )" );
	return -1;
};float FloatFromName(NamedDataPool SearchScope, string Name)
{
	for(int t = SearchScope.Float_Data.size()-1;t>= 0;t--)
		if(Name == SearchScope.Float_Data[t].Name)
			return SearchScope.Float_Data[t].data;
	
	ldbg.send("(FloatFromNameExeption) Error while retriving float : No such NamedFloat.  Will return  -1. ( Requested : " + Name + " in the pool named : " + SearchScope.Name + " )" );
	return -1;
};Ogre::Vector3 Vector3FromName(NamedDataPool SearchScope, string Name)
{
	for(int t = SearchScope.Vector3_Data.size()-1;t >= 0;--t)
		if(Name == SearchScope.Vector3_Data[t].Name)
			return SearchScope.Vector3_Data[t].data;
	
	ldbg.send("(Vector3FromNameExeption) Error while retriving Vector3 : No such NamedVector3.  Will return  (0,0,0). ( Requested : " + Name + " in the pool named : " + SearchScope.Name + " )" );
	return Ogre::Vector3::ZERO;
};string StringFromName(NamedDataPool SearchScope, string Name)
{
	for(int t = SearchScope.String_Data.size()-1;t >= 0;--t)
		if(Name == SearchScope.String_Data[t].Name)
			return SearchScope.String_Data[t].data;	ldbg.send("(StringFromNameExeption) Error while retriving String : No such NamedString.  Will return  a blank string. ( Requested : " + Name + " in the pool named : " + SearchScope.Name + " )" );
	return "";
};std::vector<int> SubPoolsIndexesFromName(NamedDataPool SearchScope, string Name)
{
	std::vector<int> table;
	for( Ogre::uint t = 0; t != SearchScope.SubPool.size() ; t++ )
		if(Name ==  SearchScope.SubPool[t].Name)
			table.push_back(t);	//if(table.size()==0)ldbg.send("(SubPoolsIndexesFromNameExeption) Error while retriving SubPoolsIndexes : No such SubPool. Returning a blank list... ( Requested : " + Name + "in the pool named : " + SearchScope.Name + " )" );
	return table;
};int FindPoolIndexFromName(std::vector<NamedDataPool> SearchScope, string Name)
{
	for(int t = SearchScope.size()-1;t>=0;t--)
		if(Name == SearchScope[t].Name)
			return t;	ldbg.send("(FindPoolIndexFromNameExeption) Fatal Error while retriving pool index : No such pool in this array.  Will return  -1. ( Requested : " + Name +" )" );
	ldbg.send("(FindPoolIndexFromNameExeption) Warning : SEGFAULT inbound" );
	ldbg.send("(FindPoolIndexFromNameExeption) Dump : (Search scope lenth : "+StringConverter::toString(SearchScope.size())+" )" );
	for(Ogre::uint t = SearchScope.size()-1;t>=0;t--)
		ldbg.send("(FindPoolIndexFromNameExeption) SearchScope(" + StringConverter::toString(t) + ").Name : "+SearchScope[t].Name);
	return -1;
};
int FindBaliseIndexFromName(std::vector<ParserBalise*> SearchScope, string Name)
{
	for(int t = SearchScope.size()-1;t>=0;t--)
		if(Name == SearchScope[t]->Name)
			return t;	ldbg.send("(FindBaliseIndexFromNameExeption) Fatal Error while retriving balise index : No such Balise in this array.  Will return  -1. ( Requested : " + Name +" )" );
	ldbg.send("(FindBaliseIndexFromNameExeption) Warning : SEGFAULT inbound" );
	ldbg.send("(FindBaliseIndexFromNameExeption) Dump : (Search scope lenth : "+StringConverter::toString(SearchScope.size())+" )" );
	for(Ogre::uint t = SearchScope.size()-1;t>=0;t--)
		ldbg.send("(FindBaliseIndexFromNameExeption) SearchScope(" + StringConverter::toString(t) + ")->Name : "+SearchScope[t]->Name);
	ldbg.send("(FindBaliseIndexFromNameExeption) exiting fct" );	return -1;
};int FindBaliseIndexFromName(std::vector<ParserBalise> SearchScope, string Name)
{
	for(int t = SearchScope.size()-1;t>=0;t--)
		if(Name == SearchScope[t].Name)
			return t;	ldbg.send("(FindBaliseIndexFromNameExeption) Fatal Error while retriving balise index : No such Balise in this array.  Will return  -1. ( Requested : " + Name +" )" );
	ldbg.send("(FindBaliseIndexFromNameExeption) Warning : SEGFAULT inbound" );
	ldbg.send("(FindBaliseIndexFromNameExeption) Dump : (Search scope lenth : "+StringConverter::toString(SearchScope.size())+" )" );
	for(Ogre::uint t = SearchScope.size()-1;t>=0;t--)
		ldbg.send("(FindBaliseIndexFromNameExeption) SearchScope[" + StringConverter::toString(t) + "].Name : "+SearchScope[t].Name);	return -1;
};#include "Namuh_Main_H.h"using namespace Ogre;int Menuci::next_id = 0;
bool Menuci::isthereOneVisible =false;// Code des méthodes de la classe
Menuci::Menuci(void)
{
}
Menuci::~Menuci(void)
{
}void Menuci::create(Menuci_Type requested_type,int requested_posX,int requested_posY, string ParentWindow)
{
	id = next_id;
	isVisible = false;
	type = requested_type;
	posX = requested_posX;
	posY = requested_posY;
	output = -1;
	CEGUI::Window *Rootwindow = GuiSandboxMan.winMgr->getWindow(ParentWindow);
	ParentWin = Rootwindow;		highlight = GuiSandboxMan.winMgr->createWindow("TaharezLook/FrameWindow","Sandbox_interface/Menu_Circulaire"+StringConverter::toString(id)+"/Highlight");
		highlight->setSize(CEGUI::UVector2(CEGUI::UDim(0,sys0.vp->getActualHeight()*0.2+10),CEGUI::UDim(0,sys0.vp->getActualHeight()*0.2+2)));
		highlight->setPosition(CEGUI::UVector2(CEGUI::UDim(0,posX-5-sys0.vp->getActualHeight()*0.1),CEGUI::UDim(0,posY-sys0.vp->getActualHeight()*0.1-1)));
		highlight->setAlpha(0.0f);		
		highlight->setProperty("TitlebarEnabled","False");
		highlight->setVisible(false);
			CEGUI::Window* highlight2 = GuiSandboxMan.winMgr->createWindow("TaharezLook/StaticImage","Sandbox_interface/Menu_Circulaire"+StringConverter::toString(id)+"/Highlight/Image");
			highlight2->setInheritsAlpha(false);
			highlight2->setAlpha(1.0f); 
			if(type == Menuci_Type_MainMenu)highlight2->setProperty("Image","set:Menu-principal-higtlight image:menu");
			if(type == Menuci_Type_Four)highlight2->setProperty("Image","set:Menu-circulaire-hightlight image:quatre");
			highlight2->setProperty("FrameEnabled","False");
			highlight2->setProperty("BackgroundEnabled","False");
			highlight2->setArea(CEGUI::URect( CEGUI::UDim(0,0),CEGUI::UDim(0,0) ,CEGUI::UDim(1,0),CEGUI::UDim(1,0) ));
		highlight->addChildWindow(highlight2);		Menu = GuiSandboxMan.winMgr->createWindow("TaharezLook/FrameWindow","Sandbox_interface/Menu_Circulaire"+StringConverter::toString(id)+"/Frame");
		Menu->setSize(CEGUI::UVector2(CEGUI::UDim(0,sys0.vp->getActualHeight()*0.2+10),CEGUI::UDim(0,sys0.vp->getActualHeight()*0.2+2)));
		Menu->setPosition(CEGUI::UVector2(CEGUI::UDim(0,posX-5-sys0.vp->getActualHeight()*0.1),CEGUI::UDim(0,posY-sys0.vp->getActualHeight()*0.1-1)));
		Menu->setAlpha(0.0f);	
		Menu->setProperty("TitlebarEnabled","False");
		Menu->setVisible(false);
			CEGUI::Window* Menu2 = GuiSandboxMan.winMgr->createWindow("TaharezLook/StaticImage","Sandbox_interface/Menu_Circulaire"+StringConverter::toString(id)+"/Frame/Image");
			Menu2->setInheritsAlpha(false);
			Menu2->setAlpha(1.0f); 
			if(type == Menuci_Type_MainMenu)Menu2->setProperty("Image","set:Menu-principal image:menu");
			if(type == Menuci_Type_Four)Menu2->setProperty("Image","set:Menu-circulaire image:quatre");
			Menu2->setProperty("FrameEnabled","False");
			Menu2->setProperty("BackgroundEnabled","False");
			Menu2->setArea(CEGUI::URect( CEGUI::UDim(0,0),CEGUI::UDim(0,0) ,CEGUI::UDim(1,0),CEGUI::UDim(1,0) ));
		Menu->addChildWindow(Menu2);		curseur = GuiSandboxMan.winMgr->createWindow("TaharezLook/FrameWindow","Sandbox_interface/Menu_Circulaire"+StringConverter::toString(id)+"/Pointeur/Frame");
		curseur->setMinSize(CEGUI::UVector2(CEGUI::UDim(0,10),CEGUI::UDim(0,10)));
		curseur->setSize(CEGUI::UVector2(CEGUI::UDim(0,sys0.vp->getActualHeight()*0.06+10),CEGUI::UDim(0,sys0.vp->getActualHeight()*0.06+2)));
		curseur->setPosition(CEGUI::UVector2(cegui_absdim(posX-5-sys0.vp->getActualHeight()*0.03),cegui_absdim(posY-sys0.vp->getActualHeight()*0.03-1))); // Oo
		curseur->setAlpha(0.0f);		
		curseur->setProperty("TitlebarEnabled","False");
		curseur->setVisible(false);
		CEGUI::Window* curseur2 = GuiSandboxMan.winMgr->createWindow("TaharezLook/StaticImage","Sandbox_interface/Menu_Circulaire"+StringConverter::toString(id)+"/Pointeur/Image");
			curseur2->setInheritsAlpha(false);
			curseur2->setAlpha(1.0f);
			curseur2->setProperty("Image","set:curseur-circulaire image:curseur");
			curseur2->setProperty("FrameEnabled","False");
			curseur2->setProperty("BackgroundEnabled","False");
			curseur2->setArea(CEGUI::URect( CEGUI::UDim(0,0),CEGUI::UDim(0,0) ,CEGUI::UDim(1,0),CEGUI::UDim(1,0) )); // l'offset contre le léger écralsement horisontal des images pour garder une image bien circulaire
		curseur->addChildWindow(curseur2);	Rootwindow->addChildWindow(Menu);
	Rootwindow->addChildWindow(curseur);
	Rootwindow->addChildWindow(highlight);	CEGUI::MouseCursor::getSingleton().setPosition(CEGUI::Point(	posX - ParentWin->getXPosition().asAbsolute(sys0.vp->getActualWidth()),
																	posY - ParentWin->getYPosition().asAbsolute(sys0.vp->getActualHeight())));	next_id++;
	ldbg.send("(Menu circulaire n°"+StringConverter::toString(id)+") Created");
}void Menuci::update()
{	float xpol = CEGUI::MouseCursor::getSingleton().getPosition().d_x - posX - ParentWin->getXPosition().asAbsolute(sys0.vp->getActualWidth()),
		  ypol = CEGUI::MouseCursor::getSingleton().getPosition().d_y - posY - ParentWin->getYPosition().asAbsolute(sys0.vp->getActualHeight());
	float angle = -360*(atan((float)(-ypol/(xpol+sqrt((float)(ypol*ypol+xpol*xpol)))))/3.141);	if(type == Menuci_Type_Four)
	{
		if(Menu->isVisible() && !isVisible)
		{
			if(-135<angle && angle<-45)output=1;
			if(-45<angle && angle<45)output=2;	
			if(45<angle && angle<135)output=3;
			if(-135>angle || angle > 135)output=4;	
			ldbg.send("(Menu circulaire n°"+StringConverter::toString(id)+") Output sent : "+StringConverter::toString(output));
		}
		else output=-1;
		if(-135<angle && angle<-45)Current_highlighted=1;
		if(-45<angle && angle<45)Current_highlighted=2;	
		if(45<angle && angle<135)Current_highlighted=3;
		if(-135>angle || angle > 135)Current_highlighted=4;			if(!Menu->isVisible() && isVisible)CEGUI::MouseCursor::getSingleton().setPosition(CEGUI::Point(posX,posY));
		if(xpol != 0)curseur->setRotation(CEGUI::Vector3(curseur->getRotation().d_x,curseur->getRotation().d_y,angle));
		if(-135>angle || angle > 135)highlight->setRotation(CEGUI::Vector3(0,0,-90));
		if(-135<angle && angle<-45)highlight->setRotation(CEGUI::Vector3(0,0,0));
		if(-45<angle && angle<45)highlight->setRotation(CEGUI::Vector3(0,0,90));
		if(45<angle && angle<135)highlight->setRotation(CEGUI::Vector3(0,0,180));
	}	if(type == Menuci_Type_MainMenu)
	{		if(Menu->isVisible() && !isVisible)
		{
			if(-90<angle && angle<90)output=1;
			if(-90>angle || angle > 90)output=2;	
			ldbg.send("(Menu circulaire n°"+StringConverter::toString(id)+") Output sent : "+StringConverter::toString(output));
		}
		else output=-1;		if(-90<angle && angle<90)Current_highlighted=1;
		if(-90>angle || angle > 90)Current_highlighted=2;		if(!Menu->isVisible() && isVisible)CEGUI::MouseCursor::getSingleton().setPosition(CEGUI::Point(posX,posY)); // positionne le curseur au milieu de la roue a son appartion
		if(xpol != 0)curseur->setRotation(CEGUI::Vector3(0,0,angle));
		if(-90<angle && angle<90)highlight->setRotation(CEGUI::Vector3(0,0,0));
		if(-90>angle || angle > 90)highlight->setRotation(CEGUI::Vector3(0,0,180));
	}	Menu->setVisible(isVisible);
	curseur->setVisible(isVisible);
	highlight->setVisible(isVisible);
	
	isthereOneVisible =false;
	for(int i = 0; i<next_id;i++)
	{
		if(GuiSandboxMan.winMgr->isWindowPresent("Sandbox_interface/Menu_Circulaire"+StringConverter::toString(i)+"/Frame"))
		{
			CEGUI::Window *AnotherMenu = GuiSandboxMan.winMgr->getWindow("Sandbox_interface/Menu_Circulaire"+StringConverter::toString(i)+"/Frame");
			isthereOneVisible = isthereOneVisible || AnotherMenu->isVisible();
		}
	}
	
	}void Menuci::setAllwaysOnTop(bool AllwaysOnTop)
{
	highlight->setAlwaysOnTop(AllwaysOnTop);
	Menu->setAlwaysOnTop(AllwaysOnTop);
	curseur->setAlwaysOnTop(AllwaysOnTop);
}
#include "Namuh_Main_H.h"using namespace Ogre;void createSphere(const std::string& strName, const float r, const int nRings, const int nSegments)
 {
     ManualObject * manual = sys0.mgr->createManualObject(strName);
     manual->begin("BaseWhiteNoLighting", RenderOperation::OT_TRIANGLE_LIST);
 
     float fDeltaRingAngle = (Math::PI / nRings);
     float fDeltaSegAngle = (2 * Math::PI / nSegments);
     unsigned short wVerticeIndex = 0 ;
 
     // Generate the group of rings for the sphere
     for( int ring = 0; ring <= nRings; ring++ ) {
         float r0 = r * sinf (ring * fDeltaRingAngle);
         float y0 = r * cosf (ring * fDeltaRingAngle);
 
         // Generate the group of segments for the current ring
         for(int seg = 0; seg <= nSegments; seg++) {
             float x0 = r0 * sinf(seg * fDeltaSegAngle);
             float z0 = r0 * cosf(seg * fDeltaSegAngle);
 
             // Add one vertex to the strip which makes up the sphere
             manual->position( x0, y0, z0);
             manual->normal(Vector3(x0, y0, z0).normalisedCopy());
             manual->textureCoord((float) seg / (float) nSegments, (float) ring / (float) nRings);
 
             if (ring != nRings) {
                 // each vertex (except the last) has six indicies pointing to it
                 manual->index(wVerticeIndex + nSegments + 1);
                 manual->index(wVerticeIndex);               
                 manual->index(wVerticeIndex + nSegments);
                 manual->index(wVerticeIndex + nSegments + 1);
                 manual->index(wVerticeIndex + 1);
                 manual->index(wVerticeIndex);
                 wVerticeIndex ++;
                 }
         }; // end for seg
     } // end for ring
     manual->end();
     MeshPtr mesh = manual->convertToMesh(strName);
     mesh->_setBounds( AxisAlignedBox( Vector3(-r, -r, -r), Vector3(r, r, r) ), false );
 
     mesh->_setBoundingSphereRadius(r);
        unsigned short src, dest;
        if (!mesh->suggestTangentVectorBuildParams(VES_TANGENT, src, dest))
        {
                  mesh->buildTangentVectors(VES_TANGENT, src, dest);
        }
 }
#include "Namuh_Main_H.h"using namespace Ogre;
Ogre::String Debug_Text = "";
 Root *Ogre_ini::mRoot;
 OIS::Keyboard *Ogre_ini::mKeyboard;
 OIS::Mouse *Ogre_ini::mMouse;
 OIS::InputManager *Ogre_ini::mInputManager;
 ExitListener *Ogre_ini::mListener;
 Ogre::String Ogre_ini::secName, Ogre_ini::typeName, Ogre_ini::archName;
 ConfigFile Ogre_ini::cf;
 Ogre::RenderSystem *Ogre_ini::rs;
 SceneManager *Ogre_ini::mgr;
 Camera* Ogre_ini::cam;
 Viewport* Ogre_ini::vp;
 size_t Ogre_ini::windowHnd;
 std::ostringstream Ogre_ini::windowHndStr;
 OIS::ParamList Ogre_ini::pl;
 RenderWindow *Ogre_ini::win;
 const OIS::MouseState *Ogre_ini::ms;
 ShadowCameraSetupPtr Ogre_ini::mPSSMSetup;
 Timer Ogre_ini::timer;
 Ogre::RenderTarget *Ogre_ini::RefractionRenderTarget;
 bool Ogre_ini::last_mousebouttons_state[8];
 float Ogre_ini::ScreenSizeRatio;
 string Ogre_ini::windowName;Ogre_ini::Ogre_ini(void)
{
	srand ( time(NULL) );
	#ifndef _DEBUG 
		 mRoot = new Root("plugins.cfg","display.cfg","log.txt");
	#endif
	#ifdef _DEBUG 
		 mRoot = new Root("plugins_d.cfg","display.cfg","log.txt");
	#endif
	LogManager::getSingleton().setLogDetail(LL_BOREME);
	cf.load("resources.cfg");
    ConfigFile::SectionIterator seci = cf.getSectionIterator();
    while (seci.hasMoreElements())
    {
        secName = seci.peekNextKey();
        ConfigFile::SettingsMultiMap *settings = seci.getNext();
        ConfigFile::SettingsMultiMap::iterator i;
        for (i = settings->begin(); i != settings->end(); ++i)
        {
            typeName = i->first;
            archName = i->second;
            ResourceGroupManager::getSingleton().addResourceLocation(archName, typeName, secName);
        }
    }
    if (!mRoot->restoreConfig() && !mRoot->showConfigDialog())
    //if (!mRoot->showConfigDialog()) // pour afficher a chaque fois la fenetre de configuration
    {
        //uniquement si probleme
        RenderSystem *rs = mRoot->getRenderSystemByName("OpenGL Rendering Subsystem");
                                          // mais aussi "Direct3D9 Rendering Subsystem"
        mRoot->setRenderSystem(rs);
        rs->setConfigOption("Full Screen", "No");
        rs->setConfigOption("Video Mode", "800 x 600 @ 32-bit colour");
    }
	windowName =  "Namuh - " + BuildDate;    mRoot->initialise(true,windowName); //true pour initialisation auprès de l'OS auto
	timer.reset();
    TextureManager::getSingleton().setDefaultNumMipmaps(5);
    ResourceGroupManager::getSingleton().initialiseAllResourceGroups();
	
	mgr = mRoot->createSceneManager("TerrainSceneManager");
	Map.terrain = OGRE_NEW Ogre::Terrain(sys0.mgr);
    cam = mgr->createCamera("Camera");
    vp = mRoot->getAutoCreatedWindow()->addViewport(cam);
	//vp->setBackgroundColour(ColourValue(0.265,0.422,0.703)); // bleu clair
	vp->setBackgroundColour(ColourValue(0,0,0)); // noir
	ScreenSizeRatio = vp->getActualWidth() / vp->getActualHeight();
    cam->setAspectRatio(Real(vp->getActualWidth()) / Real(vp->getActualHeight()));
    cam->setNearClipDistance(0.3f);
	cam->setLodBias(3);
	//mRoot->getRenderTarget(windowName)->setAutoUpdated(false);	//cam->setPolygonMode(Ogre::PolygonMode::PM_WIREFRAME);
	
	/*
	// What is that ?
	TexturePtr tex = TextureManager::getSingleton().createManual("refraction" ,ResourceGroupManager::DEFAULT_RESOURCE_GROUP_NAME, TEX_TYPE_2D, 1024, 1024, 0, PF_R8G8B8, TU_RENDERTARGET);
	RefractionRenderTarget = tex->getBuffer()->getRenderTarget();
	RefractionRenderTarget->addViewport(cam)->setOverlaysEnabled(false);
	RefractionRenderTarget->setAutoUpdated(false);
	RefractionRenderTarget->getViewport(0)->setCamera(cam);
	RefractionRenderTarget->getViewport(0)->setAutoUpdated(true);
	*/
	
    size_t windowHnd = 0;
    std::ostringstream windowHndStr;
    OIS::ParamList pl;
    win = mRoot->getAutoCreatedWindow();
    win->getCustomAttribute("WINDOW", &windowHnd);
    windowHndStr << windowHnd;
    pl.insert(std::make_pair(std::string("WINDOW"), windowHndStr.str()));
	/*
	pl.insert(std::make_pair(std::string("w32_mouse"), std::string("DISCL_FOREGROUND" )));
	pl.insert(std::make_pair(std::string("w32_mouse"), std::string("DISCL_NONEXCLUSIVE")));
	pl.insert(std::make_pair(std::string("w32_keyboard"), std::string("DISCL_FOREGROUND")));
	pl.insert(std::make_pair(std::string("w32_keyboard"), std::string("DISCL_NONEXCLUSIVE")));
	*/
    mInputManager = OIS::InputManager::createInputSystem(pl);
    mKeyboard = static_cast<OIS::Keyboard*>(mInputManager->createInputObject(OIS::OISKeyboard, true));
    mMouse = static_cast<OIS::Mouse*>(mInputManager->createInputObject(OIS::OISMouse, true));
	ms = &mMouse->getMouseState();
	ms->width = vp->getActualWidth();
	ms->height = vp->getActualHeight();	CompositorManager::getSingleton().initialise();
	Ogre::CompositorManager& compMgr = Ogre::CompositorManager::getSingleton();
	
	//compMgr.registerCompositorLogic("HDR", new HDRLogic);	
	//CompositorManager::getSingleton().addCompositor(vp,"HDR",-1);
	//CompositorManager::getSingleton().setCompositorEnabled(vp,"HDR", true);
	//CompositorManager::getSingleton().addCompositor(vp,"Bloom",-1);
	//CompositorManager::getSingleton().setCompositorEnabled(vp,"Bloom", true);
	//CompositorManager::getSingleton().addCompositor(vp,"Contrast",-1);
	//CompositorManager::getSingleton().setCompositorEnabled(vp,"Contrast", true); 
	//CompositorManager::getSingleton().addCompositor(vp,"ASCII",-1);
	//CompositorManager::getSingleton().setCompositorEnabled(vp,"ASCII", true);	// Technique des ombres
	mgr->setShadowTechnique( SHADOWTYPE_NONE); 
	/*
	mgr->setShadowTechnique( SHADOWTYPE_TEXTURE_MODULATIVE_INTEGRATED); 
	mgr->setShadowFarDistance(1200);
	mgr->setShadowTextureCountPerLightType(Ogre::Light::LT_DIRECTIONAL, 3);
	PSSMShadowCameraSetup* pssmSetup = new PSSMShadowCameraSetup();
	pssmSetup->setSplitPadding(cam->getNearClipDistance());
	pssmSetup->calculateSplitPoints(3, cam->getNearClipDistance(),1200);
	pssmSetup->setOptimalAdjustFactor(0, 2);
	pssmSetup->setOptimalAdjustFactor(1, 1);
  	pssmSetup->setOptimalAdjustFactor(2, 0.5);
    mPSSMSetup.bind(pssmSetup);
    mgr->setShadowCameraSetup(mPSSMSetup);
	mgr->setShadowTextureCount(3);
	mgr->setShadowTextureConfig(0, 1024, 1024, PF_L8);
	mgr->setShadowTextureConfig(1, 256, 256, PF_L8);
	mgr->setShadowTextureConfig(2,  64,  64, PF_L8);
	mgr->setShadowTextureSelfShadow(true);
	mgr->setShadowCasterRenderBackFaces(false);*/
	//mgr->setShadowTextureCasterMaterial(StringUtil::BLANK);	//Anisotropie
	MaterialManager::getSingleton().setDefaultTextureFiltering(TFO_ANISOTROPIC);
	MaterialManager::getSingleton().setDefaultAnisotropy(1);
		// Initialise CEGUI
	ldbg.send("Initialising CEGUI...");
	Gui_manager::mRenderer = &CEGUI::OgreRenderer::bootstrapSystem();
	Gui_manager::sys = &CEGUI::System::getSingleton();
	Gui_manager::winMgr = &CEGUI::WindowManager::getSingleton();	CEGUI::Imageset::setDefaultResourceGroup("Imagesets");
	CEGUI::Font::setDefaultResourceGroup("Fonts");
	CEGUI::Scheme::setDefaultResourceGroup("Schemes");
	CEGUI::WidgetLookManager::setDefaultResourceGroup("LookNFeel");
	CEGUI::WindowManager::setDefaultResourceGroup("Layouts"); 
	CEGUI::SchemeManager::getSingleton().create("TaharezLook.scheme");
	CEGUI::SchemeManager::getSingleton().create("GlossySerpent.scheme");
	Gui_manager::sys->setDefaultMouseCursor("TaharezLook", "MouseArrow");
	CEGUI::MouseCursor::getSingleton().setImage(Gui_manager::sys->getDefaultMouseCursor());
	ldbg.send("CEGUI sucessfully initialised");
	ldbg.send("Ogre sucessfully initialised");
}void Ogre_ini::update_SmartMouse()
{
	for(int t=0;t<7;t++)	
		last_mousebouttons_state[t] = ms->buttonDown(OIS::MouseButtonID(t));
}bool Ogre_ini::ms_pressing(char button_ID)
{
	return !last_mousebouttons_state[button_ID] &&  ms->buttonDown(OIS::MouseButtonID(button_ID));
}
bool Ogre_ini::ms_releasing(char button_ID)
{
	return last_mousebouttons_state[button_ID] &&  !ms->buttonDown(OIS::MouseButtonID(button_ID));
}Ogre_ini sys0;#include "Namuh_Main_H.h"using namespace Ogre;
Paged_geometry_mgr Paged_man;
// Code des méthodes de la classe
Paged_geometry_mgr::Paged_geometry_mgr(void)
{
	initialised = false;
}
Paged_geometry_mgr::~Paged_geometry_mgr(void)
{
}void Paged_geometry_mgr::initialise(bool PhysX)
{	if( !initialised && BoolFromName(Map.MapDataPool,"Vegetation_Enabled"))
	{
		initialised = true;		sys1.logmsg("[Paged Manager] Initialistation reached");		std::vector<int> Vegetation_object_Indexes = SubPoolsIndexesFromName(Map.MapDataPool,"Vegetation object pager");
		uint Nb_Vegetation_object = Vegetation_object_Indexes.size();
		float World_Horisontal_Size = FloatFromName(Map.MapDataPool,"World_Horisontal_Size");		for(uint i=0;i<Nb_Vegetation_object;i++)
		{
			ldbg.send("(Paged Manager) Loading Vegetation object n°"+StringConverter::toString(i+1)+" of " +StringConverter::toString(Nb_Vegetation_object));
			PagedGeometry *Vegetation_object = new PagedGeometry(sys0.cam, FloatFromName(Map.MapDataPool.SubPool[Vegetation_object_Indexes[i]],"Page_Size"));
			Geom_Pager.push_back(Vegetation_object);						
			Vegetation_object->setInfinite();			Vegetation_object->addDetailLevel<WindBatchPage>(FloatFromName(Map.MapDataPool.SubPool[Vegetation_object_Indexes[i]],"Baches_Distance"),FloatFromName(Map.MapDataPool.SubPool[Vegetation_object_Indexes[i]],"Baches_FadingDistance"));
			Vegetation_object->addDetailLevel<ImpostorPage>(FloatFromName(Map.MapDataPool.SubPool[Vegetation_object_Indexes[i]],"Impostor_Distance"),FloatFromName(Map.MapDataPool.SubPool[Vegetation_object_Indexes[i]],"Impostor_FadingDistance"));
			
			//Vegetation_object_loader = new TreeLoader3D(Vegetation_object, TBounds(0, 0, Map.World_Horisontal_Size, Map.World_Horisontal_Size));
			Vegetation_object_loader = new TreeLoader2D(Vegetation_object, TBounds(0, 0, World_Horisontal_Size, World_Horisontal_Size));
			Vegetation_object_loader->setHeightFunction(&terrain_height); // need a terrain height funtion
			Vegetation_object->setPageLoader(Vegetation_object_loader);
			Forests::ImpostorPage::setImpostorResolution(IntFromName(Map.MapDataPool.SubPool[Vegetation_object_Indexes[i]],"Impostor_Resolution"));  
			//Forests::ImpostorPage::setImpostorPivot(Ogre::BillboardOrigin::BBO_BOTTOM_CENTER);
			//Vegetation_object_loader->setColorMap("Tex.png"); A voir si on veux implémenter			//Load entities
			std::vector<Ogre::Entity*> Local_Entity_list; // On ajoute une sous liste au tableau des entités visuelles
				Entity_list.push_back(Local_Entity_list);
			std::vector<NxOgre::Mesh*> Local_PhysX_Mesh_list; // On ajoute une sous liste au tableau des maillages physiques
				PhysX_Mesh_list.push_back(Local_PhysX_Mesh_list);
			std::vector<std::pair<float, float>>	Local_RndScl_Lst;			std::vector<int> Vegetation_object_entity_Indexes = SubPoolsIndexesFromName(Map.MapDataPool.SubPool[Vegetation_object_Indexes[i]],"Entity");
			size_t Nb_Vegetation_object_entity = Vegetation_object_entity_Indexes.size();			for (uint j=0;j<Nb_Vegetation_object_entity;j++)
			{
				// Ogre loading of mesh
				Entity *Object = sys0.mgr->createEntity("VegetationObj"+StringConverter::toString(i)+"Entity"+StringConverter::toString(j),StringFromName(Map.MapDataPool.SubPool[Vegetation_object_Indexes[i]].SubPool[Vegetation_object_entity_Indexes[j]],"Visual_FileName"));
				Entity_list[i].push_back(Object);
				// PhysX loading
				NxOgre::Mesh* Object_NxMesh = NxOgre::MeshManager::getSingleton()->load("ogre://General/"+StringFromName(Map.MapDataPool.SubPool[Vegetation_object_Indexes[i]].SubPool[Vegetation_object_entity_Indexes[j]],"PhysX_FileName"));
				PhysX_Mesh_list[i].push_back(Object_NxMesh);
				// Wind parameter
				Vegetation_object->setCustomParam(Entity_list[i][j]->getName(), "windFactorX", FloatFromName(Map.MapDataPool.SubPool[Vegetation_object_Indexes[i]].SubPool[Vegetation_object_entity_Indexes[j]],"windFactorX"));
				Vegetation_object->setCustomParam(Entity_list[i][j]->getName(), "windFactorY", FloatFromName(Map.MapDataPool.SubPool[Vegetation_object_Indexes[i]].SubPool[Vegetation_object_entity_Indexes[j]],"windFactorY"));
				
				
				//  ==== Random scale parameter ====
				float	minScl = 0.00000001f, // min values for min and max scales
						maxScl = 0.00001f;
			
				// Strictly positive Scale 
				if (minScl < FloatFromName(Map.MapDataPool.SubPool[Vegetation_object_Indexes[i]].SubPool[Vegetation_object_entity_Indexes[j]],"RandomScale_MinValue"))
					minScl = FloatFromName(Map.MapDataPool.SubPool[Vegetation_object_Indexes[i]].SubPool[Vegetation_object_entity_Indexes[j]],"RandomScale_MinValue");					
				if (maxScl < FloatFromName(Map.MapDataPool.SubPool[Vegetation_object_Indexes[i]].SubPool[Vegetation_object_entity_Indexes[j]],"RandomScale_MaxValue"))
					maxScl = FloatFromName(Map.MapDataPool.SubPool[Vegetation_object_Indexes[i]].SubPool[Vegetation_object_entity_Indexes[j]],"RandomScale_MaxValue");
			
				// Default min and max to 1
				if (-1 == FloatFromName(Map.MapDataPool.SubPool[Vegetation_object_Indexes[i]].SubPool[Vegetation_object_entity_Indexes[j]],"RandomScale_MinValue"))
					minScl = 1;
				if (-1 == FloatFromName(Map.MapDataPool.SubPool[Vegetation_object_Indexes[i]].SubPool[Vegetation_object_entity_Indexes[j]],"RandomScale_MaxValue"))
					maxScl = 1;				if (maxScl < minScl)	minScl = maxScl;				if (minScl != maxScl || maxScl != 1)
					Local_RndScl_Lst.push_back(std::pair<float, float>(minScl, maxScl));
				else
					Local_RndScl_Lst.push_back(std::pair<float, float>(-1, -1));  // Do not scale			}
			
			//Randomly place some objects on the cliffs or at the specified altitude
			size_t	Object_Count = IntFromName(Map.MapDataPool.SubPool[Vegetation_object_Indexes[i]],"Object_Count");
			float	RandomPosition_Y_minDelta = 	FloatFromName(Map.MapDataPool.SubPool[Vegetation_object_Indexes[i]],"RandomPosition_Y_minDelta"),
					RandomPosition_Y_MaxDelta =		FloatFromName(Map.MapDataPool.SubPool[Vegetation_object_Indexes[i]],"RandomPosition_Y_MaxDelta"),
					RandomPosition_Y_LowerBound =	FloatFromName(Map.MapDataPool.SubPool[Vegetation_object_Indexes[i]],"RandomPosition_Y_LowerBound"),
					RandomPosition_Y_UpperBound  =	FloatFromName(Map.MapDataPool.SubPool[Vegetation_object_Indexes[i]],"RandomPosition_Y_UpperBound");			// WARING : pas d'acces aux dataPools sur une boucle autant utilisée (acces aux datapools très lent)
			for (uint r = 0; r < Object_Count;)
			{
				float fyaw =Math::RangeRandom(0, 360);
				yaw = Degree(fyaw);				position.x = Math::RangeRandom(0, World_Horisontal_Size);
				position.z = Math::RangeRandom(0, World_Horisontal_Size);
				position.y = terrain_height(position.x, position.z,0);
				float delta_y = pow((terrain_height(position.x-10, position.z+10,0) - terrain_height(position.x+10, position.z-10,0)),2)
								+pow((terrain_height(position.x+10, position.z-10,0) - terrain_height(position.x-10, position.z+10,0)),2);				// on vérifie que delta_y appartient a [RandomPosition_Y_minDelta;RandomPosition_Y_MaxDelta]
				// et que position.y appartient a [RandomPosition_Y_LowerBound;RandomPosition_Y_UpperBound]
				if(	RandomPosition_Y_minDelta < delta_y 
					&& delta_y < RandomPosition_Y_MaxDelta
					&& RandomPosition_Y_LowerBound < position.y 
					&& position.y < RandomPosition_Y_UpperBound)
				{
					float rnd = Math::RangeRandom(0,Nb_Vegetation_object_entity); // prend une entité au hasard
					for(uint j=0;j<Nb_Vegetation_object_entity;j++)  // sorte de switch automatisé
						if (j< rnd && rnd < j+1)
						{		
							NxOgre::Mesh* Object_NxMesh_scaled;
							float	fscale;							if (Local_RndScl_Lst[j].first != -1)
							{	
								fscale = Math::RangeRandom(Local_RndScl_Lst[j].first, Local_RndScl_Lst[j].second);	//pas inférieur a 1, ca bug =_=  (12/08/13 : Ca n'a pas l'air)
								scale = fscale;								if(PhysX)
								{
									// mise a l'échelle du maillaige physique, attention, opération longue
									NxOgre::ManualMesh m = PhysX_Mesh_list[i][j]->getMeshData();
									for(unsigned int k=0;k < m.nbVertices();k++)
										m.scaleVertex(k, NxOgre::Vec3(fscale,fscale,fscale) );
									Object_NxMesh_scaled = m.end();
									m.clean();
								}
								else 
									Object_NxMesh_scaled = PhysX_Mesh_list[i][j];
								
							}
							else
							{
								fscale = scale = 1;
								Object_NxMesh_scaled = PhysX_Mesh_list[i][j];
							}
							Vegetation_object_loader->addTree(Entity_list[i][j], position, yaw, scale);
							
							if(PhysX)
							{								
								NxOgre::Quat quat = NxOgre::Quat(NxOgre::Math::cos(fyaw*3.14/360), 0, NxOgre::Math::sin(fyaw*3.14/360), 0);
								quat.normalise();
								NxOgre::Matrix44 mat = NxOgre::Matrix44( NxOgre::Vec3(position.x, position.y, position.z) ,quat);
								PhysX_man.mScene->createSceneGeometry( NxOgre::TriangleGeometryDescription(Object_NxMesh_scaled) ,mat);
							}
							
							r++;
						} 		
				}
			}
		}		std::vector<int> Vegetation_image_Indexes = SubPoolsIndexesFromName(Map.MapDataPool,"Vegetation image pager");
		size_t Nb_Vegetation_image = Vegetation_image_Indexes.size();		for(uint i=0;i<Nb_Vegetation_image;i++)
		{
			ldbg.send("(Paged Manager) Loading Vegetation image n°"+StringConverter::toString(i+1)+" of " +StringConverter::toString(Nb_Vegetation_image));
			PagedGeometry *Vegetation_image = new PagedGeometry(sys0.cam, FloatFromName(Map.MapDataPool.SubPool[Vegetation_image_Indexes[i]],"Page_Size"));
			Geom_Pager.push_back(Vegetation_image);
			Vegetation_image->addDetailLevel<GrassPage>(FloatFromName(Map.MapDataPool.SubPool[Vegetation_image_Indexes[i]],"Distance"),FloatFromName(Map.MapDataPool.SubPool[Vegetation_image_Indexes[i]],"FadeDistance"));
			Vegetation_image_loader = new GrassLoader(Vegetation_image);
			Vegetation_image->setPageLoader(Vegetation_image_loader);	//Assign the "treeLoader" to be used to load geometry for the PagedGeometry instance
			Vegetation_image_loader->setHeightFunction(&terrain_height); // grass need a terrain height funtion			l = Vegetation_image_loader->addLayer(StringFromName(Map.MapDataPool.SubPool[Vegetation_image_Indexes[i]],"Material_Name"));
			l->setMinimumSize(FloatFromName(Map.MapDataPool.SubPool[Vegetation_image_Indexes[i]],"Size_min"), FloatFromName(Map.MapDataPool.SubPool[Vegetation_image_Indexes[i]],"Size_min"));
			l->setMaximumSize(FloatFromName(Map.MapDataPool.SubPool[Vegetation_image_Indexes[i]],"Size_Max"), FloatFromName(Map.MapDataPool.SubPool[Vegetation_image_Indexes[i]],"Size_Max"));
			l->setAnimationEnabled(true);		//Enable animations
			l->setSwayDistribution(FloatFromName(Map.MapDataPool.SubPool[Vegetation_image_Indexes[i]],"Sway_Distribution"));		//Sway fairly unsynchronized
			l->setSwayLength(FloatFromName(Map.MapDataPool.SubPool[Vegetation_image_Indexes[i]],"Sway_Length"));				//Sway back and forth 0.5 units in length
			l->setSwaySpeed(FloatFromName(Map.MapDataPool.SubPool[Vegetation_image_Indexes[i]],"Sway_Speed"));				//Sway 1/2 a cycle every second
			l->setDensity(FloatFromName(Map.MapDataPool.SubPool[Vegetation_image_Indexes[i]],"Density"));				//Relatively dense grass 
			if(IntFromName(Map.MapDataPool.SubPool[Vegetation_image_Indexes[i]],"RenderTechnique") == 0)
				l->setRenderTechnique(Forests::GRASSTECH_QUAD);
			if(IntFromName(Map.MapDataPool.SubPool[Vegetation_image_Indexes[i]],"RenderTechnique") == 1)
				l->setRenderTechnique(Forests::GRASSTECH_CROSSQUADS);
			if(IntFromName(Map.MapDataPool.SubPool[Vegetation_image_Indexes[i]],"RenderTechnique") == 2)
				l->setRenderTechnique(Forests::GRASSTECH_SPRITE);
			l->setFadeTechnique(FADETECH_GROW);	//Distant grass should slowly raise out of the ground when coming in range
			if(StringFromName(Map.MapDataPool.SubPool[Vegetation_image_Indexes[i]],"ColorMap") != "None")
				l->setColorMap(StringFromName(Map.MapDataPool.SubPool[Vegetation_image_Indexes[i]],"ColorMap"));
			l->setDensityMap(StringFromName(Map.MapDataPool.SubPool[Vegetation_image_Indexes[i]],"DensityMap"));
			l->setMapBounds(TBounds(0, 0, FloatFromName(Map.MapDataPool,"World_Horisontal_Size"), FloatFromName(Map.MapDataPool,"World_Horisontal_Size"))); // to scale density and color texture to terrain size
			l->setLightingEnabled(true);
		}
			
		ldbg.send("(Paged Manager) Updating Paged instances");
		for(uint i=0;i<(Nb_Vegetation_object+Nb_Vegetation_image);i++)
			Geom_Pager[i]->update();
		ldbg.send("(Paged Manager) Intialisation Complete"); 
	}
}void Paged_geometry_mgr::update(void)
{
	std::vector<int> Vegetation_object_Indexes = SubPoolsIndexesFromName(Map.MapDataPool,"Vegetation object pager");
	uint Nb_Vegetation_object = Vegetation_object_Indexes.size();
	std::vector<int> Vegetation_image_Indexes = SubPoolsIndexesFromName(Map.MapDataPool,"Vegetation image pager");
	uint Nb_Vegetation_image = Vegetation_image_Indexes.size();	if(BoolFromName(Map.MapDataPool,"Vegetation_Enabled"))
		for(uint i=0;i<(Nb_Vegetation_object+Nb_Vegetation_image);i++)
			Geom_Pager[i]->update();
	//rocks_paged->update();
}void Paged_geometry_mgr::destroy(void)
{
	std::vector<int> Vegetation_object_Indexes = SubPoolsIndexesFromName(Map.MapDataPool,"Vegetation object pager");
	uint Nb_Vegetation_object = Vegetation_object_Indexes.size();
	std::vector<int> Vegetation_image_Indexes = SubPoolsIndexesFromName(Map.MapDataPool,"Vegetation image pager");
	uint Nb_Vegetation_image = Vegetation_image_Indexes.size();	if(BoolFromName(Map.MapDataPool,"Vegetation_Enabled"))
	{
		ldbg.send(" Stating Paged geometry unloader ");
		for(uint i=0;i<(Nb_Vegetation_object+Nb_Vegetation_image);i++)
		{
			Geom_Pager[i]->removeDetailLevels();
			delete Geom_Pager[i]->getPageLoader();
			//delete Geom_Pager[i];
		}		//delete rocks_paged->getPageLoader();
		//delete rocks_paged;
		ldbg.send(" rocks_paged unloaded ");
	}
}
/*ldbg.send("File "+ string(__FILE__) +" passed line n°"+ StringConverter::toString(__LINE__)); // Debug =================================*/
#include "Namuh_Main_H.h"using namespace Ogre;
Gui_sandbox_manager GuiSandboxMan; // Un jour faudra le mettre en tant que membre de partie// Code des méthodes de la classe
Partie::Partie(PartieArg args)
{
	Net_Partie_Status = args.Net_Status;
	isSandBox = args.isSandbox;
	Perso::cam_sync = raknet_man.peer->GetGuidFromSystemAddress(RakNet::UNASSIGNED_SYSTEM_ADDRESS); // On met la camera dans le joueur local
	bouclecount = 0;
	lastDebugTextUpdateTimeStamp = 0;
	lastHydraxUpdateTimeStamp = 0;
	lastHydraxRTTUpdateTimeStamp = 0;	gametime = 0;
	inv_FPS = -1;
	string MapName = args.Mapfile;
	if(ldbg.initialised) // enlève le ldbg si déja initalisé ailleurs.
		ldbg.disable();
	if(isSandBox)
		GuiSandboxMan.Initialise();
	else
		GuiFPSMan.Initialise();
	if(Net_Partie_Status == Partie_Server)
	{
		raknet_man.InitialiseAsServer(&gametime);
		raknet_man.map = MapName;
	}
	if(Net_Partie_Status == Partie_Client)
	{
		ldbg.send("Connecting to server");
		raknet_man.InitialiseAsClient(&gametime, args.IPofSrv);
		ldbg.send("Connexion initialised, waiting for server datas.");
		// Attente de réponse du serveur, pour savoir quelle map charger
		float timestamp = sys0.timer.getMilliseconds();
		while(raknet_man.map == "")
		{
			raknet_man.update(1/60);
			if(timestamp + 30000 < sys0.timer.getMilliseconds())
			{
				
				ldbg.send("Connexion failed, will load default map.");
				raknet_man.map = "Maps/Chutes Bresiliennes/Chutes Bresiliennes.map";
			}
		}
		if(timestamp + 30000 < sys0.timer.getMilliseconds())
				ldbg.send("Connexion sucessful, map recieved.");
		MapName = raknet_man.map;
		ldbg.send("Loading map : " + MapName);
	}	Map.load(MapName);
	ldbg.send("Terrain loaded sucessfully");
	Hydrax_man.initialise();
	if(Net_Partie_Status != Partie_Server)
	{
		Atm_man.initialise();
		ldbg.send("Atmophere manager loaded sucessfully");
	}
	PhysX_man.initialise();
	ldbg.send("PhysX loaded sucessfully");
	if(isSandBox)
	{
		Constructeur.intitalise();
		ldbg.send("Sandbox_constructeur initialised sucessfully");
	}
	ldbg.send("First part loaded sucessfully");
	if(Net_Partie_Status != Partie_Server)
	{
		Map.terrain->dirtyLightmap(); //a faire au moins une fois quand meme
		//sys0.RefractionRenderTarget->update(); // Pareil
	}
	Map.terrain->update();
	for (	std::map<RakNet::RakNetGUID, Perso*>::iterator PlayerIterator = PlayerList.begin();
			PlayerIterator != PlayerList.end();
			PlayerIterator++)
	{
		ldbg.send("Initialising/spawning player ID_"+raknet_man.GUIDtoString(PlayerIterator->first));		PlayerIterator->second->initialise();
		PlayerIterator->second->spawn(Vector3FromName(Map.MapDataPool,"Spawn_Position")+Ogre::Vector3(Math::RangeRandom(-5,5),0,Math::RangeRandom(-5,5)),true); // Messy spawn point TODO : make team spawn area
	}
	
	if(Net_Partie_Status == Partie_Server)
		local_player.OrientationInput = Ogre::Vector3(0,90-local_player.rot.getPitch().valueDegrees(),0); // Le serveur regarde en l'air, gain énorme de FPS
	ldbg.send("loading Paged geometry ");
	//Paged_man.initialise(Net_Partie_Status != Partie_Client); // normalement c'est ca (authoritative srv)
	Paged_man.initialise(false); // pour test
	ldbg.send("Paged geometry loaded sucessfully");
	if(Net_Partie_Status != Partie_Server)
	{
		ldbg.send("Loading Amnesic Faune "); 
		Amnesic_Faune_man.initialise(); 
		ldbg.send("Amnesic Faune Loaded sucessfully");
	}
	ldbg.send("Loading Faune "); Faune_man.initialise(); ldbg.send("Faune Loaded sucessfully");
	if(!isSandBox)Ruler.initialise();	ldbg.Flows["FPS"] = &inv_FPS;
	ldbg.Graphs["FPS"].YDatas["FPS"].setRange_CenterLastValue(true,0.05f);
	ldbg.Graphs["FPS"].YDatas["FPS"].AutoKeepOrigin = false;
	ldbg.graph("FPS","FPS");	ldbg.Flows["posX"] = &(PlayerList.begin()->second->pos.x);
	ldbg.Flows["posZ"] = &(PlayerList.begin()->second->pos.z);
	ldbg.Graphs["miniMap"].XFlowConnexions["posZ"] = "posZ";
	ldbg.Graphs["miniMap"].YFlowConnexions["posX"] = "posX";
	ldbg.Graphs["miniMap"].posY = 0.025f + (ldbg.Graphs["miniMap"].sizeY +0.005f) * (ldbg.Graphs.size()-1);	ldbg.Flows["LightDir"] = &(Atm_man.lightDir.y);
	ldbg.Flows["PosY"] = &(PlayerList.begin()->second->pos.y);
	ldbg.graph("PosY","PosY");
	ldbg.send("Loading static geometry"); 
	/*	TODO : Implement contruction rotation	Entity* Grotte = sys0.mgr->createEntity("Grotte","Grotte.mesh");
	SceneNode* Grotte_n = sys0.mgr->getRootSceneNode()->createChildSceneNode();
	Grotte_n->attachObject(Grotte);
	Grotte_n->setPosition(100,44,100);	
	CstrMgr.Load("Estrade Menu principal.nmh",Ogre::Vector3(115,45,115)); ////////////===============
	
	CstrMgr.LoadedConstructions.back()->Rotate(Ogre::Quaternion(Ogre::Radian(3.14/2),Ogre::Vector3(0,1,0)));  ////////////===============
	*/}
void Partie::update(void)
{
	//ldbg.UpdateGrantedGraphes();											// Slow tool, use it only when required
	sys1.Watch_LoopStart = sys0.timer.getMilliseconds();
	inv_FPS = 1/sys1.FPS;	
	if(isSandBox)
	{
		if(lastDebugTextUpdateTimeStamp + 500 < sys1.Watch_LoopStart)
		{
			GuiSandboxMan.UpdateDebugtext();
			lastDebugTextUpdateTimeStamp = sys1.Watch_LoopStart;
		}
		GuiSandboxMan.Update(inv_FPS);
		GuiSandboxMan.UpdateSandbox(inv_FPS);
		Constructeur.update();
	}
	else
	{
		GuiFPSMan.UpdateStats();
		GuiFPSMan.Update(inv_FPS);
		GuiFPSMan.UpdateFPS_UI(inv_FPS);
		Ruler.update();
	}
	if(Net_Partie_Status != Partie_Locale) raknet_man.update(inv_FPS);
	sys1.Watch_UI = sys0.timer.getMilliseconds() - sys1.Watch_LoopStart;
	PhysX_man.update(inv_FPS);
	sys1.Watch_PhysX = sys0.timer.getMilliseconds() - sys1.Watch_LoopStart;	for (	std::map<RakNet::RakNetGUID, Perso*>::iterator PlayerIterator = PlayerList.begin();
			PlayerIterator != PlayerList.end();
			PlayerIterator++)
		if(isSandBox && GuiSandboxMan.cameravolanteswitch) // Fly si sandbox
			PlayerIterator->second->update(inv_FPS,Mvt_Fly,Net_Partie_Status == Partie_Client); // Manual Fire only for client
		else
			PlayerIterator->second->update(inv_FPS,Mvt_Normal,Net_Partie_Status == Partie_Client); // Manual Fire only for client
	Faune_man.update(inv_FPS,local_player.pos);	if(Net_Partie_Status != Partie_Server)
	{
		Amnesic_Faune_man.update(inv_FPS,Ogre::Vector2(local_player.pos.x,local_player.pos.z));
		Atm_man.update(inv_FPS);
			sys1.Watch_Atm = sys0.timer.getMilliseconds()- sys1.Watch_LoopStart;
			
			sys1.Watch_Hydrax = sys0.timer.getMilliseconds()- sys1.Watch_LoopStart;
		Map.terrain->update();
		//Map.terrain->dirtyLightmap(); // a déplacer pour n'etre éffectué que quand
			sys1.Watch_Terrain = sys0.timer.getMilliseconds()- sys1.Watch_LoopStart;
		Paged_man.update();
			sys1.Watch_PagedGeometry = sys0.timer.getMilliseconds()- sys1.Watch_LoopStart;
	}	// ============================================================================================================================
	/// Render routine (detached to enable separate control of render targets, like the hydrax one)
	sys1.update(inv_FPS, false);// update system
	if(Net_Partie_Status != Partie_Server && lastHydraxUpdateTimeStamp + 50 < sys1.Watch_LoopStart) // Hydrax update caped to 10 FPS
	{
		Hydrax_man.update(0.05f);			
		lastHydraxUpdateTimeStamp = sys0.timer.getMilliseconds();
	}
	if(Net_Partie_Status != Partie_Server && lastHydraxRTTUpdateTimeStamp + 500 < sys1.Watch_LoopStart) // Hydrax update caped to 10 FPS
	{
		if(Hydrax_man.initialised)
			Hydrax_man.mHydrax->updateOnlyRTT(0.0f);
		lastHydraxRTTUpdateTimeStamp = sys0.timer.getMilliseconds();
	}
	sys0.mRoot->getRenderTarget(sys0.windowName)->update(false);
	// give client app opportunity to use queued GPU time
	sys0.mRoot->_fireFrameRenderingQueued();
	// block for final swap
	sys0.mRoot->getRenderSystem()->_swapAllRenderTargetBuffers(sys0.mRoot->getRenderSystem()->getWaitForVerticalBlank());
	sys0.mRoot->getRenderTarget(sys0.windowName)->swapBuffers(sys0.mRoot->getRenderSystem()->getWaitForVerticalBlank());
    // This belongs here, as all render targets must be updated before events are
    // triggered, otherwise targets could be mismatched.  This could produce artifacts,
    // for instance, with shadows.
    for (SceneManagerEnumerator::SceneManagerIterator it = sys0.mRoot->getSceneManagerIterator(); it.hasMoreElements(); it.moveNext())
        it.peekNextValue()->_handleLodEvents();
	sys0.mRoot->_fireFrameEnded();
	/// End of render routine
	// ============================================================================================================================
	sys1.Watch_Sys1 = sys0.timer.getMilliseconds() - sys1.Watch_LoopStart;
	sys1.Watch_LoopEnd = sys0.timer.getMilliseconds();
	sys1.giveWaches();
	gametime += sys1.Watch_LoopEnd - sys1.Watch_LoopStart;
}
Partie::~Partie(void)
{
	
	ldbg.send("Destroying Ruler");
	Ruler.destroy();
	ldbg.send("Destroying Partie");
	GuiSandboxMan.Destroy();
sys1.logmsg("*** Debug flag reached (n°1) ***");
//	Hydrax_man.destroy();sys1.logmsg("*** Debug flag reached (n°2) ***");
	Atm_man.destroy();
sys1.logmsg("*** Debug flag reached (n°3) ***");
	PhysX_man.destroy();
sys1.logmsg("*** Debug flag reached (n°4) ***");
	if(isSandBox)Constructeur.destroy();
sys1.logmsg("*** Debug flag reached (n°5) ***");
	local_player.destroy();
sys1.logmsg("*** Debug flag reached (n°6) ***");
	//Paged_man.destroy();
sys1.logmsg("*** Debug flag reached (n°7) ***");
	Map.unload();
	ldbg.send("Partie Destroyed");
}
#include "Namuh_Main_H.h"
/*ldbg.send("File "+ string(__FILE__) +" passed line n°"+ StringConverter::toString(__LINE__)); // Debug =================================*/
using namespace Ogre;// Définition du joueur local
std::map<RakNet::RakNetGUID, Perso*> PlayerList; // et de la liste des joueurs
std::map<RakNet::RakNetGUID, KeyState> KeyPlayer; // et de leurs claviers// Définition des membres statiques
RakNet::RakNetGUID Perso::cam_sync = RakNet::UNASSIGNED_RAKNET_GUID;
raknet_mgr raknet_man;
Perso local_player(raknet_man.local_GUID);// Code des méthodes de la classe
Perso::Perso(RakNet::RakNetGUID ID)
{
	ldbg.send("Declaration of Perso ID_"+raknet_man.GUIDtoString(ID));
	initialised = false;
	id = ID;
	PlayerList[ID] = this;
	KeyState new_keystate;
	KeyPlayer[ID] =  new_keystate;
	Ruler.PointList[ID] = 10;
	raknet_man.AdPlayer.push_back(raknet_man.peer->GetSystemAddressFromGuid(ID));
}
Perso::~Perso(void)
{
	ldbg.send("Destruction of Perso ID_"+raknet_man.GUIDtoString(id));
	PlayerList.erase(id);
	KeyPlayer.erase(id);
	Ruler.PointList.erase(id);
}void Perso::initialise(void) // Déplacement
{	if(!initialised)
	{
		// Initialisation Ogre
		Node = PhysX_man.mRenderSystem->createNode(); // Neud racine du personnage
		Mesh_n = Node->createChildSceneNode(); // Neud du perso
		CamNode = Node->createChildSceneNode(); // neud de la caméra
		if(cam_sync == id)
		{
			sys0.cam->detachFromParent();
			CamNode->attachObject(sys0.cam);
		}
		else
		{
			mesh = sys0.mgr->createEntity("Sapiens" + StringConverter::toString(sys0.timer.getMilliseconds()),"Sapiens_01.mesh"); //maillage du perso
			Mesh_n = Node->createChildSceneNode(); // Neud du perso
			Mesh_n->attachObject(mesh);
			Mesh_n->setOrientation(Quaternion(Ogre::Radian(3.14f),Ogre::Vector3(0.0f,1.0f,0.0f)));
			Mesh_n->setPosition(0.0f,-1.18f,0.25f);
			Mesh_n->scale(0.78f,0.78f,0.78f);
		}		// Initialisation PhysX
		PhysXDescription.mCollisionMask = 1;
		PhysXDescription.mSlopeLimit = 0.7f;
		PhysXDescription.mMaxGroundSpeed = 10.0f;
		PhysXDescription.mStepOffset = 0.5;
		PhysXDescription.mShape = NxOgre::SimpleCapsule(1.6f, 0.31f);
		PhysXDescription.setJumpVelocityFromMaxHeight(NxOgre::Constants::MEAN_EARTH_GRAVITY.y, 0.5f);
		character = PhysX_man.mRenderSystem->createAnimatedCharacter(Vector3(0,0,0), Ogre::Radian(0.0f), Node, PhysXDescription);
		CharCtrl = reinterpret_cast<NxOgre::CharacterController*>(character);
		InputHelper = new Critter::CharacterInputHelper();
		Last_movetime = -1;
		LinearVelocity = Ogre::Vector3::ZERO;
		Acceleration = Ogre::Vector3::ZERO;
		UpdateOrientationOrPosition = false;		// Initialisation des Armes
			// Lance Pierre
			Lance_Pierre_Actuel.initialise(id);
			Inventory.push_back(&Lance_Pierre_Actuel);
			Lance_Pierre_Actuel.WeaponNode->setVisible(true);
			// Arc
			Arc_En_Bois_Actuel.initialise(id);
			Inventory.push_back(&Arc_En_Bois_Actuel);
			Arc_En_Bois_Actuel.WeaponNode->setVisible(false);
			// Javelot
			Javelot_Actuel.initialise(id);
			Inventory.push_back(&Javelot_Actuel);
			Javelot_Actuel.WeaponNode->setVisible(false);
		Current_Weapon = Inventory[0]; // On commence avec le lance pierre en main
		Last_Damage_Owner_id = 	RakNet::UNASSIGNED_RAKNET_GUID;		// Initialistion des caractéristiques
		movespeed = 0.3f;
		MotionInput = Ogre::Vector4::ZERO;
		OrientationInput = Ogre::Vector3::ZERO;
		JumpInput = false;
		FireInput = false;
		initialised = true;
	}
	else
		ldbg.send("Tried to intialise player n°" + raknet_man.GUIDtoString(id) + " ,which is already initialised. Skipping...");
}void Perso::spawn(Vector3 temp, bool urgent) // Repositionnement
{
	// RAZ de la santé, et on redevient temporairement invincible (1sec)
	Spawning_invicinbility_time = sys0.timer.getMilliseconds()-2000;
	invincible = true;
	vie = 100;
	if(cam_sync == id)GuiSandboxMan.Affichage_vie.set(vie);
		// RAZ armes
	Last_Damage_Owner_id = RakNet::UNASSIGNED_RAKNET_GUID;
	//RAZ cinématique
	pos = temp;
	lastpos = temp;
	LastLinearVelocity = Ogre::Vector3::ZERO;
	LinearVelocity = Ogre::Vector3::ZERO;
	Acceleration = Ogre::Vector3::ZERO;
	MotionInput = Ogre::Vector4::ZERO;
	OrientationInput = Ogre::Vector3::ZERO;
	JumpInput = false;
	FireInput = false;
	// téléport
	InputHelper->reset();
	character->setInput(*InputHelper);
	character->setPosition(temp);
	CharCtrl->setPosition(temp);
	Node->setPosition(temp);
	character->setUsesGravity(false);
	if(urgent) PhysX_man.update(10000); // plein de temps
	UpdateOrientationOrPosition = false;
	update(100000,Mvt_DisableFallDamage); // encore plein de temps
	UpdateOrientationOrPosition = false;
	Last_movetime = -1;
}void Perso::update(float TimeEllapsed, Perso_Mvt_flag MovingMode, bool ManualFire )
{
	//Gestion de l'invincibilité
	if(invincible && Spawning_invicinbility_time + 3000 < sys0.timer.getMilliseconds())
	{
		invincible = false;
		ldbg.send("Tu n'es plus invincible, prout !",false); 
	}	// Déplacement volant ?
	if(MovingMode == Mvt_Fly)
	{
		if(Current_Weapon != NULL && Current_Weapon->WeaponNode != NULL)
			Current_Weapon->WeaponNode->setVisible(false);		// Compute dispalcement
		Ogre::Vector3 mTranslateVector = Ogre::Vector3::ZERO;
		if(MotionInput.x != 0) mTranslateVector.z -= 1; //Ogre::Math::Cos(rot.getPitch().valueRadians());
		if(MotionInput.y != 0) mTranslateVector.z += 1; //Ogre::Math::Cos(rot.getPitch().valueRadians());
		if(MotionInput.z != 0) mTranslateVector.x -= 1;
		if(MotionInput.w != 0) mTranslateVector.x += 1;
		mTranslateVector.y = -1*Ogre::Math::Sin(rot.getPitch().valueRadians())*mTranslateVector.z;
		mTranslateVector.normalise();
		mTranslateVector *= movespeed;
		
		// Apply displacement
		character->setUsesGravity(false);
		Node->getSceneNode()->translate(Node->getSceneNode()->getLocalAxes(),mTranslateVector);
		pos = Node->getPosition();		character->setPosition(pos);
		CharCtrl->setPosition(pos);
		Node->setPosition(pos);
	}
	else		
	{
		character->setUsesGravity(true);
		Current_Weapon->WeaponNode->setVisible(true);
	}	// TODO : Modify critter to enable it to update both per frame
	if(UpdateOrientationOrPosition) // Les deux sont impossible a faire simultanément a cause de InputHelper->input.turning_mode
	{
		// Réeoriente le personnage
		this->rotate(OrientationInput); 
		OrientationInput = Ogre::Vector3::ZERO;
	}
	else
	{
		// Déplace le personnage
		this->move(MotionInput, JumpInput, MovingMode);
		MotionInput = Ogre::Vector4::ZERO;
		JumpInput = false;		// Calculs cinématiques rustiques
		pos = Node->getPosition();
		Ogre::Real		dt = sys0.timer.getMilliseconds()-Last_movetime; // faire disparaitre les allocation realtime une fois que tout sera débuggué
		if(dt == 0.0f)dt = 0.001f; // Evite de diviser par 0, au cas ou		Ogre::Vector3	dl = pos-lastpos,
						dv = LinearVelocity-LastLinearVelocity;
		LinearVelocity	 = 1000.0f*dl/dt;
		Acceleration	 = dv/dt;		Last_movetime = sys0.timer.getMilliseconds();
		lastpos = pos;
		LastLinearVelocity = LinearVelocity;		// Dégats de chute
		if(!invincible && MovingMode != Mvt_DisableFallDamage && Acceleration.length() > 425 && (raknet_man.isServer || !raknet_man.initialised))
		{
			Last_Damage_Owner_id = RakNet::UNASSIGNED_RAKNET_GUID;
			//damage((Acceleration.length()-425)/2);
		}
	}
	UpdateOrientationOrPosition = !UpdateOrientationOrPosition;	// Le tir
	if(FireInput && !ManualFire) this->fire();
	FireInput = false;	// Gestion de l'au-dela
	if(vie <= 0)
	{
		if(Last_Damage_Owner_id != RakNet::UNASSIGNED_RAKNET_GUID)Ruler.NoticeFrag(id,Last_Damage_Owner_id);
		else Ruler.NoticeScuicide(id);
		spawn(Vector3FromName(Map.MapDataPool,"Spawn_Position"));
		ldbg.send("Mort du perso d'id " + raknet_man.GUIDtoString(id) + ", due a l'id : " + raknet_man.GUIDtoString(Last_Damage_Owner_id) ,false);
	}
}void Perso::move(Ogre::Vector4 KeysWeights, bool Jump, Perso_Mvt_flag Mvt_Flag) // Déplacement
{
	if(Mvt_Flag != Mvt_Fly)
	{
		// Compute dispalcement
		InputHelper->input.turning_mode  = Critter::Enums::CharacterTurningMode_SideStep;
		if(KeysWeights.y != 0)InputHelper->forwardFractional(KeysWeights.y); // ces if sont la car faire un backwardFractional(0.0f) invalide le forwardFractional
		if(KeysWeights.x != 0)InputHelper->backwardFractional(KeysWeights.x); 
		if(KeysWeights.z != 0)InputHelper->leftFractional(KeysWeights.z);
		if(KeysWeights.w != 0)InputHelper->rightFractional(KeysWeights.w);
		if(Jump)InputHelper->up(Jump);		// Apply displacement
		character->setInput(*InputHelper);
		InputHelper->reset();
		Node->setPosition(CharCtrl->getPosition());
	}
}void Perso::setpos(Ogre::Vector3 temp) // Repositionnement
{
	//RAZ cinématique
	pos = temp;
	lastpos = temp;
	LastLinearVelocity = Ogre::Vector3::ZERO;
	LinearVelocity = Ogre::Vector3::ZERO;
	Acceleration = Ogre::Vector3::ZERO;
	MotionInput = Ogre::Vector4::ZERO;
	OrientationInput = Ogre::Vector3::ZERO;
	JumpInput = false;
	FireInput = false;
	// téléport
	InputHelper->reset();
	character->setInput(*InputHelper);
	character->setPosition(temp);
	CharCtrl->setPosition(temp);
	Node->setPosition(temp);
	UpdateOrientationOrPosition = false;
	update(100000,Mvt_DisableFallDamage); // encore plein de temps
	UpdateOrientationOrPosition = false;
	Last_movetime = -1;
}void Perso::sethealth(int new_vie) // Modifier la vie
{
	vie = new_vie;
	if(vie<0)vie=0;
	if(Perso::cam_sync == id) GuiSandboxMan.Affichage_vie.set(vie);
}void Perso::damage(int amount) // Infliger des dégats au joueur
{
	if(!invincible && (raknet_man.isServer || !raknet_man.initialised))
	{
		ldbg.send("degat subit par l'id " + raknet_man.GUIDtoString(id) + ", due a l'id : " + raknet_man.GUIDtoString(Last_Damage_Owner_id) + "montant : " + StringConverter::toString(amount) ,false);
		sethealth(vie - amount);
	}
}void Perso::rotate(Ogre::Vector3 requested_rotation) // Rotation Relative
{
	last_rot_vect = rot_vect;	// Ogre handle vertical orientation
	rot	= rot * Quaternion(Degree(requested_rotation.y), Ogre::Vector3::UNIT_X);
    CamNode->setOrientation(rot);	// PhysX handle horisontal orientation
	InputHelper->input.turning_mode  = Critter::Enums::CharacterTurningMode_Add;
	InputHelper->input.left_right = requested_rotation.x;
	character->setInput(*InputHelper);
	InputHelper->reset();	//Calculs cinématiques
	Ogre::Real		 dt = sys0.timer.getMilliseconds()-Last_rotatetime;
	Ogre::Vector3	 da = rot_vect-last_rot_vect;
	rotative_velocity	= requested_rotation/dt;
	Last_rotatetime = sys0.timer.getMilliseconds();
}void Perso::setOrientation(Ogre::Vector3 requested_rotation) // Rotation Absolue (to merge ?)
{
	// Ogre handle vertical orientation
	rot	= Quaternion(Degree(requested_rotation.y), Ogre::Vector3::UNIT_X);
    CamNode->setOrientation(rot);
		
	// PhysX handle horisontal orientation
	InputHelper->input.turning_mode  = Critter::Enums::CharacterTurningMode_Set;
	InputHelper->input.left_right = requested_rotation.x;
	character->setInput(*InputHelper);
	InputHelper->reset();
}void Perso::fire()
{
	Current_Weapon->fire();
	if(raknet_man.isServer)
	{
		RakNet::BitStream bsOut;		
		bsOut.Write((RakNet::MessageID)StC_TIR);
		bsOut.Write(id); // le -1 vient du fait que le local_player du serv ne compte pas dans la liste des joueurs
		raknet_man.peer->Send(&bsOut,IMMEDIATE_PRIORITY,RELIABLE,0,RakNet::UNASSIGNED_SYSTEM_ADDRESS,true);	
	}
}void Perso::destroy()
{
ldbg.send("File "+ string(__FILE__) +" passed line n°"+ StringConverter::toString(__LINE__)); // Debug =================================
	//Mesh_n->removeAndDestroyAllChildren();
ldbg.send("File "+ string(__FILE__) +" passed line n°"+ StringConverter::toString(__LINE__)); // Debug =================================
	//CamNode->removeAllChildren();
ldbg.send("File "+ string(__FILE__) +" passed line n°"+ StringConverter::toString(__LINE__)); // Debug =================================
	//Arme_n->removeAndDestroyAllChildren();
ldbg.send("File "+ string(__FILE__) +" passed line n°"+ StringConverter::toString(__LINE__)); // Debug =================================
	//Node->removeEntity();
ldbg.send("File "+ string(__FILE__) +" passed line n°"+ StringConverter::toString(__LINE__)); // Debug =================================
	initialised = false;
}
void Perso::SwichWeapon(uchar NewWeaponIndex,bool NoticeNewtork)
{
	// Montre la nouvelle arme
	Current_Weapon->WeaponNode->setVisible(false);
	Current_Weapon = Inventory[NewWeaponIndex];
	Current_Weapon->WeaponNode->setVisible(true);	//  si on est client d'une partie, on en averti le serveur
	if(raknet_man.mClient.initialised && NoticeNewtork) 
	{
		ldbg.send("Sending network notification for weapon switch : "+ StringConverter::toString(char(NewWeaponIndex)));
		RakNet::BitStream bsOut;
		bsOut.Write((RakNet::MessageID)CtS_WEAPONSWITCH);
		bsOut.Write(char(NewWeaponIndex));
		raknet_man.peer->Send(&bsOut,HIGH_PRIORITY,RELIABLE_SEQUENCED,0,RakNet::UNASSIGNED_SYSTEM_ADDRESS,true);
	}
}#include "Namuh_Main_H.h"using namespace Ogre;
PhysX_mgr PhysX_man;
//extern Hydrax_mgr Hydrax_man;
// Code des méthodes de la classe
PhysX_mgr::PhysX_mgr(void)
{
	initialised = false;
}
PhysX_mgr::~PhysX_mgr(void)
{
}void PhysX_mgr::initialise(void)
{
	if(!initialised)
	{
		initialised = true;		mWorld = NxOgre::World::createWorld();
		mWorld->getRemoteDebugger()->connect();
		NxOgre::ResourceSystem::getSingleton()->openProtocol(new Critter::OgreResourceProtocol());
		// Enable CCD via the World. Normally this is off by default in PhysX. So we have to switch it on.
		mWorld->setCCDEnabled(true);
	  		//scene description
		scndesc.mGravity = NxOgre::Constants::MEAN_EARTH_GRAVITY;
		scndesc.mUseHardware = false;
		// Create scene
		mScene = mWorld->createScene(scndesc);		// Set some physical scene values
		mScene->getMaterial(0)->setStaticFriction(0.5f);
		mScene->getMaterial(0)->setDynamicFriction(0.5f);
		mScene->getMaterial(0)->setRestitution(0.1f);
		// Create the rendersystem.
		mRenderSystem = new Critter::RenderSystem(mScene, sys0.mgr);
		// Create the Visual Debugger
		/*
		ldbg.send("(PhysX Manager) Creating Visual debugger");
		NxOgre::VisualDebuggerDescription desc;
		desc.showLight();
		desc.mWorld.axes = true;
		desc.mCollision.AABB = true; // Axis Aligned Bounding Box
		desc.mCollision.shapes = false; //  /!\ TRES TRES LENT SI TRUE
		desc.mCollision.axes= true;
		desc.mJoint.worldAxes = true;
		desc.mJoint.limits = true;
		NxOgre::VisualDebugger debugger(mWorld);
		debugger.enable();
		debugger.loadFromDescription(desc);
		mRenderSystem->createVisualDebugger(desc);
		ldbg.send("(PhysX Manager) Visual debugger created");
		ldbg.send("(PhysX Manager) Visual debugger : shapes : "+ StringConverter::toString(desc.mCollision.shapes));
		*/
		
		// Load Terrain heightfield
		loadTerrainGeometry(Map.terrain->getMaterialName(), Map.terrain->getHeightData(), Map.terrain->getSize(),Map.terrain->getWorldSize(), Map.terrain->getMinHeight(), Map.terrain->getMaxHeight(), Map.terrain->getPosition());		PhysX_Waterfall_man.make();
		/*
		mCube = mRenderSystem->createBody(NxOgre::BoxDescription(2.925, 2.925, 2.925), NxOgre::Vec3(-9+225,38.2,-42.74+225), "Cube.mesh");
		mCube2 = mRenderSystem->createBody(NxOgre::BoxDescription(2.925, 2.925, 2.925), NxOgre::Vec3(-9+225,42,-41.84+225), "Cube.mesh");
		mCube3 = mRenderSystem->createBody(NxOgre::BoxDescription(2.925, 2.925, 2.925), NxOgre::Vec3(-9+225,44,-41.84+225), "Cube.mesh");
		
		PhysXfloater.add(mCube);
		PhysXfloater.add(mCube2);
		PhysXfloater.add(mCube3);		// Création d'un radeau a quille
		RocherMesh = NxOgre::MeshManager::getSingleton()->load("ogre://General/Rocher.nxs");
		RocherMesh->setName("Quille du radeau");
		
		Critter::BodyDescription QuilleActorDescription;
		QuilleActorDescription.mMass = 2000.0f;
		//QuilleActorDescription.mLinearDamping = 1.02f;  
		//QuilleActorDescription.mAngularDamping = 1.02f; // Maxi intertie
		//Quille = mRenderSystem->createBody(new NxOgre::Box(2.925, 2.925, 2.925), NxOgre::Vec3(125,32.5,260), "Cube.mesh", QuilleActorDescription);
		Quille = mRenderSystem->createBody(NxOgre::ConvexDescription(RocherMesh),NxOgre::Vec3(125,73.7,260), "rocher.mesh",QuilleActorDescription);
		Quille->setSolverIterationCount(100);
		NxOgre::Mesh* convexMesh = NxOgre::MeshManager::getSingleton()->load("ogre://General/Objects/Radeau_base/Radeau_base.nxs");
		convexMesh->setName("Maillage du radeau de la base");
		Critter::BodyDescription RadeauActorDescription;
		RadeauActorDescription.mMass = 25525.0f; 
		RadeauActorDescription.mLinearDamping = 0.002f;  
		RadeauActorDescription.mAngularDamping = 0.002f; // Petite intertie
		Critter::Body* Radeau = mRenderSystem->createBody(NxOgre::ConvexDescription(convexMesh), NxOgre::Vec3(125,72.2,260), "Radeau_base.mesh", RadeauActorDescription);
		Radeau->setSolverIterationCount(100);
		NxOgre::FixedJoint* Joint = mScene->createFixedJoint(Radeau,Quille);
		Joint->setBreakable(8000000.0f,8000000.0f); // casse si on lance un ménhir de très près 
		PhysXfloater.add(Radeau);
		NxOgre::Mesh* MenhirMesh = NxOgre::MeshManager::getSingleton()->load("ogre://General/Objects/Menhir/Menhir.nxs");
		MenhirMesh->setName("Maillaige du menhir");
		Menhirdescription.mMass = 5850.0f;
		Menhirdescription.mLinearDamping = 0.02f;  
		Menhirdescription.mAngularDamping = 0.01f;
		*/
		// Créatin du petit caillou du lance pierre
		Cailloux = NxOgre::MeshManager::getSingleton()->load("ogre://General/Rocher.nxs");
		
		// Scale du projectile par 0.05
		NxOgre::ManualMesh m(Cailloux->getMeshData());
		for (unsigned int i=0;i < m.nbVertices();i++)
		m.scaleVertex(i, NxOgre::Vec3(0.05f,0.05f,0.05f) );
		Cailloux = m.end();
		m.clean();
		Cailloux->setName("Petit cailloux du Lance Pierre");
				
		CstrMgr.RocherMesh = NxOgre::MeshManager::getSingleton()->load("ogre://General/Objects/Rocher/Rocher.nxs");
		/*
		Vector2 Tourelle_pos(124,261);
		NxOgre::Mesh* Tourelle_mesh = NxOgre::MeshManager::getSingleton()->load("ogre://General/Objects/Tourelle/Tourelle.nxs");
		Tourelle_mesh->setName("Ze tourelle");*/
		/*
			// Scale de la tourlle, par 0.7
			NxOgre::ManualMesh m2 = NxOgre::ManualMesh(Tourelle_mesh->getMeshData());
			for (unsigned int i=0;i < m2.nbVertices();i++)
				m2.scaleVertex(i, NxOgre::Vec3(0.7,0.7,0.7) );
			Tourelle_mesh = m2.end();
			m2.clean();*/
		// Définition dela matrice de position et d'orientation de la tourelle
	/*	NxOgre::Quat quat = NxOgre::Quat(NxOgre::Math::cos(3.14/4), 0, NxOgre::Math::sin(3.14/4), 0); // les angles sont ici au facteur 0.5
		quat.normalise();
		NxOgre::Matrix44 mat = NxOgre::Matrix44(
				NxOgre::Vec3(Tourelle_pos.x,terrain_height(Tourelle_pos.x, Tourelle_pos.y,0), Tourelle_pos.y),
				quat);
		mScene->createSceneGeometry(NxOgre::TriangleGeometryDescription(Tourelle_mesh),mat);
		Entity* Tourelle = sys0.mgr->createEntity("Tourelle","Tourelle.mesh");
		SceneNode* Tourelle_n = sys0.mgr->getRootSceneNode()->createChildSceneNode();
		Tourelle_n->attachObject(Tourelle);
		// memes tranformations a l'entité visuelle
		Tourelle_n->setPosition(Tourelle_pos.x,terrain_height(Tourelle_pos.x, Tourelle_pos.y,0), Tourelle_pos.y);
		Tourelle_n->yaw(Radian(3.141/2));
		//Tourelle_n->scale(0.7,0.7,0.7);
	*/	/*
		//création d'un piaf 
		Entity* piaf = sys0.mgr->createEntity("Sapiens test","Sapiens_01.mesh");
		SceneNode* piaf_n = sys0.mgr->getRootSceneNode()->createChildSceneNode();
		piaf_n->attachObject(piaf);
		piaf_n->setPosition(Tourelle_pos.x,terrain_height(Tourelle_pos.x, Tourelle_pos.y,0), Tourelle_pos.y);
		piaf_n->scale(5,5,5);
		// set up a 20 second animation for our light, using spline interpolation for nice curves
		Animation* anim = sys0.mgr->createAnimation("LightTrack", 20);
		anim->setInterpolationMode(Animation::IM_SPLINE);		// create a track to animate the camera's node
		NodeAnimationTrack* track = anim->createNodeTrack(0, piaf_n);		// create keyframes for our track
		track->createNodeKeyFrame(0)->setTranslate(Vector3(142, 77, 342));
		track->createNodeKeyFrame(2)->setTranslate(Vector3(121, 84, 335));
		track->createNodeKeyFrame(4)->setTranslate(Vector3(121, 91, 314));
		track->createNodeKeyFrame(6)->setTranslate(Vector3(156, 70, 328));
		track->createNodeKeyFrame(8)->setTranslate(Vector3(128, 70, 356));
		track->createNodeKeyFrame(10)->setTranslate(Vector3(114, 63, 328));
		track->createNodeKeyFrame(12)->setTranslate(Vector3(114, 56, 328));
		track->createNodeKeyFrame(14)->setTranslate(Vector3(100, 35, 384));
		track->createNodeKeyFrame(16)->setTranslate(Vector3(114, 35, 314));
		track->createNodeKeyFrame(18)->setTranslate(Vector3(135, 84, 300));
		track->createNodeKeyFrame(20)->setTranslate(Vector3(142, 77, 342));		piaf_n->setPosition(track->getNodeKeyFrame(0)->getTranslate());		// create a new animation state to track this
		mLightAnimState = sys0.mgr->createAnimationState("LightTrack");
		mLightAnimState->setEnabled(true);
		// fin du piaf		// grotte
		NxOgre::Mesh* Petite_Grotte_mesh = NxOgre::MeshManager::getSingleton()->load("ogre://General/Objects/Petite Grotte/Petite Grotte.nxs");
		mScene->createSceneGeometry(NxOgre::TriangleGeometryDescription(Petite_Grotte_mesh), NxOgre::Matrix44(NxOgre::Vec3(114.8+225,6.7,-121.49+225)));
		Entity* Petite_Grotte = sys0.mgr->createEntity("Grotte","Petite Grotte.mesh");
		SceneNode* Petite_Grotte_n = sys0.mgr->getRootSceneNode()->createChildSceneNode();
		Petite_Grotte_n->attachObject(Petite_Grotte);
		Petite_Grotte_n->setPosition(114.8+225,6.7,-121.49+225);*/
	}
}void PhysX_mgr::update(float ellapsed_time)
{
	//mLightAnimState->addTime(ellapsed_time); 
	PhysXfloater.update(ellapsed_time); // Met a jour la physique ainsi que la flotabilité des objets}
	// Gestion de la destruction des projectiles en fin de vie
	for (	std::map<RakNet::RakNetGUID, Perso*>::iterator PlayerIterator = PlayerList.begin();
			PlayerIterator != PlayerList.end();
			PlayerIterator++)		
		for (uint j=0;j<PlayerIterator->second->Inventory.size();j++)
			for (uint k=0;k<PlayerIterator->second->Inventory[j]->ProjectileList.size();k++)
				if (PlayerIterator->second->Inventory[j]->ProjectileList[k].Date_Fired + 8000 < sys0.timer.getMilliseconds()
					&& PlayerIterator->second->Inventory[j]->ProjectileList[k].CanDamage)
				{
					 //sys0.mgr->destroySceneNode(PlayerIterator->second->Inventory[j]->ProjectileList[k].body->getNode()->getSceneNode()); // Aww, buggy
					 mRenderSystem->destroyBody(PlayerIterator->second->Inventory[j]->ProjectileList[k].body);
					 PlayerIterator->second->Inventory[j]->ProjectileList[k].CanDamage = false;
				}	mWorld->advance(ellapsed_time);
}void PhysX_mgr::destroy(void)
{
/*
	NxOgre::MeshManager::MeshIterator mIterator = NxOgre::MeshManager::getSingleton()->getMeshes(); 
	NxOgre::MeshManager::MeshIterator mIterator2 = NxOgre::MeshManager::getSingleton()->getMeshes(); 	int i =0;
	while(mIterator2 != mIterator.end())
	{
		sys1.logmsg("*** Debug flag reached ("+string(mIterator2->getName())+") ***");
		mIterator2++;
		i++;
	}
	sys1.logmsg("*** Iterator flag reached ( Il y a jusqu'au n°"+ StringConverter::toString(i) +" meshes) ***");	while(mIterator != mIterator.end())
	{
		sys1.logmsg("*** Debug flag reached ("+string(mIterator->getName())+") ***");
		NxOgre::MeshManager::getSingleton()->unload(mIterator->getName());
		mIterator++;
		i++;
	}	sys1.logmsg("*** Debug flag reached (n°BBB) ***");
	*/
	delete mRenderSystem;
	NxOgre::World::destroyWorld();
	sys0.mgr->destroyAllEntities();
	sys0.mgr->destroyAllAnimations();
	sys0.mgr->destroyAllAnimationStates();
	sys0.mgr->getRootSceneNode()->removeAllChildren();
	PhysXfloater.flush();	initialised = false;
}#include "Namuh_Main_H.h"using namespace Ogre;//extern Hydrax::Hydrax *mHydrax;PhysX_Raft PhysXfloater;
PhysX_Raft::PhysX_Raft(void)
{
	int last_mesh = 0,waterheight = -3.5;
	Critter::Body* list[5000] = {NULL};
};
PhysX_Raft::~PhysX_Raft(void){};void PhysX_Raft::add(Critter::Body* new_raft)
{
	list[last_mesh] = new_raft;
	last_mesh++;
};void PhysX_Raft::remove(Critter::Body* raft)
{
	for(int i =0;i<last_mesh;i++)
		if(list[i] == raft)
			list[i] = NULL;
};void PhysX_Raft::flush(void)
{
	last_mesh = 0;waterheight = -6.5;
	for(int i =0;i<5000;i++)
	{
		if(list[i] != NULL)
		{
			list[i] = NULL;
		}
	}
};void PhysX_Raft::update(float deltatime)
{
	if(Hydrax_man.initialised)
	{
		if(list[0] != NULL) // TODO : Get an efficient way to access this data at 10fps for each floating object
			waterheight = Hydrax_man.mHydrax->getHeigth(Vector2(list[0]->getGlobalPosition().x,list[0]->getGlobalPosition().z)); //update this only when required		for(int i =0;i<last_mesh;i++)
			if(list[i] != NULL)
			{
				if(list[i]->getNode()->getPosition().y<waterheight)
				{
				// Frottements
				list[i]->setLinearVelocity(Vector3((0.97)*list[i]->getLinearVelocity().x *Ogre::Math::Exp(-0.02/(Ogre::Math::Abs(list[i]->getLinearVelocity().x)+1) ),
												   (0.97)*list[i]->getLinearVelocity().y *Ogre::Math::Exp(-0.02/(Ogre::Math::Abs( list[i]->getLinearVelocity().y)+1) ),
												   (0.97)*list[i]->getLinearVelocity().z *Ogre::Math::Exp(-0.02/(Ogre::Math::Abs( list[i]->getLinearVelocity().z)+1) ) ));				list[i]->setAngularVelocity(Vector3((0.97)*list[i]->getAngularVelocity().x *Ogre::Math::Exp(-0.02/(Ogre::Math::Abs(list[i]->getAngularVelocity().x)+1) ),
													(0.97)*list[i]->getAngularVelocity().y *Ogre::Math::Exp(-0.02/(Ogre::Math::Abs( list[i]->getAngularVelocity().y)+1) ),
													(0.97)*list[i]->getAngularVelocity().z *Ogre::Math::Exp(-0.02/(Ogre::Math::Abs( list[i]->getAngularVelocity().z)+1) ) ));
							// Flotabilité des cubes (valeur multipilé ensuite par l'écart entre la surface et l'objet)
					float y =   (9.8f * list[i]->getMass());						  // counteract gravity
	//					 + (-list[i]->getLinearVelocity().y * list[i]->getMass() * list[i]->getMass())    // slowly counteract vertical velocity
	//					 + ((waterheight-list[i]->getNode()->getPosition().y)/40 * list[i]->getMass()); // add some force to move it to the top
									list[i]->addForce(NxOgre::Vec3(0,y*2*(waterheight-list[i]->getNode()->getPosition().y),0), NxOgre::Enums::ForceMode_Force); 
					list[i]->addForce(NxOgre::Vec3(Math::RangeRandom(-100.1f,100.1f)/1000.0f* list[i]->getMass()*9.8, 0, Math::RangeRandom(-100.1f,100.1f)/1000.0f* list[i]->getMass())*9.8f,NxOgre::Enums::ForceMode_Force); 
				
				
				}
			}
		}
};#include "Namuh_Main_H.h"using namespace Ogre;//extern Hydrax_mgr Hydrax_man;PhysX_Waterfall PhysX_Waterfall_man;
PhysX_Waterfall:: PhysX_Waterfall(void){};
PhysX_Waterfall::~PhysX_Waterfall(void){};void PhysX_Waterfall::make(void)
{	sys1.logmsg("[PhysX Manager] Fluids Initialistation reached");
	std::vector<int> Fluid_object_Indexes = SubPoolsIndexesFromName(Map.MapDataPool,"Fluid");
	uint Nb_Fluid_object = Fluid_object_Indexes.size();	for(uint i=0;i<Nb_Fluid_object;i++)
	{
		
		NxOgre::FluidDescription Fluid_desc;
		NxOgre::FluidEmitterDescription Emiter_desc;		Fluid_desc.mMaxParticles =					IntFromName(Map.MapDataPool.SubPool[Fluid_object_Indexes[i]],"MaxParticles");
		Fluid_desc.mKernelRadiusMultiplier =		FloatFromName(Map.MapDataPool.SubPool[Fluid_object_Indexes[i]],"KernelRadiusMultiplier");
		Fluid_desc.mRestParticlesPerMetre =			FloatFromName(Map.MapDataPool.SubPool[Fluid_object_Indexes[i]],"RestParticlesPerMetre");
		Fluid_desc.mMotionLimitMultiplier =			FloatFromName(Map.MapDataPool.SubPool[Fluid_object_Indexes[i]],"MotionLimitMultiplier");
		Fluid_desc.mPacketSizeMultiplier =			FloatFromName(Map.MapDataPool.SubPool[Fluid_object_Indexes[i]],"PacketSizeMultiplier");
		Fluid_desc.mCollisionDistanceMultiplier =	FloatFromName(Map.MapDataPool.SubPool[Fluid_object_Indexes[i]],"CollisionDistanceMultiplier");
		Fluid_desc.mStiffness =						FloatFromName(Map.MapDataPool.SubPool[Fluid_object_Indexes[i]],"Stiffness");
		Fluid_desc.mViscosity =						FloatFromName(Map.MapDataPool.SubPool[Fluid_object_Indexes[i]],"Viscosity");
		Fluid_desc.mRestDensity =					FloatFromName(Map.MapDataPool.SubPool[Fluid_object_Indexes[i]],"RestDensity");
		Fluid_desc.mSimulationMethod = NxOgre::Enums::FluidSimulationMethod_NoParticleInteraction;
		//Fluid_desc.mFlags |= Enums::FluidFlags_Hardware;
		//Fluid_desc.mFlags |= NxOgre::Enums::FluidFlags_DisableGravity;		NxOgre::Fluid* Fluid_Background = PhysX_man.mRenderSystem->createFluid(Fluid_desc,StringFromName(Map.MapDataPool.SubPool[Fluid_object_Indexes[i]],"Material"), Critter::Enums::FluidType_OgreParticle);
		((Critter::ParticleRenderable*)Fluid_Background->getRenderable())->getParticleSystem()->setDefaultDimensions(
																				FloatFromName(Map.MapDataPool.SubPool[Fluid_object_Indexes[i]],"ParticleSize"),
																				FloatFromName(Map.MapDataPool.SubPool[Fluid_object_Indexes[i]],"ParticleSize"));
		((Critter::ParticleRenderable*)Fluid_Background->getRenderable())->getParticleSystem()->setRenderQueueGroup(((Critter::ParticleRenderable*)Fluid_Background->getRenderable())->getParticleSystem()->getRenderQueueGroup()+IntFromName(Map.MapDataPool.SubPool[Fluid_object_Indexes[i]],"RenderQueueGroupOffset"));		Emiter_desc.mPose.set(
			NxOgre::Matrix44(
			Vector3FromName(Map.MapDataPool.SubPool[Fluid_object_Indexes[i]],"Position"),
			NxOgre::Quat(Ogre::Math::Cos(0.2/2,false),
			NxOgre::Vec3(0,Ogre::Math::Sin(0.2/2,false),0))));
		Emiter_desc.mShape = NxOgre::Enums::FluidEmitterShape_Rectangular;
		Emiter_desc.mParticleLifetime = FloatFromName(Map.MapDataPool.SubPool[Fluid_object_Indexes[i]],"ParticleLifetime");
		Emiter_desc.mRate = FloatFromName(Map.MapDataPool.SubPool[Fluid_object_Indexes[i]],"Rate");
		Emiter_desc.mFluidSpeed = FloatFromName(Map.MapDataPool.SubPool[Fluid_object_Indexes[i]],"FluidSpeed");
		Emiter_desc.mType = NxOgre::Enums::FluidEmitterType_FlowRate;
		Emiter_desc.mReplusionCoefficient = FloatFromName(Map.MapDataPool.SubPool[Fluid_object_Indexes[i]],"ReplusionCoefficient");
		Emiter_desc.mDimensionX = Vector3FromName(Map.MapDataPool.SubPool[Fluid_object_Indexes[i]],"EmmiterSize").x;
		Emiter_desc.mDimensionY = Vector3FromName(Map.MapDataPool.SubPool[Fluid_object_Indexes[i]],"EmmiterSize").y;
		NxOgre::FluidEmitter*	Emitter_Background = Fluid_Background->createEmitter(Emiter_desc);
	}
};#include "Namuh_Main_H.h"using namespace Ogre;PlayerProfileManager ProfileMgr;// Code des méthodes de la classe
PlayerProfileManager::PlayerProfileManager(void)
{
	// Definition de la syntaxe des fichiers de profil	ProfileFileSyntax.push_back(new ParserBalise);
	ProfileFileSyntax.back()->Name = "General Info";
	ProfileFileSyntax.back()->StringKeywords.push_back("ProfileName");	ProfileFileSyntax.push_back(new ParserBalise);
	ProfileFileSyntax.back()->Name = "Game preferences";		ParserBalise FavoriteCstrLst = {"Favorite Construction List"};
		ProfileFileSyntax.back()->SousBalises.push_back(FavoriteCstrLst);			ParserBalise FavoriteCstr = {"Favorite Construction"};
			ProfileFileSyntax.back()->SousBalises.back().SousBalises.push_back(FavoriteCstr);
		
			ProfileFileSyntax.back()->SousBalises.back().SousBalises.back().StringKeywords.push_back("FileName");	ProfileFileSyntax.push_back(new ParserBalise);
	ProfileFileSyntax.back()->Name = "Misc";
	ProfileFileSyntax.back()->StringKeywords.push_back("Default_IP");
}
PlayerProfileManager::~PlayerProfileManager(void)
{
}
 PlayerProfile* PlayerProfileManager::Load(string ProfileFile)
{
	std::vector<NamedDataPool> RawConfigFile = Map_Parser.ParseFile(ProfileFileSyntax, ProfileFile);
	LoadedProfiles.push_back(new PlayerProfile);	// Retrouve l'index des pools de données
	Ogre::uint	GeneralInfoPoolIndex = -1,
				MiscPoolIndex = -1,
				GamePreferencePoolIndex = -1;
	for(Ogre::uint i = 0; i < RawConfigFile.size(); ++i)
	{
		if(RawConfigFile[i].Name == "General Info")
			GeneralInfoPoolIndex = i;
		else if (RawConfigFile[i].Name == "Game preferences")
			GamePreferencePoolIndex = i;
		else if (RawConfigFile[i].Name == "Misc")
			MiscPoolIndex = i;
	}
	if(GeneralInfoPoolIndex == -1)
	{
		ldbg.send("(PlayerProfileManager Exeption) Unable to load profile file " + ProfileFile + ". 'General Info' pool is missing. NULL will be returned.");
		return NULL;
	}
	if(GamePreferencePoolIndex == -1)
	{
		ldbg.send("(PlayerProfileManager Exeption) Unable to load profile file " + ProfileFile + ". 'Game preferences' pool is missing. NULL will be returned.");
		return NULL;
	}
	if(MiscPoolIndex == -1)
	{
		ldbg.send("(PlayerProfileManager Exeption) Unable to load profile file " + ProfileFile + ". 'Misc' pool is missing. NULL will be returned.");
		return NULL;
	}
	// Remplit le nouvel objet PlayerProfile	LoadedProfiles.back()->Name = StringFromName(RawConfigFile[GeneralInfoPoolIndex],"ProfileName");
	LoadedProfiles.back()->Default_IP = StringFromName(RawConfigFile[MiscPoolIndex],"Default_IP");
	
	Ogre::uint FavCstrLst_Indexe = SubPoolsIndexesFromName(RawConfigFile[GamePreferencePoolIndex],"Favorite Construction List").back();
	for(Ogre::uint i = 0; i < RawConfigFile[GamePreferencePoolIndex].SubPool[FavCstrLst_Indexe].SubPool.size(); ++i)
		LoadedProfiles.back()->FavoritesConstructions.push_back(StringFromName(RawConfigFile[GamePreferencePoolIndex].SubPool[FavCstrLst_Indexe].SubPool[i],"FileName"));	return LoadedProfiles.back();
}
void PlayerProfileManager::SaveAs(string ProfileFile, PlayerProfile* ProfileObject )
{	
	if(ProfileObject == NULL) ProfileObject = this->getCurrent();
	// construit les Datapools qui contiendront toutes les données a enregister
	std::vector<NamedDataPool*>Profile_data;	// General Info
	Profile_data.push_back(new NamedDataPool);
	Profile_data.back()->Name = "General Info";
		Profile_data.back()->String_Data.push_back(*(new NamedString));
		Profile_data.back()->String_Data.back().Name = "ProfileName";
		Profile_data.back()->String_Data.back().data = ProfileObject->Name;	// Game Preferences
	Profile_data.push_back(new NamedDataPool);
	Profile_data.back()->Name = "Game preferences";
		Profile_data.back()->SubPool.push_back(*(new NamedDataPool));
		Profile_data.back()->SubPool.back().Name = "Favorite Construction List";		for(Ogre::uint i = 0; i < ProfileObject->FavoritesConstructions.size(); ++i)
			{
				Profile_data.back()->SubPool.back().SubPool.push_back(*(new NamedDataPool));
				Profile_data.back()->SubPool.back().SubPool.back().Name = "Favorite Construction";					Profile_data.back()->SubPool.back().SubPool.back().String_Data.push_back(*(new NamedString));
					Profile_data.back()->SubPool.back().SubPool.back().String_Data.back().Name = "FileName";
					Profile_data.back()->SubPool.back().SubPool.back().String_Data.back().data = ProfileObject->FavoritesConstructions[i];
			}
	
	// Misc
	Profile_data.push_back(new NamedDataPool);
	Profile_data.back()->Name = "Misc";
		Profile_data.back()->String_Data.push_back(*(new NamedString));
		Profile_data.back()->String_Data.back().Name = "Default_IP";
		Profile_data.back()->String_Data.back().data = ProfileObject->Default_IP;			// Write the file
	File_Serialiser.WriteFile(Profile_data,ProfileFile);
}
void PlayerProfileManager::setCurrent(PlayerProfile* NewProfile)
{
	ProfilePath = "Players Profiles Datas/" + NewProfile->Name+"/";
	CurrentProfile = NewProfile;
}
PlayerProfile* PlayerProfileManager::getCurrent(void)
{
	return CurrentProfile;
}
void PlayerProfileManager::deleteCurrent(void)
{
	//TOFIX
	DeleteDirectory(&string("Players Profiles Datas/"+getCurrent()->Name)[0]);
}void PlayerProfileManager::CreateNew(string Name)
{
	// Crée les dossiers du profil
	CreateDirectory (&string("Players Profiles Datas/"+Name)[0], NULL);
	CreateDirectory (&string("Players Profiles Datas/"+Name+"/Constructions")[0], NULL);
	
	// Crée un fichier de configuration vierge
	PlayerProfile NewProfile;
	NewProfile.Name = Name;
	SaveAs("Players Profiles Datas/"+Name+"/MainFile.cfg", &NewProfile);
}PlayerProfile::PlayerProfile(void)
{
	Name = "Unamed Profile " + StringConverter::toString(sys0.timer.getMicroseconds());
	Default_IP = "127.0.0.1";
	// TODO : Mettre des constuction en favoris par défault (des construction préfaites)}
PlayerProfile::~PlayerProfile(void)
{
}
#include "Namuh_Main_H.h"using namespace Ogre;
// Code des méthodes de la classestd::vector<ProjCallback> ProjCallbackList;Projectile::Projectile(Perso* Requested_Owner) : Owner(Requested_Owner){}
Projectile::Projectile(void)
{
}
Projectile::~Projectile(void)
{
}
#include "Namuh_Main_H.h"using namespace Ogre;
bool OpenUPNP(RakNet::RakPeerInterface *rakPeer, RakNet::SystemAddress serverAddress);
raknet_Client::raknet_Client(void)
{
	peer = raknet_man.peer;
	connected = false;
	initialised = false;
	needupdate = true;
}void raknet_Client::Initialise(string IP,int port)
{	
	peer = raknet_man.peer;
	peer->Startup(1,&RakNet::SocketDescriptor(), 1);
	OpenUPNP(peer, RakNet::SystemAddress(&IP[0], port));
	ldbg.send("Initialising client on port : "+StringConverter::toString(port));
	ldbg.send("Trying to connect to : "+IP);
	peer->Connect(&IP[0], port, 0,0);
	initialised = true;
}void raknet_Client::update(void)
{	
	// Ne demande d'update que quand la partie est prête
	if(local_player.initialised)
		this->SendDatas(); 	// Traitement de paquets en entrée
	for (packet=peer->Receive(); packet; peer->DeallocatePacket(packet), packet=peer->Receive())
		switch (packet->data[0])
		{
			case ID_REMOTE_DISCONNECTION_NOTIFICATION:
				ldbg.send("(NetI/O Processor) Remote client disconnected.");
			break;
			case ID_REMOTE_CONNECTION_LOST:
				ldbg.send("(NetI/O Processor) Remote client lost the connection.");
			break;
			case ID_CONNECTION_ATTEMPT_FAILED:
				ldbg.send("(NetI/O Processor) Ana peut pas se connectationner au serveur :/");
			break;
			case ID_REMOTE_NEW_INCOMING_CONNECTION:
				ldbg.send("(NetI/O Processor) Remote client connected.");
			break;
			case ID_CONNECTION_REQUEST_ACCEPTED:
			{
				connected = true;
				ldbg.send("(NetI/O Processor) Connected to server");
			}
			break;
			case ID_NO_FREE_INCOMING_CONNECTIONS:
				ldbg.send("(NetI/O Processor) The server is full.");
			break;
			case ID_DISCONNECTION_NOTIFICATION:
			{
				connected = false;
				ldbg.send("(NetI/O Processor) Disconnected by server.");
			}
			break;
			case ID_CONNECTION_LOST:
			{
				connected = false;
				ldbg.send("(NetI/O Processor) Connection lost.");
			}
			break;
			case ID_REMOTE_DEBUG_MESSAGE:
				raknet_man.ProcessPacket_RemoteDebuggerMsg(packet);
			break;
			case StC_SYNC_SET_TIME:
				this->ProcessPacket_SyncClock(packet);
			break;
			case StC_GAME_MAP:
				this->ProcessPacket_MapName(packet);
			break;
			case StC_HEALTH:
				this->ProcessPacket_PlayerHealth(packet);
			break;
			case StC_PLAYER_POS:
				this->ProcessPacket_PlayerPosition(packet);
			break;
			case StC_PLAYER_ROT:
				this->ProcessPacket_PlayerOrientation(packet);
			break;
			case StC_SET_ID:
				this->ProcessPacket_SetID(packet);
			break;			
			case StC_TIR:
				this->ProcessPacket_Tir(packet);
			break;
			case StC_PLAYER_PTS:
				this->ProcessPacket_PlayerPts(packet);
			break;
			case StC_WEAPONSWITCH:
				this->ProcessPacket_WeaponSwitch(packet);
			break;
			case StC_GAME_END:
				Ruler.EndOfGame = true;
			break;
			case StC_PING:
				this->ProcessPacket_Ping(packet);
			break;
			default:
				ldbg.send("Message with identifier "+StringConverter::toString(packet->data[0])+" has arrived.\n" );
			break;
		}
}void raknet_Client::ProcessPacket_MapName(RakNet::Packet* Datas)
{
	RakNet::BitStream bsIn(Datas->data,Datas->length,false);
	bsIn.IgnoreBytes(sizeof(RakNet::MessageID));
	RakNet::RakString rs;
	bsIn.Read(rs);
	raknet_man.map = rs.C_String();
	ldbg.send("(NetI/O Processor) Recived map name : "+ raknet_man.map);
}void raknet_Client::ProcessPacket_SetID(RakNet::Packet* Datas)
{
	RakNet::BitStream bsIn(Datas->data,Datas->length,false);
	bsIn.IgnoreBytes(sizeof(RakNet::MessageID));
	RakNet::RakNetGUID newID;	// construit autant de nouveau personnage qu'il y a d'autres clients dans la partie
	bsIn.Read(newID);
	ldbg.send("Recieved new player with ID_"+raknet_man.GUIDtoString(newID));
	while (newID != RakNet::UNASSIGNED_RAKNET_GUID) // Tant qu'on ne passe pas le marqueur de fin
	{
		new Perso(newID);
		bsIn.Read(newID);
	}
}void raknet_Client::ProcessPacket_PlayerPosition(RakNet::Packet* Datas)
{	
	RakNet::BitStream bsIn(Datas->data,Datas->length,false);
	bsIn.IgnoreBytes(sizeof(RakNet::MessageID));
	Vector3 pos;
	float x,y,z;
	RakNet::RakNetGUID ID;
	bsIn.Read(ID); 
	bsIn.Read(x);
	bsIn.Read(y);
	bsIn.Read(z);
	pos = Vector3(x,y,z);
	if(PlayerList.count(ID))
		PlayerList[ID]->setpos(pos);
	else
		ldbg.send("Recieved position (" + toOgStr(pos) + ") for unknown player ID_"+raknet_man.GUIDtoString(ID));
	needupdate = true;
}void raknet_Client::ProcessPacket_PlayerOrientation(RakNet::Packet* Datas)
{
	RakNet::BitStream bsIn(Datas->data,Datas->length,false);
	bsIn.IgnoreBytes(sizeof(RakNet::MessageID));
	float angle,angle_vert;
	RakNet::RakNetGUID ID;
	bsIn.Read(ID);
	bsIn.Read(angle);
	bsIn.Read(angle_vert);
	if(PlayerList.count(ID))
		PlayerList[ID]->OrientationInput = Ogre::Vector3(angle			-PlayerList[ID]->Node->getOrientation().getYaw().valueDegrees(),
														 angle_vert		-PlayerList[ID]->rot.getPitch().valueDegrees(),
														 0);
	else
		ldbg.send("Recieved orientation  (" + toOgStr(angle) + ", " + toOgStr(angle_vert) + ")  for unknown player ID_"+raknet_man.GUIDtoString(ID));
	needupdate = true;
}void raknet_Client::ProcessPacket_Tir(RakNet::Packet* Datas)
{
	RakNet::BitStream bsIn(Datas->data,Datas->length,false);
	bsIn.IgnoreBytes(sizeof(RakNet::MessageID));
	
	RakNet::RakNetGUID ID;
	bsIn.Read(ID);
	PlayerList[ID]->fire();
}void raknet_Client::ProcessPacket_PlayerHealth(RakNet::Packet* Datas)
{
	RakNet::BitStream bsIn(Datas->data,Datas->length,false);
	bsIn.IgnoreBytes(sizeof(RakNet::MessageID));
	char vie;
	bsIn.Read(vie);
	local_player.sethealth(vie);
	needupdate = true;
}void raknet_Client::ProcessPacket_PlayerPts(RakNet::Packet* Datas)
{
	RakNet::BitStream bsIn(Datas->data,Datas->length,false);
	bsIn.IgnoreBytes(sizeof(RakNet::MessageID));
	int pts;
	RakNet::RakNetGUID ID;
	bsIn.Read(ID);
	bsIn.Read(pts);
	Ruler.PointList[ID]=float(pts)/100.0f;
}void raknet_Client::ProcessPacket_WeaponSwitch(RakNet::Packet* Datas)
{
	RakNet::BitStream bsIn(packet->data,packet->length,false);
	bsIn.IgnoreBytes(sizeof(RakNet::MessageID));
	char NewWeapon_c;
	RakNet::RakNetGUID ID;
	bsIn.Read(ID);
	bsIn.Read(NewWeapon_c);
	PlayerList[ID]->Current_Weapon->WeaponNode->setVisible(false);
	PlayerList[ID]->Current_Weapon = PlayerList[ID]->Inventory[NewWeapon_c];
	PlayerList[ID]->Current_Weapon->WeaponNode->setVisible(true);
}void raknet_Client::SendDatas(void)
{
	if(needupdate)
	{
		// Demande au serveur une MAJ
		RakNet::BitStream bsOut;
		bsOut.Write((RakNet::MessageID)CtS_UPDATE_REQUEST);
		bsOut.Write((long double)*raknet_man.gametime);
		peer->Send(&bsOut,IMMEDIATE_PRIORITY,RELIABLE,0,RakNet::UNASSIGNED_SYSTEM_ADDRESS,true);		// Envoi des infos clavier
		bsOut.Reset();
		bsOut.Write((RakNet::MessageID)CtS_KEYSTATE);
		bsOut.Write((long double)*raknet_man.gametime);
		bsOut.Write(bool(local_player.FireInput));
		bsOut.Write(bool(local_player.MotionInput.x > 0.0f));
		bsOut.Write(bool(local_player.MotionInput.y > 0.0f));
		bsOut.Write(bool(local_player.MotionInput.z > 0.0f));
		bsOut.Write(bool(local_player.MotionInput.w > 0.0f));
		bsOut.Write(bool(local_player.JumpInput));
		peer->Send(&bsOut,IMMEDIATE_PRIORITY,RELIABLE_SEQUENCED,0,RakNet::UNASSIGNED_SYSTEM_ADDRESS,true);		// Envoi de l'orientation du personnage
		bsOut.Reset();
		bsOut.Write((RakNet::MessageID)CtS_ORIENTATION);
		bsOut.Write(float(local_player.Node->getOrientation().getYaw().valueDegrees()));
		bsOut.Write(float(local_player.rot.getPitch().valueDegrees()));
		bsOut.Write(float(local_player.rotative_velocity.x));
		bsOut.Write(float(local_player.rotative_velocity.y));
		peer->Send(&bsOut,IMMEDIATE_PRIORITY,RELIABLE_SEQUENCED,0,RakNet::UNASSIGNED_SYSTEM_ADDRESS,true);
		
		needupdate = false;
	}
}void raknet_Client::ProcessPacket_SyncClock(RakNet::Packet* Datas)
{
	// Recois l'état de l'horloge serveur
	long double delta;
	RakNet::BitStream bsIn(Datas->data,Datas->length,false);
	bsIn.IgnoreBytes(sizeof(RakNet::MessageID));
	bsIn.Read(*raknet_man.gametime);
	bsIn.Read(delta);
	*raknet_man.gametime += delta/2;	// La rerenvois pour confirmation	
	RakNet::BitStream bsOut;
	bsOut.Write((RakNet::MessageID)CtS_SYNC_TIMESTAMP);
	bsOut.Write(long double(*raknet_man.gametime));
	bsOut.Write(long double(delta));
	peer->Send(&bsOut,IMMEDIATE_PRIORITY,RELIABLE_ORDERED,0,RakNet::UNASSIGNED_SYSTEM_ADDRESS,true);
}void raknet_Client::ProcessPacket_Ping(RakNet::Packet* Datas)
{
	// renvois le paquet au serveur
	RakNet::BitStream bsIn(Datas->data,Datas->length,false);
	bsIn.IgnoreBytes(sizeof(RakNet::MessageID));
	long double pingdate;
	bsIn.Read(pingdate);	RakNet::BitStream bsOut;
	bsOut.Write((RakNet::MessageID)CtS_PING);
	bsOut.Write((long double)pingdate);
	peer->Send(&bsOut,HIGH_PRIORITY,RELIABLE,0,RakNet::UNASSIGNED_SYSTEM_ADDRESS,true);
}void raknet_Client::destroy(void)
{	}
raknet_Client::~raknet_Client(void)
{
}#include "Namuh_Main_H.h"using namespace Ogre;
bool OpenUPNP(RakNet::RakPeerInterface *rakPeer, RakNet::SystemAddress serverAddress);
raknet_mgr::raknet_mgr(void)
{
	map = "";
	AdPlayer.push_back(RakNet::UNASSIGNED_SYSTEM_ADDRESS); //Le player 0 (ie local_player du serveur) n'a pas d'adresse
	peer = RakNet::RakPeerInterface::GetInstance();
	local_GUID = peer->GetGuidFromSystemAddress(RakNet::UNASSIGNED_SYSTEM_ADDRESS); // mon id local
	ldbg.send("initialising Raknet_mgr with ID_"+this->GUIDtoString(local_GUID));
	// pour les bots; on pourra leur donner un id avec Get64BitUniqueRandomNumber
}void raknet_mgr::InitialiseAsServer(long double* ptr_gametime, int port, int MaxClients)
{	
	isServer = true;
	mServer.Initialise(port,MaxClients);
	initialised = true;
	gametime = ptr_gametime;
}void raknet_mgr::InitialiseAsClient(long double* ptr_gametime, string IP, int port)
{	
	isServer = false;
	mClient.Initialise(IP,port);
	initialised = true;
	gametime = ptr_gametime;
}void raknet_mgr::update(float inv_FPS)
{	
	if(isServer) mServer.update();
	else mClient.update();
}void raknet_mgr::destroy(void)
{	}
raknet_mgr::~raknet_mgr(void)
{
		RakNet::RakPeerInterface::DestroyInstance(peer);
}string raknet_mgr::StringIDfromSystemAddress(RakNet::SystemAddress Addr)
{
	char* newstring = new char[64];
	(peer->GetGuidFromSystemAddress(Addr)).ToString(newstring);
	string ID = newstring;
	return ID;
}string raknet_mgr::GUIDtoString(RakNet::RakNetGUID ID)
{
	char* newstring = new char[64];
	ID.ToString(newstring);
	std::stringstream outstream;
	string out = "";
	outstream << *newstring;
	outstream >> out;
	return out;
}void raknet_mgr::ProcessPacket_RemoteDebuggerMsg(RakNet::Packet* Datas)
{
	RakNet::RakString rs;
	RakNet::BitStream bsIn(Datas->data,Datas->length,false);
	bsIn.IgnoreBytes(sizeof(RakNet::MessageID));
	bsIn.Read(rs);
	ldbg.send(rs.C_String());
}bool OpenUPNP(RakNet::RakPeerInterface *rakPeer, RakNet::SystemAddress serverAddress)
{	
	using namespace RakNet;
	struct UPNPDev * devlist = 0;
	devlist = upnpDiscover(1000, 0, 0, 0); // was 2000
	if (devlist)
	{
		char lanaddr[64];	/* my ip address on the LAN */
		struct UPNPUrls urls;
		struct IGDdatas data;
		if (UPNP_GetValidIGD(devlist, &urls, &data, lanaddr, sizeof(lanaddr))==1)
		{
			DataStructures::List< RakNetSmartPtr< RakNetSocket> > sockets;
			rakPeer->GetSockets(sockets);			char iport[32];
			Itoa(sockets[0]->boundAddress.GetPort(),iport,10);
			char eport[32];
			Itoa(rakPeer->GetExternalID(serverAddress).GetPort(),eport,10);			int r = UPNP_AddPortMapping(urls.controlURL, data.first.servicetype, eport, iport, lanaddr, 0, "UDP", 0);
			if(r!=UPNPCOMMAND_SUCCESS)
			{
				return false;
			}
		}
		else
		{
			return false;
		}
	}
	else
	{
		return false;
	}	return true;
}#include "Namuh_Main_H.h"using namespace Ogre;
bool OpenUPNP(RakNet::RakPeerInterface *rakPeer, RakNet::SystemAddress serverAddress);std::map<RakNet::RakNetGUID, ushort> PlayerPing;
extern std::map<RakNet::RakNetGUID, KeyState> KeyPlayer;raknet_Server::raknet_Server(void)
{
	peer = raknet_man.peer;
	pingflag = 1;
}void raknet_Server::Initialise(int port, int MaxClients)
{	
	peer = raknet_man.peer;
	int ConnecResult;
	ConnecResult = int(peer->Startup(MaxClients, &RakNet::SocketDescriptor(port,0), 1));
	if(ConnecResult != 1)
		ldbg.send("Cannot Start server, error code : "+StringConverter::toString(ConnecResult));
	else
		ldbg.send("Initialised server on port : "+StringConverter::toString(port)+", Maximum client allowed : "+StringConverter::toString(MaxClients)+".");
	peer->SetMaximumIncomingConnections(MaxClients);
	initialised = true;
}void raknet_Server::update(void)
{	
	// Ping les clients tout les 3sec
	if(*raknet_man.gametime > pingflag*3000)
	{
		pingflag++;
		RakNet::BitStream bsOut;
		bsOut.Write((RakNet::MessageID)StC_PING);
		bsOut.Write((long double)*raknet_man.gametime);
		peer->Send(&bsOut,HIGH_PRIORITY,RELIABLE,0,RakNet::UNASSIGNED_SYSTEM_ADDRESS,true);
	}
	
	// Traitement de paquets en entrée
	for (packet=peer->Receive(); packet; peer->DeallocatePacket(packet), packet=peer->Receive())
		switch (packet->data[0])
		{
			case ID_REMOTE_DISCONNECTION_NOTIFICATION:
				ldbg.send("(NetI/O Processor) Remote client ID_"+raknet_man.GUIDtoString(packet->guid)+" left");
			break;
			case ID_REMOTE_CONNECTION_LOST:
				ldbg.send("(NetI/O Processor) Remote client ID_"+raknet_man.GUIDtoString(packet->guid)+" lost the connection.");
			break;
			case ID_REMOTE_NEW_INCOMING_CONNECTION:
				ldbg.send("(NetI/O Processor) Remote client ID_"+raknet_man.GUIDtoString(packet->guid)+" connected.");
			break;
			case ID_NEW_INCOMING_CONNECTION:
				this->ProcessPacket_NewClient(packet);
			break;
			case ID_NO_FREE_INCOMING_CONNECTIONS:
				ldbg.send("(NetI/O Processor) The server is full.");
			break;
			case ID_DISCONNECTION_NOTIFICATION:
				ldbg.send("(NetI/O Processor) Client ID_"+raknet_man.GUIDtoString(packet->guid)+" left");
			break;
			case ID_CONNECTION_LOST:
				ldbg.send("(NetI/O Processor) Client ID_"+raknet_man.GUIDtoString(packet->guid)+" lost the connection.");
			break;
			case ID_REMOTE_DEBUG_MESSAGE:
				raknet_man.ProcessPacket_RemoteDebuggerMsg(packet);
			break;
			case CtS_SYNC_TIMESTAMP:
				this->ProcessPacket_SyncClock(packet);
			break;
			case CtS_UPDATE_REQUEST:
				this->SendUpdate(packet->guid);
			break;
			case CtS_KEYSTATE:
				this->ProcessPacket_NewKeystate(packet);
			break;
			case CtS_ORIENTATION:
				this->ProcessPacket_NewOrientation(packet);
			break;
			case CtS_WEAPONSWITCH:
				this->ProcessPacket_ChangeWeapon(packet);
			break;
			case CtS_PING:
				this->ProcessPacket_Ping(packet);
			break;
			default:
				ldbg.send("(NetI/O Processor) Unknown packet with identifier "+StringConverter::toString(packet->data[0])+" recived from Client ID_"+raknet_man.GUIDtoString(packet->guid)+" : Skipping.\n" );
			break;
		}
}void raknet_Server::ProcessPacket_NewClient(RakNet::Packet* Datas)
{		
	// Envoi au client les autres IDs présents
	RakNet::BitStream bsOut;
	bsOut.Write((RakNet::MessageID)StC_SET_ID);
	for (std::map<RakNet::RakNetGUID, Perso*>::iterator IDIterator = PlayerList.begin();
		IDIterator !=PlayerList.end();
		IDIterator++)
		if(IDIterator->second->id != raknet_man.local_GUID)
			bsOut.Write(IDIterator->second->id); // recopie tout les GUID dans le paquet (sauf celui du srv)
	bsOut.Write(RakNet::UNASSIGNED_RAKNET_GUID); // Marqueur de fin
	peer->Send(&bsOut,MEDIUM_PRIORITY,RELIABLE,0,Datas->guid,false);	// Envoi du nom de la map
	ldbg.send("(NetI/O Processor) Sending Map_name  (" + raknet_man.map + ") to this client");	
	bsOut.Reset();
	bsOut.Write((RakNet::MessageID)StC_GAME_MAP);
	RakNet::RakString rs;
	rs.Set(raknet_man.map.c_str());
	bsOut.Write(rs);
	peer->Send(&bsOut,MEDIUM_PRIORITY,RELIABLE,0,packet->guid,false);	// Envoi du Timestamp
	bsOut.Reset();
	bsOut.Write((RakNet::MessageID)StC_SYNC_SET_TIME);
	bsOut.Write(long double(*raknet_man.gametime));
	bsOut.Write(long double(0));
	peer->Send(&bsOut,IMMEDIATE_PRIORITY,RELIABLE,0,packet->guid,false);	// Spawn un nouveau perso
	Perso* NewPerso = new Perso(Datas->guid);
	NewPerso->initialise();
	NewPerso->spawn(Vector3FromName(Map.MapDataPool,"Spawn_Position")+Ogre::Vector3(Math::RangeRandom(-5,5),0,Math::RangeRandom(-5,5))); // Messy spawn point TODO : make team spawn area
	ldbg.send("(NetI/O Processor) Client ID_" +raknet_man.GUIDtoString(NewPerso->id) + " joined");
	// TODO : Make a system to ensure that this info is correctly transmited
	// Préviens les autres clients du nouveau joueur
	/*
	bsOut.Reset();
	bsOut.Write((RakNet::MessageID)StC_SET_ID);
	bsOut.Write(Datas->guid);
	bsOut.Write(RakNet::UNASSIGNED_RAKNET_GUID); // Marqueur de fin
	peer->Send(&bsOut,MEDIUM_PRIORITY,RELIABLE,0,Datas->guid,true);
	*/}void raknet_Server::SendUpdate(RakNet::RakNetGUID ClientID)
{
	RakNet::BitStream bsOut;
	float x,y,z;
	for (	std::map<RakNet::RakNetGUID, Perso*>::iterator PlayerIterator = PlayerList.begin();
		PlayerIterator != PlayerList.end();
		PlayerIterator++)
	{
		if(PlayerIterator->second->id != raknet_man.local_GUID)
		{
			// Envoi de la position des joueurs
			bsOut.Reset();
			x = float(PlayerIterator->second->pos.x);
			y = float(PlayerIterator->second->pos.y);
			z = float(PlayerIterator->second->pos.z);
			bsOut.Write((RakNet::MessageID)StC_PLAYER_POS);
			bsOut.Write((RakNet::RakNetGUID)PlayerIterator->second->id);
			bsOut.Write(x);
			bsOut.Write(y);
			bsOut.Write(z);
			peer->Send(&bsOut,IMMEDIATE_PRIORITY,RELIABLE_ORDERED,0,ClientID,false);			// envoit l'orientation des joueurs , sauf l'orientation du joueur qui demande l'update
			// Par contre ce joueur doit recevoir sa nouvelle valeur de vie
			if(ClientID != PlayerIterator->first)
			{
				bsOut.Reset();
				bsOut.Write((RakNet::MessageID)StC_PLAYER_ROT);
				bsOut.Write(PlayerIterator->first);
				bsOut.Write(float(PlayerIterator->second->Node->getOrientation().getYaw().valueDegrees()));
				bsOut.Write(float(PlayerIterator->second->rot.getPitch().valueDegrees()));
				peer->Send(&bsOut,IMMEDIATE_PRIORITY,RELIABLE_ORDERED,0,ClientID,false);
			}
			else
			{
				// TODO : send only on change
				bsOut.Reset();
				bsOut.Write((RakNet::MessageID)StC_HEALTH);
				bsOut.Write(char(PlayerIterator->second->vie));
				peer->Send(&bsOut,IMMEDIATE_PRIORITY,RELIABLE_ORDERED,0,ClientID,false);
			}
		}
	}
}
void raknet_Server::ProcessPacket_NewKeystate(RakNet::Packet* Datas)
{
	RakNet::BitStream bsIn(packet->data,packet->length,false);
	bsIn.IgnoreBytes(sizeof(RakNet::MessageID));
	
	RakNet::RakNetGUID ID = Datas->guid;	std::map<RakNet::RakNetGUID, Perso*>::iterator PlayerIterator = PlayerList.find(ID);
	if(PlayerIterator != PlayerList.end())
	{
		// Met a jour le clavier virtuel du joueur
		bsIn.Read(KeyPlayer[PlayerIterator->first].timestamp);
		bsIn.Read(KeyPlayer[PlayerIterator->first].fire);
		bsIn.Read(KeyPlayer[PlayerIterator->first].up);
		bsIn.Read(KeyPlayer[PlayerIterator->first].down);
		bsIn.Read(KeyPlayer[PlayerIterator->first].left);
		bsIn.Read(KeyPlayer[PlayerIterator->first].right);
		bsIn.Read(KeyPlayer[PlayerIterator->first].jump);
	}
	else
		ldbg.send("(NetI/O Processor) Recived new keystates from an unknown player : packet skipped (ID_" + raknet_man.GUIDtoString(ID) + ")");
}void raknet_Server::ProcessPacket_NewOrientation(RakNet::Packet* Datas)
{
	RakNet::BitStream bsIn(packet->data,packet->length,false);
	bsIn.IgnoreBytes(sizeof(RakNet::MessageID));
	RakNet::RakNetGUID ID = Datas->guid;	float rot,rot_vert,rotative_velocity_x,rotative_velocity_y;
	bsIn.Read(rot); // angle horisontal
	bsIn.Read(rot_vert); // angle vertical
	bsIn.Read(rotative_velocity_x); // vitesse de rotation horisontale
	bsIn.Read(rotative_velocity_y); // vitesse de rotation verticale
	std::map<RakNet::RakNetGUID, Perso*>::iterator PlayerIterator = PlayerList.find(ID);
	if(PlayerIterator != PlayerList.end())
	{
		PlayerList[PlayerIterator->first]->OrientationInput = Ogre::Vector3(rot			-PlayerList[PlayerIterator->first]->Node->getOrientation().getYaw().valueDegrees(),
																			rot_vert	-PlayerList[PlayerIterator->first]->rot.getPitch().valueDegrees(),
																			0);
		PlayerList[PlayerIterator->first]->rotative_velocity = Ogre::Vector3(rotative_velocity_x,rotative_velocity_y,0);
	}
	else
		ldbg.send("(NetI/O Processor) Recived orientation from an unknown player : packet skipped (ID_" + raknet_man.GUIDtoString(ID) + ")");
}void raknet_Server::ProcessPacket_ChangeWeapon(RakNet::Packet* Datas)
{
	// Récupère les infos du paquet
	RakNet::BitStream bsIn(Datas->data,Datas->length,false);
	bsIn.IgnoreBytes(sizeof(RakNet::MessageID));
	RakNet::RakNetGUID ID = Datas->guid;
	long double timestamp;
	bsIn.Read(timestamp);	char NewWeapon_c;
	bsIn.Read(NewWeapon_c);
	std::map<RakNet::RakNetGUID, Perso*>::iterator PlayerIterator = PlayerList.find(ID);
	if(PlayerIterator != PlayerList.end())
	{
		// Change d'arme
		PlayerIterator->second->Current_Weapon->WeaponNode->setVisible(false);
		PlayerIterator->second->Current_Weapon = PlayerIterator->second->Inventory[NewWeapon_c];
		PlayerIterator->second->Current_Weapon->WeaponNode->setVisible(true);		// Préviens les autres clients que ClientPlayerIndex a changé d'arme
		RakNet::BitStream bsOut;
		bsOut.Write((RakNet::MessageID)StC_WEAPONSWITCH);
		bsOut.Write(PlayerIterator->first);
		bsOut.Write(char(NewWeapon_c));
		peer->Send(&bsOut,LOW_PRIORITY,RELIABLE_ORDERED,0,ID,true);
		bsOut.Reset();
	}
	else
		ldbg.send("(NetI/O Processor) Recived a notification to change a weapon from an unknown player : packet skipped (ID_" + raknet_man.GUIDtoString(ID) + ")");
}void raknet_Server::ProcessPacket_Ping(RakNet::Packet* Datas)
{
	long double pingdate;
	RakNet::RakNetGUID ID = Datas->guid;
	RakNet::BitStream bsIn(Datas->data,Datas->length,false);
	bsIn.IgnoreBytes(sizeof(RakNet::MessageID));
	bsIn.Read(pingdate);
	PlayerPing[ID] = (ushort)(*raknet_man.gametime - pingdate);
	ldbg.send("(ID_" + raknet_man.GUIDtoString(Datas->guid) + "). ping : " + StringConverter::toString(int(PlayerPing[ID])));
}void raknet_Server::ProcessPacket_SyncClock(RakNet::Packet* Datas)
{
	// Recois l'état de l'horloge client
	long double ClientClock, ClientDelta, delta;
	RakNet::BitStream bsIn(Datas->data,Datas->length,false);
	bsIn.IgnoreBytes(sizeof(RakNet::MessageID));
	bsIn.Read(ClientClock);
	bsIn.Read(ClientDelta);
	delta = *raknet_man.gametime - ClientClock;
	//ldbg.send("(ID_" + raknet_man.GUIDtoString(Datas->guid) + "). delta : " + StringConverter::toString(float(delta)));	// renvois un ajustement si nécécaire
	if(delta < 1  || ClientDelta < 1 || ClientDelta <= delta)
	{
		RakNet::BitStream bsOut;
		bsOut.Write((RakNet::MessageID)StC_SYNC_SET_TIME);
		bsOut.Write(long double(*raknet_man.gametime));
		bsOut.Write(long double(delta));
		peer->Send(&bsOut,IMMEDIATE_PRIORITY,RELIABLE,0,packet->guid,false);
	}
}void raknet_Server::destroy(void)
{	}
raknet_Server::~raknet_Server(void)
{
}
#include "Namuh_Main_H.h"
#include "NxOgre/NxOgreClasses.h" // Plugin PhysX
using namespace Ogre;Sandbox_Constructeur Constructeur;
Sandbox_Constructeur::Sandbox_Constructeur(void)
{
	mouseflag = false;
	kc_left_flag = false; 
	kc_right_flag = false; 
	zcursor = 2.0f;
	Construction_num = -1.0f; //pas encore de construction en cours !
	diametre_rondin = 1.0f;
	longeur_rondin = 10.0f;
	orientation_rondin = 90.0f;
	diskOrientation = 90.0f;
	diskLength = 0.2f;
	diskRadius = 1.0f;
	triangleOrientation = 90.0f;
	triangleLength = 1.5f;
	triangleRadius = 0.2f;
	CurrentBuildTool = NONE;
	ClickedBody = NULL;
	
}
Sandbox_Constructeur::~Sandbox_Constructeur(void)
{
}void Sandbox_Constructeur::intitalise(void)
{	// charge les curseurs
	RondinCursor = sys0.mgr->createEntity("LogCursor","Rondin.mesh");
    RondinCursor_n = sys0.mgr->getRootSceneNode()->createChildSceneNode();
    RondinCursor_n->attachObject(RondinCursor);
	RondinCursor_n->setVisible(false);	RocherCursor = sys0.mgr->createEntity("RockCursor","rocher.mesh");
    RocherCursor_n = sys0.mgr->getRootSceneNode()->createChildSceneNode();
    RocherCursor_n->attachObject(RocherCursor);
	RocherCursor_n->setVisible(false);	// TODO : make them
	DiskCursor = sys0.mgr->createEntity("DiskCursor","rocher.mesh");
    DiskCursor_n = sys0.mgr->getRootSceneNode()->createChildSceneNode();
    DiskCursor_n->attachObject(DiskCursor);
	DiskCursor_n = sys0.mgr->getRootSceneNode()->createChildSceneNode();
    DiskCursor_n->setVisible(false);	/*
	
	TriangleCursor_n = sys0.mgr->getRootSceneNode()->createChildSceneNode();
	Ogre::SceneNode* log1 = TriangleCursor_n->createChildSceneNode("TriangleCursor1",Ogre::Vector3(0.0f,0.0f, 0.43f)*triangleLength,Quaternion(Degree(0), Vector3::UNIT_X));
    log1->attachObject(sys0.mgr->createEntity("TriangleCursor1","Rondin.mesh"));
	Ogre::SceneNode* log2 = TriangleCursor_n->createChildSceneNode("TriangleCursor2",Ogre::Vector3(0.37f,0.0f, -0.22f)*triangleLength,Quaternion(Degree(60), Vector3::UNIT_X));
    log2->attachObject(sys0.mgr->createEntity("TriangleCursor2","Rondin.mesh"));
	Ogre::SceneNode* log3 = TriangleCursor_n->createChildSceneNode("TriangleCursor3",Ogre::Vector3(-0.37f,0.0f, -0.22f)*triangleLength,Quaternion(Degree(120), Vector3::UNIT_X));
    log3->attachObject(sys0.mgr->createEntity("TriangleCursor3","Rondin.mesh"));
	*/	TriangleCursor_n = sys0.mgr->getRootSceneNode()->createChildSceneNode();
	Ogre::SceneNode* log1 = TriangleCursor_n->createChildSceneNode("TriangleCursor1",Ogre::Vector3(0.0f,0.0f, 0.0f)*triangleLength,Quaternion(Degree(0), Vector3::UNIT_X));
    log1->attachObject(sys0.mgr->createEntity("TriangleCursor1","Rondin.mesh"));
	Ogre::SceneNode* log2 = TriangleCursor_n->createChildSceneNode("TriangleCursor2",Ogre::Vector3(0.0f,0.0f, 0.0f)*triangleLength,Quaternion(Degree(60), Vector3::UNIT_X));
    log2->attachObject(sys0.mgr->createEntity("TriangleCursor2","Rondin.mesh"));
	Ogre::SceneNode* log3 = TriangleCursor_n->createChildSceneNode("TriangleCursor3",Ogre::Vector3(0.0f,0.0f, 0.0f)*triangleLength,Quaternion(Degree(120), Vector3::UNIT_X));
    log3->attachObject(sys0.mgr->createEntity("TriangleCursor3","Rondin.mesh"));
	TriangleCursor_n->setVisible(false);
	}void Sandbox_Constructeur::destroy(void)
{}void Sandbox_Constructeur::update(void)
{
	if(CurrentBuildTool != NONE)
		this->UpdateConstructeur();
}
Ogre::Vector3 Sandbox_Constructeur::ComputeCursor3DPos(void)
{
	// Rayon a tester
	CEGUI::Point mousePos = CEGUI::MouseCursor::getSingleton().getPosition();
	Ogre::Ray mRay = sys0.cam->getCameraToViewportRay(mousePos.d_x/float(sys0.vp->getActualWidth()), mousePos.d_y/float(sys0.vp->getActualHeight()));	// Intersection Terrain
	// intersection est un couple dont le premier élement est un booléen indiquent si le rayon a tapé ou non, le deuxième est un vector3 donnant le lieu de l'intersection
	std::pair <int, Ogre::Vector3> intersection = (std::pair <int, Ogre::Vector3> )Map.terrain->rayIntersects(mRay,10000); 
	float terrainDist = (intersection.second - mRay.getOrigin()).length();
/*
	// Intersection objets (ogre)
	Ogre::RaySceneQuery* mRayScnQuery = sys0.mgr->createRayQuery(Ogre::Ray());
	mRayScnQuery->setQueryTypeMask(SceneManager::ENTITY_TYPE_MASK);
	mRayScnQuery->setRay(mRay);
	mRayScnQuery->setSortByDistance(true);
	RaySceneQueryResult &result = mRayScnQuery->execute();
	RaySceneQueryResult::iterator itr;
	for ( itr = result.begin( ); itr != result.end(); itr++ )
		if ( itr->movable )
			if(itr->movable->getName().find("Ogre/MO",0) == 0)		// Trouve un objet de la sandbox		
				break;
*/	//Intersection Rigibody
	NxOgre::Ray Nxray;
	Nxray.mDirection.from(mRay.getDirection());
	Nxray.mOrigin.from(mRay.getOrigin() + (mRay.getDirection().normalisedCopy())*0.3);
	NxOgre::RaycastHit Nxresult = PhysX_man.mScene->raycastClosestShape(Nxray,NxOgre::Enums::ShapesType_Dynamic,2147483647,10000);
	ClickedBody = Nxresult.mRigidBody;	// Prend l'intersection la plus proche
	if( Nxresult.mDistance < terrainDist) 
	{
		bool ClickedBodyIsValid = false;
		Cursor3D_Type = INVALID;
		for (	std::vector<Critter::Body*>::iterator itt = BuiltCstr[Constructeur.getConstruction_num()]->element.begin();
				itt != BuiltCstr[Constructeur.getConstruction_num()]->element.end();
				++itt)
			if(*itt == ClickedBody)
			{
				ClickedBodyIsValid = true;
				Cursor3D_Type = CAST_OBJECT; // CAST_OBJECT uniquement si l'objet casté est dans la construction en cours
				break;
			}		if(!ClickedBodyIsValid)ClickedBody = NULL; // ClickedBody ne peut pointer sur autre chose qu'un élément de la construction en cours
		Ogre::Vector3 interPos = Ogre::Vector3(Nxresult.mWorldImpact.x,Nxresult.mWorldImpact.y,Nxresult.mWorldImpact.z)+zcursor*Ogre::Vector3(Nxresult.mWorldNormal.x,Nxresult.mWorldNormal.y,Nxresult.mWorldNormal.z);
		return interPos;
	}
	else
	{
		Cursor3D_Type = CAST_TERRAIN;
		return intersection.second+Ogre::Vector3::UNIT_Y*zcursor;
	}
}void Sandbox_Constructeur::UpdateConstructeur(void)
{
	if(CurrentBuildTool == ROCHER || CurrentBuildTool == RONDIN || CurrentBuildTool == DISK || CurrentBuildTool == TRIANGLE) this->UpdateBuildUI();
	else if(CurrentBuildTool == DELOBJ)  this->UpdateDeleteUI();
	else if(CurrentBuildTool == CREATE_LINK_PICK_FIRST) this->UpdateCreateLinkPickFirstUI();
	else if(CurrentBuildTool == CREATE_LINK_PICK_SECOND) this->UpdateCreateLinkPickSecondUI();
	else 
		ldbg.send("(Sandbox_Constructeur Exeption) Called UpdateConstructeur with incorrect currentMode, Nothing to do.");
}
void Sandbox_Constructeur::UpdateCreateLinkPickFirstUI(void)
{
	// Met a jour le ClickedBody
	this->ComputeCursor3DPos();	// envois le Body si l'on clique
	if(Cursor3D_Type == CAST_OBJECT)
		if(!sys0.ms->buttonDown( OIS::MB_Left ))mouseflag = false;
		else if(!mouseflag)
			if(ClickedBody != NULL)
			{
				mouseflag = true;				CEGUI::Listbox* Objlist = static_cast<CEGUI::Listbox*>(GuiSandboxMan.winMgr->getWindow("SanboxLinkCreator/FirstObjLst"));
				if(Objlist->getFirstSelectedItem() != NULL) // Si objet séléctionné il y a, désélectionné il sera
					Objlist->getFirstSelectedItem()->setSelected(false);
				for(Ogre::uint i = 0; i<Objlist->getItemCount(); ++i)
					if(Objlist->getListboxItemFromIndex(i)->getText() == ClickedBody->getName()) // Sélectionne le Body cliqué
						Objlist->getListboxItemFromIndex(i)->setSelected(true);
							
				GuiSandboxMan.winMgr->getWindow("SanboxLinkCreator")->enable();
				GuiSandboxMan.winMgr->getWindow("SanboxLinkCreator")->show();
				setConstructionMode(NONE);
			}
}void Sandbox_Constructeur::UpdateCreateLinkPickSecondUI(void)
{
	// Met a jour le ClickedBody
	this->ComputeCursor3DPos();	// envois le Body si l'on clique
	if(Cursor3D_Type == CAST_OBJECT)
		if(!sys0.ms->buttonDown( OIS::MB_Left ))mouseflag = false;
		else if(!mouseflag)
			if(ClickedBody != NULL)
			{
				mouseflag = true;				CEGUI::Listbox* Objlist = static_cast<CEGUI::Listbox*>(GuiSandboxMan.winMgr->getWindow("SanboxLinkCreator/SecondObjLst"));
				if(Objlist->getFirstSelectedItem() != NULL) // Si objet séléctionné il y a, désélectionné il sera
					Objlist->getFirstSelectedItem()->setSelected(false);
				for(Ogre::uint i = 0; i<Objlist->getItemCount(); ++i)
					if(Objlist->getListboxItemFromIndex(i)->getText() == ClickedBody->getName()) // Sélectionne le Body cliqué
						Objlist->getListboxItemFromIndex(i)->setSelected(true);
							
				GuiSandboxMan.winMgr->getWindow("SanboxLinkCreator")->enable();
				GuiSandboxMan.winMgr->getWindow("SanboxLinkCreator")->show();
				setConstructionMode(NONE);
			}
}void Sandbox_Constructeur::UpdateDeleteUI(void)
{
	// Met a jour le ClickedBody
	this->ComputeCursor3DPos();	// Détruit si l'on clique
	if(Cursor3D_Type == CAST_OBJECT)
		if(!sys0.ms->buttonDown( OIS::MB_Left ))mouseflag = false;
		else if(!mouseflag)
			if(ClickedBody != NULL)
			{
				mouseflag = true;
				
				// Unregister related links				
				for(Ogre::uint i = 0; i<BuiltCstr[Constructeur.getConstruction_num()]->joint.size(); ++i)
					if(BuiltCstr[Constructeur.getConstruction_num()]->joint[i].joint->getFirstRigidBody() == ClickedBody ||
					   BuiltCstr[Constructeur.getConstruction_num()]->joint[i].joint->getSecondRigidBody() == ClickedBody)
						BuiltCstr[Constructeur.getConstruction_num()]->DestroyJoint(BuiltCstr[Constructeur.getConstruction_num()]->joint[i].joint);
				
				// Unregister the element from the construction
				for(Ogre::uint i = 0; i<BuiltCstr[Constructeur.getConstruction_num()]->element.size(); ++i)
					if(BuiltCstr[Constructeur.getConstruction_num()]->element[i] == static_cast<Critter::Body*>(ClickedBody))
						BuiltCstr[Constructeur.getConstruction_num()]->element.erase(BuiltCstr[Constructeur.getConstruction_num()]->element.begin()+i);				//  Unregister floater if needed
				PhysXfloater.remove(static_cast<Critter::Body*>(ClickedBody));				// delete Ogre's node
				Critter::Node* ClickedNode = static_cast<Critter::Body*>(ClickedBody)->getNode();
				sys0.mgr->destroySceneNode(ClickedNode->getSceneNode());				// Delete PhysX's body (Yes, we can cast a Rigidbody to a Critter's Body)
				PhysX_man.mRenderSystem->destroyBody(static_cast<Critter::Body*>(ClickedBody));
				
				Constructeur.refreshLinkLst();
				ClickedBody = NULL;
			}
		
}void Sandbox_Constructeur::UpdateBuildUI(void)
{
	SceneNode* Cursor;
	if(CurrentBuildTool == RONDIN) Cursor = RondinCursor_n;
	else if(CurrentBuildTool == ROCHER) Cursor = RocherCursor_n;
	else if(CurrentBuildTool == DISK) Cursor = DiskCursor_n;
	else if(CurrentBuildTool == TRIANGLE) Cursor = TriangleCursor_n;
	else if(CurrentBuildTool == DELETE) Cursor = NULL;
	else 
	{
		ldbg.send("(Sandbox_Constructeur Exeption) Called UpdateBuildUI with incorrect currentMode, Aborded.");
		return;
	}
 	//Curseur immatériel
	Ogre::Vector3 Cursor3DPos = this->ComputeCursor3DPos();
	if((Cursor3D_Type == CAST_TERRAIN && BuiltCstr[Constructeur.getConstruction_num()]->element.size() == 0) || Cursor3D_Type == CAST_OBJECT)
	{
		Cursor->resetToInitialState();
		Cursor->setVisible(true);
		Cursor->setPosition(Vector3(	Cursor3DPos.x,
										Cursor3DPos.y,
										Cursor3DPos.z));		// update du curseur en fonction de l'outil choisi
		if(CurrentBuildTool == RONDIN)
		{
			Cursor->scale(diametre_rondin/2,longeur_rondin/10,diametre_rondin/2);
			Cursor->setOrientation(Quaternion(Degree(local_player.Node->getOrientation().getYaw().valueDegrees()), Vector3::UNIT_Y)*Quaternion(Degree(orientation_rondin), Vector3::UNIT_X));
		}
		else if(CurrentBuildTool == ROCHER)
			Cursor->setOrientation(Quaternion(Degree(local_player.Node->getOrientation().getYaw().valueDegrees()), Vector3::UNIT_Y));
		else if(CurrentBuildTool == TRIANGLE)
		{
			Cursor->setOrientation(Quaternion(Degree(local_player.Node->getOrientation().getYaw().valueDegrees()), Vector3::UNIT_Y)*Quaternion(Degree(90), Vector3::UNIT_Y)*Quaternion(Degree(triangleDirection), Vector3::UNIT_X));
			Cursor->translate(0,triangleRadius,0);
			Cursor->getChild("TriangleCursor1")->setPosition(Ogre::Vector3(0.0f,0.0f, 0.43f)*triangleLength*0.5f);				
			Cursor->getChild("TriangleCursor2")->setPosition(Ogre::Vector3(0.0f, 0.37f, -0.22f)*triangleLength*0.5f);				
			Cursor->getChild("TriangleCursor3")->setPosition(Ogre::Vector3(0.0f, -0.37f, -0.22f)*triangleLength*0.5f);				
			Cursor->getChild("TriangleCursor1")->setScale(triangleRadius/2,triangleLength/10,triangleRadius/2);
			Cursor->getChild("TriangleCursor2")->setScale(triangleRadius/2,triangleLength/10,triangleRadius/2);
			Cursor->getChild("TriangleCursor3")->setScale(triangleRadius/2,triangleLength/10,triangleRadius/2);
		}		// Construit si l'on clique
		if(!sys0.ms->buttonDown( OIS::MB_Left ))mouseflag = false;
		else if(!mouseflag)
		{
			mouseflag = true;			if(CurrentBuildTool == RONDIN)				
				CstrMgr.Create_rondin(	BuiltCstr[Constructeur.getConstruction_num()],
										Cursor3DPos, 
										Quaternion(Degree(local_player.Node->getOrientation().getYaw().valueDegrees()),Vector3::UNIT_Y)*Quaternion(Degree(orientation_rondin), Vector3::UNIT_X),
										diametre_rondin,
										longeur_rondin);			else if(CurrentBuildTool == ROCHER)			
				CstrMgr.Create_rocher(	BuiltCstr[Constructeur.getConstruction_num()],
										Cursor3DPos,
										Quaternion(Degree(local_player.Node->getOrientation().getYaw().valueDegrees()),Vector3::UNIT_Y));
			
			else if(CurrentBuildTool == TRIANGLE)
			{
						
				CstrMgr.Create_triangle(BuiltCstr[Constructeur.getConstruction_num()],
										Cursor3DPos, 
										Quaternion(Degree(local_player.Node->getOrientation().getYaw().valueDegrees() + triangleDirection),Vector3::UNIT_Y)
										* Quaternion(Degree(triangleOrientation), Vector3::UNIT_X)
										* Quaternion(Degree(triangleDirection), Vector3::UNIT_Z),
										triangleRadius,
										triangleLength);
				refreshLinkLst();
			}			if(ClickedBody != NULL)
			{
				// Crée le joint PhysX entre le nouveau rigibody et celui que l'on a cliqué
				BuiltCstr[Constructeur.getConstruction_num()]->CreateFixedLink(ClickedBody,BuiltCstr[Constructeur.getConstruction_num()]->element.back());
		
				// retrace la liste des links
				Constructeur.refreshLinkLst();
			}
		}
	}
	else
		Cursor->setVisible(false);	// TODO : auto Zcursor
	// Molette pour chager l'altitude du curseur
	zcursor = 1.3f + GuiSandboxMan.mouseZ*0.0025;
	if(zcursor<0)zcursor=0;	
}void Sandbox_Constructeur::NewConstruction(void)
{
	// Crée la construction
	BuiltCstr.push_back(CstrMgr.CreateNew());
	
	// Crée un élément dans la liste
	CEGUI::Listbox* Cstrlist = static_cast<CEGUI::Listbox*>(GuiSandboxMan.winMgr->getWindow("Sandbox_interface/Sandbox/Liste_constructions"));
	CEGUI::ListboxTextItem* CstrListItem = new CEGUI::ListboxTextItem(BuiltCstr.back()->name);
	CstrListItem->setSelectionBrushImage("TaharezLook", "ListboxSelectionBrush");
	Cstrlist->addItem(CstrListItem);	// La définit comme active
	Constructeur.setConstruction_num(BuiltCstr.size()-1);
}void Sandbox_Constructeur::setConstructionMode(Construction_mode NewMode)
{	
	Constructeur.CurrentBuildTool = NewMode;
	
	// retour visuel a l'utilisateur
	CEGUI::WindowManager * winMgr = CEGUI::WindowManager::getSingletonPtr();
	if(NewMode == RONDIN)
	{
		ldbg.send("Contructeur :  Now using logs");
		winMgr->getWindow("Sandbox_interface/StatusBar")->setText("Click on a existing object to place a log on it");
	}
	if(NewMode == ROCHER)
	{
		ldbg.send("Contructeur :  Now using rocks");
		winMgr->getWindow("Sandbox_interface/StatusBar")->setText("Click on a existing object to place a rock on it");
	}
	if(NewMode == DISK)
	{
		ldbg.send("Contructeur :  Now using disks");
		winMgr->getWindow("Sandbox_interface/StatusBar")->setText("Click on a existing object to place a rock on it");
	}
	
	if(NewMode == TRIANGLE)
	{
		ldbg.send("Contructeur :  Now using triangles");
		winMgr->getWindow("Sandbox_interface/StatusBar")->setText("Click on a existing object to place a rock on it");
	}
	if(NewMode == DELOBJ)
	{
		ldbg.send("Contructeur :  Now deleting objects");
		winMgr->getWindow("Sandbox_interface/StatusBar")->setText("Click on a existing object to delete it");
	}	ldbg.send("TODO : Make a toast appear to explain this");
	}Construction_mode Sandbox_Constructeur::getConstructionMode(void)
{
	return CurrentBuildTool;
}
void Sandbox_Constructeur::setConstruction_num(int NewConstruction_num)
{
	// Change Construction_num
	Construction_num = NewConstruction_num;	// Sélectionne la construction dans la liste des constructions
	CEGUI::Listbox* Cstrlist = static_cast<CEGUI::Listbox*>(GuiSandboxMan.winMgr->getWindow("Sandbox_interface/Sandbox/Liste_constructions"));
	if(Cstrlist->getSelectedCount())
		Cstrlist->getFirstSelectedItem()->setSelected(false);
	Cstrlist->getListboxItemFromIndex(Construction_num)->setSelected(true);	// Redessine la liste des liaisons
	this->refreshLinkLst();
}int Sandbox_Constructeur::getConstruction_num(void)
{
	return Constructeur.Construction_num;
}
void Sandbox_Constructeur::refreshLinkLst(void)
{
	// Redessine la liste des liaisons
	CEGUI::Listbox* LnkLst = static_cast<CEGUI::Listbox*>(GuiSandboxMan.winMgr->getWindow("Sandbox_interface/Sandbox/Liste_liaisons"));
	LnkLst->resetList();
	CEGUI::ListboxTextItem* LinkListItem;
	for( Ogre::uint i = 0; i<BuiltCstr[Constructeur.getConstruction_num()]->joint.size(); ++i)
	{
		LinkListItem = new CEGUI::ListboxTextItem(BuiltCstr[Constructeur.getConstruction_num()]->joint[i].name);
		LinkListItem->setSelectionBrushImage("TaharezLook", "ListboxSelectionBrush");
		LnkLst->addItem(LinkListItem);
	}
}
#include "Namuh_Main_H.h"using namespace Ogre;
extern const OIS::MouseState &ms = sys0.mMouse->getMouseState();namuh_system sys1;namuh_system::namuh_system(void) //Constructeur
{
    escQuit = false;	//définition du fichier de configuration racine
	MainConfigFileSyntax.push_back(new ParserBalise);
	MainConfigFileSyntax.back()->Name = "General";
	MainConfigFileSyntax.back()->StringKeywords.push_back("ActiveProfile");	
	ifstream file ("Namuh.cfg",ios::in);
	if(!file)
	{
		file.close();
		ldbg.send("(Sys1 Exeption) Unable to open main config file, will prompt for informations to create a new one");
		ProfileMgr.isCurrentProfileValid = false;	}
	else
	{
		file.close();
		ProfileMgr.isCurrentProfileValid = true;
		std::vector<NamedDataPool> RawMainConfigFile = Map_Parser.ParseFile(MainConfigFileSyntax,"Namuh.cfg");
		
		// Retrouve l'index des pools de données
		Ogre::uint	GeneralPoolIndex = -1;
		for(Ogre::uint i = 0; i < RawMainConfigFile.size(); ++i)
			if(RawMainConfigFile[i].Name == "General")
				GeneralPoolIndex = i;
		if(GeneralPoolIndex == -1)
		{
			ldbg.send("(Sys1 Exeption) Unable to load main config file : file is corrupted (Cannot find 'General' Balise), will prompt to create a new one");
			ProfileMgr.isCurrentProfileValid = false;
		}
		else
			ProfileMgr.setCurrent(ProfileMgr.Load("Players Profiles Datas/"+StringFromName(RawMainConfigFile[GeneralPoolIndex],"ActiveProfile")+"/MainFile.cfg"));
	}
}namuh_system::~namuh_system(void) //Destructeur
{
	// write the main config file	// construit les Datapools qui contiendront toutes les données a enregister
	std::vector<NamedDataPool*>Config_data;
	// General
	Config_data.push_back(new NamedDataPool);
	Config_data.back()->Name = "General";
		Config_data.back()->String_Data.push_back(*(new NamedString));
		Config_data.back()->String_Data.back().Name = "ActiveProfile";
		Config_data.back()->String_Data.back().data = ProfileMgr.getCurrent()->Name;
	// Write the file
	File_Serialiser.WriteFile(Config_data,"Namuh.cfg");	// Write down the current user profile
	ProfileMgr.SaveAs(ProfileMgr.ProfilePath+"MainFile.cfg",ProfileMgr.getCurrent());;
}
void namuh_system::render (bool force_full_render)
{/*
	sys0.mRoot->_fireFrameStarted();	
	Ogre::SceneManagerEnumerator::SceneManagerIterator::iterator a = sys0.mRoot->getSceneManagerIterator().begin();
	Ogre::SceneManagerEnumerator::SceneManagerIterator::iterator b = sys0.mRoot->getSceneManagerIterator().end();
	b--;	//Rendu de toutes les render tagets sauf la principale
	MapIterator<Ogre::RenderTargetMap> it = sys0.mRoot->getRenderSystem()->getRenderTargetIterator();
	MapIterator<Ogre::RenderTargetMap>::iterator itarg;	for( itarg = it.begin(); itarg != it.end(); ++itarg )
	{
		if( itarg->second->isActive() && !itarg->second->isAutoUpdated() &&  itarg->second->getName() != sys0.windowName)
				itarg->second->update(false);
	}
	sys0.mRoot->getRenderTarget(sys0.windowName)->update(false);
	// give client app opportunity to use queued GPU time
	sys0.mRoot->_fireFrameRenderingQueued();
	// block for final swap
	sys0.mRoot->getRenderSystem()->_swapAllRenderTargetBuffers(sys0.mRoot->getRenderSystem()->getWaitForVerticalBlank());
	sys0.mRoot->getRenderTarget(sys0.windowName)->swapBuffers(sys0.mRoot->getRenderSystem()->getWaitForVerticalBlank());	// This belongs here, as all render targets must be updated before events are
	// triggered, otherwise targets could be mismatched.  This could produce artifacts,
	// for instance, with shadows.
	for (SceneManagerEnumerator::SceneManagerIterator it = sys0.mRoot->getSceneManagerIterator(); it.hasMoreElements(); it.moveNext())
		it.peekNextValue()->_handleLodEvents();	sys0.mRoot->_fireFrameEnded();*/	sys0.mRoot->_fireFrameStarted();
	
	//Rendu de toutes les render tagets sauf la principale
	MapIterator<Ogre::RenderTargetMap> it = sys0.mRoot->getRenderSystem()->getRenderTargetIterator();
	MapIterator<Ogre::RenderTargetMap>::iterator itarg = it.begin();	for( itarg = it.begin(); itarg != it.end(); ++itarg )
	{
		if( itarg->second->isActive() && !itarg->second->isAutoUpdated() &&  itarg->second->getName() != sys0.windowName)
				itarg->second->update(false);
	}	if (force_full_render) // termine le rendu si demandé (comportement par défault)
	{
		
	
		if(Hydrax_man.initialised)
			Hydrax_man.mHydrax->updateOnlyRTT(0.0f);		sys0.mRoot->getRenderTarget(sys0.windowName)->update(false);
		// give client app opportunity to use queued GPU time
		sys0.mRoot->_fireFrameRenderingQueued();
		// block for final swap
		sys0.mRoot->getRenderSystem()->_swapAllRenderTargetBuffers(sys0.mRoot->getRenderSystem()->getWaitForVerticalBlank());
		sys0.mRoot->getRenderTarget(sys0.windowName)->swapBuffers(sys0.mRoot->getRenderSystem()->getWaitForVerticalBlank());		// This belongs here, as all render targets must be updated before events are
		// triggered, otherwise targets could be mismatched.  This could produce artifacts,
		// for instance, with shadows.
		for (SceneManagerEnumerator::SceneManagerIterator it = sys0.mRoot->getSceneManagerIterator(); it.hasMoreElements(); it.moveNext())
			it.peekNextValue()->_handleLodEvents();
		sys0.mRoot->_fireFrameEnded();
	}
	//sys0.RefractionRenderTarget->update(); // Rafraichie la réfraction
}
void  namuh_system::update(float time, bool force_full_render)
{
	namuh_system::update_wo_render();
	namuh_system::render(force_full_render);
}
void  namuh_system::update_wo_render(void)
{
	// Update des Stats
	MoyFPS = sys0.win->getAverageFPS();
	FPS = sys0.win->getLastFPS();
	BestFPS = sys0.win->getBestFPS();
	WorstFPS = sys0.win->getWorstFPS();
	Polycount = sys0.win->getTriangleCount();
		
    Ogre::WindowEventUtilities::messagePump(); //guette des messages de windows (Type Verr MAJ ou Shift)
    sys0.mKeyboard->capture(); // Met a jour le clavier
	sys0.update_SmartMouse(); // Toujours a appeller avant le getMouseState
    sys0.mMouse->capture(); const OIS::MouseState &ms = sys0.mMouse->getMouseState(); // Met a jour la souris
    if(!sys0.mKeyboard->isKeyDown(OIS::KC_ESCAPE) && escQuit && last_esc) // Quitte si Echap
    {
        LogManager::getSingletonPtr()->logMessage("*** Quit command (Escape) ***");
        MustQuit = true;
    }
	last_esc = sys0.mKeyboard->isKeyDown(OIS::KC_ESCAPE);
}
void namuh_system::logmsg(string msg)
{
    LogManager::getSingletonPtr()->logMessage(msg,LML_CRITICAL);
}
void namuh_system::resetMustQuit(void)
{
    MustQuit = last_esc = false;
}
void namuh_system::giveWaches(void)
{
    GuiSandboxMan.Watch_PagedGeometry = 100 * Watch_PagedGeometry / (Watch_LoopEnd - Watch_LoopStart);
	GuiSandboxMan.Watch_PhysX = 100 * Watch_PhysX / (Watch_LoopEnd - Watch_LoopStart);
	GuiSandboxMan.Watch_UI = 100 * Watch_UI / (Watch_LoopEnd - Watch_LoopStart);
	GuiSandboxMan.Watch_Hydrax = 100 * Watch_Hydrax / (Watch_LoopEnd - Watch_LoopStart);
	GuiSandboxMan.Watch_Atm = 100 * Watch_Atm / (Watch_LoopEnd - Watch_LoopStart);
	GuiSandboxMan.Watch_Terrain = 100 * Watch_Terrain / (Watch_LoopEnd - Watch_LoopStart);
	GuiSandboxMan.Watch_Sys =  100 * Watch_Sys1 / (Watch_LoopEnd - Watch_LoopStart);
}
BOOL IsDots(const TCHAR* str)
{
    if(_tcscmp(str,".") && _tcscmp(str,"..")) return FALSE;
    return TRUE;
}BOOL DeleteDirectory(const TCHAR* sPath) 
{
	HANDLE hFind; // file handle
	WIN32_FIND_DATA FindFileData;
	 
	TCHAR DirPath[MAX_PATH];
	TCHAR FileName[MAX_PATH];
	 
	_tcscpy(DirPath,sPath);
	_tcscat(DirPath,"\\*"); // searching all files
	_tcscpy(FileName,sPath);
	_tcscat(FileName,"\\");
	 
	// find the first file
	hFind = FindFirstFile(DirPath,&FindFileData);
	if(hFind == INVALID_HANDLE_VALUE) return FALSE;
	_tcscpy(DirPath,FileName);
	 
	bool bSearch = true;
	while(bSearch) 
	{ // until we find an entry
		if(FindNextFile(hFind,&FindFileData)) 
		{
			if(IsDots(FindFileData.cFileName)) continue;
			_tcscat(FileName,FindFileData.cFileName);
			if((FindFileData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY))
			{
				// we have found a directory, recurse
				if(!DeleteDirectory(FileName)) 
				{
					FindClose(hFind);
					return FALSE; // directory couldn't be deleted
				}
			// remove the empty directory
			RemoveDirectory(FileName);
			_tcscpy(FileName,DirPath);
			}
			else
			{
				if(!DeleteFile(FileName))
				{ // delete the file
					FindClose(hFind);
					return FALSE;
				}
				_tcscpy(FileName,DirPath);
			}
		}
		else 
		{
			// no more files there
			if(GetLastError() == ERROR_NO_MORE_FILES)
			bSearch = false;
			else
			{
				// some error occurred; close the handle and return FALSE
				FindClose(hFind);
				return FALSE;
			}
		}
	}
	FindClose(hFind); // close the file handle
	return RemoveDirectory(sPath); // remove the empty directory
}
#include "Namuh_Main_H.h"using namespace Ogre;
// Code des méthodes de la classe
Vie_Hud::Vie_Hud(void)
{
	initialised = false;
}
Vie_Hud::~Vie_Hud(void)
{
}void Vie_Hud::initialise()
{
	initialised = true;
	vie = 100;
	overlay =  Ogre::OverlayManager::getSingleton().create( "VieOverlay" );
	overlay->show();
	
	// Create the graph's texture and store a pointer of it
	Texture = TextureManager::getSingleton().createManual(
		"Affichage vie "+ StringConverter::toString(sys0.timer.getMicroseconds()), // name
		ResourceGroupManager::DEFAULT_RESOURCE_GROUP_NAME,
		TEX_TYPE_2D,      // type
		256,256,     // width & height
		0,                // number of mipmaps
		PF_BYTE_RGBA,     // pixel format
		TU_DYNAMIC_WRITE_ONLY);
	PixelBuffer = Texture->getBuffer();
	 
	// Generate the image
	PixelBuffer->lock(HardwareBuffer::HBL_DISCARD);
	const PixelBox& PixelBox = PixelBuffer->getCurrentLock();	Ogre::uint32 *data = static_cast<Ogre::uint32*>(PixelBox.data);
	size_t height = PixelBox.getHeight();
	size_t width = PixelBox.getWidth();
	size_t pitch = PixelBox.rowPitch; // Skip between rows of image	for(size_t y=0; y<height; ++y)
		for(size_t x=0; x<width; ++x)
			data[pitch*y + x] =  static_cast<Ogre::uint32>(Ogre::ColourValue::ZERO.getAsARGB());		
	for(int i=0;i<360;i++)
	{
		Ogre::uint	x = 128+(50+7*(float(i)*0.01*vie/360))*Ogre::Math::Cos(Ogre::Degree(i)),
					y = 128+(50+7*(float(i)*0.01*vie/360))*Ogre::Math::Sin(Ogre::Degree(i));
		data[pitch*y + x] = Ogre::ColourValue::Red.getAsARGB();
	}	// Réticule
	for(size_t y=127; y<129; ++y)
		for(size_t x=127; x<129; ++x)
			data[pitch*y + x] =  Ogre::ColourValue::Red.getAsARGB();	PixelBuffer->unlock();	// Create a material using the texture
	MaterialPtr material = MaterialManager::getSingleton().create(Texture->getName(),ResourceGroupManager::DEFAULT_RESOURCE_GROUP_NAME);
	material->getTechnique(0)->getPass(0)->createTextureUnitState(Texture->getName());
	material->getTechnique(0)->getPass(0)->setSceneBlending(SBT_TRANSPARENT_ALPHA);	// Create a panel
	panel = static_cast<Ogre::OverlayContainer*>(OverlayManager::getSingleton().createOverlayElement("Panel",Texture->getName()));
	panel->setMetricsMode(Ogre::GMM_PIXELS);
	panel->setPosition(sys0.vp->getActualWidth()/2-128,sys0.vp->getActualHeight()/2-128);
	panel->setDimensions(256,256);
	panel->setMaterialName(material->getName());
	overlay->add2D(panel);
}void Vie_Hud::set(int requested_vie)
{
	vie = requested_vie;
	if(initialised)
	{
		// Regenerate the image
		PixelBuffer->lock(HardwareBuffer::HBL_DISCARD);
		const PixelBox& PixelBox = PixelBuffer->getCurrentLock();		Ogre::uint32 *data = static_cast<Ogre::uint32*>(PixelBox.data);
		size_t height = PixelBox.getHeight();
		size_t width = PixelBox.getWidth();
		size_t pitch = PixelBox.rowPitch; // Skip between rows of image		for(size_t y=0; y<height; ++y)
			for(size_t x=0; x<width; ++x)
				data[pitch*y + x] =  static_cast<Ogre::uint32>(Ogre::ColourValue::ZERO.getAsARGB());			
		for(int i=0;i<360;i++)
		{
			Ogre::uint	x = 128+(50+7*(float(i)*0.01*vie/360))*Ogre::Math::Cos(Ogre::Degree(i)),
						y = 128+(50+7*(float(i)*0.01*vie/360))*Ogre::Math::Sin(Ogre::Degree(i));
			data[pitch*y + x] = Ogre::ColourValue::Red.getAsARGB();		}		// Réticule
		for(size_t y=127; y<129; ++y)
			for(size_t x=127; x<129; ++x)
				data[pitch*y + x] =  Ogre::ColourValue::Red.getAsARGB();		PixelBuffer->unlock();
	}}